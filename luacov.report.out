
==============================================================================
.////src/dropbox.lua
==============================================================================
    	-- https://github.com/JakobGreen/lua-requests/wiki
   1	local requests = require 'requests'
   1	local json = require 'cjson.safe'
   1	local pp = require 'pprint'
    	
    	-- Constants
    	
   1	local DROPBOX_RPC_ENDPOINT = 'https://api.dropboxapi.com/2/'
   1	local DROPBOX_CONTENT_ENDPOINT = 'https://content.dropboxapi.com/2/'
    	
    	-- Module vars
    	
    	local token
    	
    	-- Private functions
    	
    	local function add_auth(tbl)
   8	  tbl["Authorization"] = "Bearer "..token
   8	  return tbl
    	end
    	
    	local function json_resp(response)
    	  local err
   8	  if response.status_code >= 400 then
   1	    err = response.text
    	  end
   8	  return response.json(), err
    	end
    	
    	local function make_rpc_request(reqfunc, endpoint, data)
  14	  local headers = add_auth{
   7	    ["Content-Type"] = 'application/json'
    	  }
  14	  local response = reqfunc(DROPBOX_RPC_ENDPOINT .. endpoint, {
   7	    headers = headers,
   7	    data = data
    	  })
   7	  return json_resp(response)
    	end
    	
    	local function make_content_request(reqfunc, endpoint, data, content)
   2	  local headers = add_auth{
   1	    ["Content-Type"] = 'application/octet-stream',
   1	    ["Dropbox-API-Arg"] = json.encode(data)
    	  }
   2	  local response = reqfunc(DROPBOX_CONTENT_ENDPOINT .. endpoint, {
   1	    headers = headers,
   1	    data = content
    	  })
   1	  return json_resp(response)
    	end
    	
    	-- Public functions
    	
    	local function set_token(tk)
   1	  token = tk
    	end
    	
    	local function list_folder(path, recursive, include_media_info, include_deleted)
    	  -- https://www.dropbox.com/developers/documentation/http/documentation#files-list_folder
   1	  local message = {
   1	    path = path,
   1	    recursive = recursive,
   1	    include_media_info = include_media_info,
   1	    include_deleted = include_deleted
    	  }
   1	  return make_rpc_request(requests.post, 'files/list_folder', message)
    	end
    	
    	local function list_folder_continue(cursor)
    	  -- https://www.dropbox.com/developers/documentation/http/documentation#files-list_folder-continue
***0	  local message = {
***0	    cursor = cursor
    	  }
***0	  return make_rpc_request(requests.post, 'files/list_folder/continue', message)
    	end
    	
    	local function create_folder(path)
   2	  local message = {
   2	    path = path
    	  }
   2	  return make_rpc_request(requests.post, 'files/create_folder', message)
    	end
    	
    	local function cursor(res)
***0	  local results = res
***0	  local pos = 0
***0	  local local_pos = 0
    	  return function()
***0	    pos = pos + 1
***0	    local_pos = local_pos + 1
***0	    if not results.entries[local_pos] and results.has_more then
***0	      local_pos = 1
***0	      results = list_folder_continue(results.cursor)
    	    end
***0	    return results.entries[local_pos], pos
    	  end
    	end
    	
    	local function upload(path, data)
    	  -- https://www.dropbox.com/developers/documentation/http/documentation#files-upload
    	  -- TODO This function should only be used for small files,
    	  --      Dropbox limit 150 MB
   1	  local message = {
   1	    path = path,
   1	    mode = "add",
   1	    autorename = true,
   1	    mute = false
    	  }
   1	  return make_content_request(requests.post, 'files/upload', message, data)
    	end
    	
    	local function copy(from_path, to_path)
   1	  local message = {
   1	    from_path = from_path,
   1	    to_path = to_path
    	  }
   1	  return make_rpc_request(requests.post, 'files/copy', message)
    	end
    	
    	local function delete(path)
   3	  local message = {
   3	    path = path
    	  }
   3	  return make_rpc_request(requests.post, 'files/delete', message)
    	end
    	
   1	return {
   1	  list_folder = list_folder,
   1	  create_folder = create_folder,
   1	  set_token = set_token,
   1	  delete = delete,
   1	  copy = copy,
   1	  cursor = cursor,
   1	  upload = upload
   1	}

==============================================================================
.////src/pprint.lua
==============================================================================
   1	local pprint = { VERSION = '0.1' }
    	
   1	pprint.defaults = {
    	    -- type display trigger, hide not useful datatypes by default
    	    -- custom types are treated as table
   1	    show_nil = true,
   1	    show_boolean = true,
   1	    show_number = true,
   1	    show_string = true,
   1	    show_table = true,
   1	    show_function = false,
   1	    show_thread = false,
   1	    show_userdata = false,
    	    -- additional display trigger
   1	    show_metatable = false,     -- show metatable
   1	    show_all = false,           -- override other show settings and show everything
   1	    use_tostring = false,       -- use __tostring to print table if available
   1	    filter_function = nil,      -- called like callback(value[,key, parent]), return truty value to hide
   1	    object_cache = 'local',     -- cache blob and table to give it a id, 'local' cache per print, 'global' cache
    	                                -- per process, falsy value to disable (might cause infinite loop)
    	    -- format settings
   1	    indent_size = 2,            -- indent for each nested table level
   1	    level_width = 80,           -- max width per indent level
   1	    wrap_string = true,         -- wrap string when it's longer than level_width
   1	    wrap_array = false,         -- wrap every array elements
   1	    sort_keys = true,           -- sort table keys
   1	}
    	
   1	local TYPES = {
   1	    ['nil'] = 1, ['boolean'] = 2, ['number'] = 3, ['string'] = 4, 
   1	    ['table'] = 5, ['function'] = 6, ['thread'] = 7, ['userdata'] = 8
    	}
    	
    	-- seems this is the only way to escape these, as lua don't know how to map char '\a' to 'a'
   1	local ESCAPE_MAP = {
   1	    ['\a'] = '\\a', ['\b'] = '\\b', ['\f'] = '\\f', ['\n'] = '\\n', ['\r'] = '\\r',
   1	    ['\t'] = '\\t', ['\v'] = '\\v', ['\\'] = '\\\\',
    	}
    	
    	-- generic utilities
    	local function escape(s)
***0	    s = s:gsub('([%c\\])', ESCAPE_MAP)
***0	    local dq = s:find('"') 
***0	    local sq = s:find("'")
***0	    if dq and sq then
***0	        return s:gsub('"', '\\"'), '"'
***0	    elseif sq then
***0	        return s, '"'
    	    else
***0	        return s, "'"
    	    end
    	end
    	
    	local function is_plain_key(key)
***0	    return type(key) == 'string' and key:match('^[%a_][%a%d_]*$')
    	end
    	
   1	local CACHE_TYPES = {
   1	    ['table'] = true, ['function'] = true, ['thread'] = true, ['userdata'] = true
    	}
    	
    	-- cache would be populated to be like:
    	-- {
    	--     function = { `fun1` = 1, _cnt = 1 }, -- object id
    	--     table = { `table1` = 1, `table2` = 2, _cnt = 2 },
    	--     visited_tables = { `table1` = 7, `table2` = 8  }, -- visit count
    	-- }
    	-- use weakrefs to avoid accidentall adding refcount
    	local function cache_apperance(obj, cache, option)
***0	    if not cache.visited_tables then
***0	        cache.visited_tables = setmetatable({}, {__mode = 'k'})
    	    end
***0	    local t = type(obj)
    	
    	    -- TODO can't test filter_function here as we don't have the ix and key,
    	    -- might cause different results?
    	    -- respect show_xxx and filter_function to be consistent with print results
***0	    if (not TYPES[t] and not option.show_table)
***0	        or (TYPES[t] and not option['show_'..t]) then
***0	        return
    	    end
    	
***0	    if CACHE_TYPES[t] or TYPES[t] == nil then
***0	        if not cache[t] then
***0	            cache[t] = setmetatable({}, {__mode = 'k'})
***0	            cache[t]._cnt = 0
    	        end
***0	        if not cache[t][obj] then
***0	            cache[t]._cnt = cache[t]._cnt + 1
***0	            cache[t][obj] = cache[t]._cnt
    	        end
    	    end
***0	    if t == 'table' or TYPES[t] == nil then
***0	        if cache.visited_tables[obj] == false then
    	            -- already printed, no need to mark this and its children anymore
***0	            return
***0	        elseif cache.visited_tables[obj] == nil then
***0	            cache.visited_tables[obj] = 1
    	        else
    	            -- visited already, increment and continue
***0	            cache.visited_tables[obj] = cache.visited_tables[obj] + 1
***0	            return
    	        end
***0	        for k, v in pairs(obj) do
***0	            cache_apperance(k, cache, option)
***0	            cache_apperance(v, cache, option)
    	        end
***0	        local mt = getmetatable(obj)
***0	        if mt and option.show_metatable then
***0	            cache_apperance(mt, cache, option)
    	        end
    	    end
    	end
    	
    	-- makes 'foo2' < 'foo100000'. string.sub makes substring anyway, no need to use index based method
    	local function str_natural_cmp(lhs, rhs)
***0	    while #lhs > 0 and #rhs > 0 do
***0	        local lmid, lend = lhs:find('%d+')
***0	        local rmid, rend = rhs:find('%d+')
***0	        if not (lmid and rmid) then return lhs < rhs end
    	
***0	        local lsub = lhs:sub(1, lmid-1)
***0	        local rsub = rhs:sub(1, rmid-1)
***0	        if lsub ~= rsub then
***0	            return lsub < rsub
    	        end
    	        
***0	        local lnum = tonumber(lhs:sub(lmid, lend))
***0	        local rnum = tonumber(rhs:sub(rmid, rend))
***0	        if lnum ~= rnum then
***0	            return lnum < rnum
    	        end
    	
***0	        lhs = lhs:sub(lend+1)
***0	        rhs = rhs:sub(rend+1)
    	    end
***0	    return lhs < rhs
    	end
    	
    	local function cmp(lhs, rhs)
***0	    local tleft = type(lhs)
***0	    local tright = type(rhs)
***0	    if tleft == 'number' and tright == 'number' then return lhs < rhs end
***0	    if tleft == 'string' and tright == 'string' then return str_natural_cmp(lhs, rhs) end
***0	    if tleft == tright then return str_natural_cmp(tostring(lhs), tostring(rhs)) end
    	
    	    -- allow custom types
***0	    local oleft = TYPES[tleft] or 9
***0	    local oright = TYPES[tright] or 9
***0	    return oleft < oright
    	end
    	
    	-- setup option with default
    	local function make_option(option)
***0	    if option == nil then
***0	        option = {}
    	    end
***0	    for k, v in pairs(pprint.defaults) do
***0	        if option[k] == nil then
***0	            option[k] = v
    	        end
***0	        if option.show_all then
***0	            for t, _ in pairs(TYPES) do
***0	                option['show_'..t] = true
    	            end
***0	            option.show_metatable = true
    	        end
    	    end
***0	    return option
    	end
    	
    	-- override defaults and take effects for all following calls
   1	function pprint.setup(option)
***0	    pprint.defaults = make_option(option)
    	end
    	
    	-- format lua object into a string
   1	function pprint.pformat(obj, option, printer)
***0	    option = make_option(option)
***0	    local buf = {}
    	    local function default_printer(s)
***0	        table.insert(buf, s)
    	    end
***0	    printer = printer or default_printer
    	
    	    local cache
***0	    if option.object_cache == 'global' then
    	        -- steal the cache into a local var so it's not visible from _G or anywhere
    	        -- still can't avoid user explicitly referentce pprint._cache but it shouldn't happen anyway
***0	        cache = pprint._cache or {}
***0	        pprint._cache = nil
***0	    elseif option.object_cache == 'local' then
***0	        cache = {}
    	    end
    	
***0	    local last = '' -- used for look back and remove trailing comma
***0	    local status = {
    	        indent = '', -- current indent
    	        len = 0,     -- current line length
    	    }
    	
    	    local wrapped_printer = function(s)
***0	        printer(last)
***0	        last = s
    	    end
    	
    	    local function _indent(d)
***0	        status.indent = string.rep(' ', d + #(status.indent))
    	    end
    	
    	    local function _n(d)
***0	        wrapped_printer('\n')
***0	        wrapped_printer(status.indent)
***0	        if d then
***0	            _indent(d)
    	        end
***0	        status.len = 0
***0	        return true -- used to close bracket correctly
    	    end
    	
    	    local function _p(s, nowrap)
***0	        status.len = status.len + #s
***0	        if not nowrap and status.len > option.level_width then
***0	            _n()
***0	            wrapped_printer(s)
***0	            status.len = #s
    	        else
***0	            wrapped_printer(s)
    	        end
    	    end
    	
***0	    local formatter = {}
    	    local function format(v)
***0	        local f = formatter[type(v)]
***0	        f = f or formatter.table -- allow patched type()
***0	        if option.filter_function and option.filter_function(v, nil, nil) then
***0	            return ''
    	        else
***0	            return f(v)
    	        end
    	    end
    	
    	    local function tostring_formatter(v)
***0	        return tostring(v)
    	    end
    	
    	    local function number_formatter(n)
***0	        return n == math.huge and '[[math.huge]]' or tostring(n)
    	    end
    	
    	    local function nop_formatter(v)
***0	        return ''
    	    end
    	
    	    local function make_fixed_formatter(t, has_cache)
***0	        if has_cache then
    	            return function (v)
***0	                return string.format('[[%s %d]]', t, cache[t][v])
    	            end
    	        else
    	            return function (v)
***0	                return '[['..t..']]'
    	            end
    	        end
    	    end
    	
    	    local function string_formatter(s, force_long_quote)
***0	        local s, quote = escape(s)
***0	        local quote_len = force_long_quote and 4 or 2
***0	        if quote_len + #s + status.len > option.level_width then
***0	            _n()
    	            -- only wrap string when is longer than level_width
***0	            if option.wrap_string and #s + quote_len > option.level_width then
    	                -- keep the quotes together
***0	                _p('[[')
***0	                while #s + status.len >= option.level_width do
***0	                    local seg = option.level_width - status.len
***0	                    _p(string.sub(s, 1, seg), true)
***0	                    _n()
***0	                    s = string.sub(s, seg+1)
    	                end
***0	                _p(s) -- print the remaining parts
***0	                return ']]' 
    	            end
    	        end
    	
***0	        return force_long_quote and '[['..s..']]' or quote..s..quote
    	    end
    	
    	    local function table_formatter(t)
***0	        if option.use_tostring then
***0	            local mt = getmetatable(t)
***0	            if mt and mt.__tostring then
***0	                return string_formatter(tostring(t), true)
    	            end
    	        end
    	
    	        local print_header_ix = nil
***0	        local ttype = type(t)
***0	        if option.object_cache then
***0	            local cache_state = cache.visited_tables[t]
***0	            local tix = cache[ttype][t]
    	            -- FIXME should really handle `cache_state == nil`
    	            -- as user might add things through filter_function
***0	            if cache_state == false then
    	                -- already printed, just print the the number
***0	                return string_formatter(string.format('%s %d', ttype, tix), true)
***0	            elseif cache_state > 1 then
    	                -- appeared more than once, print table header with number
***0	                print_header_ix = tix
***0	                cache.visited_tables[t] = false
    	            else
    	                -- appeared exactly once, print like a normal table
    	            end
    	        end
    	
***0	        local tlen = #t
***0	        local wrapped = false
***0	        _p('{')
***0	        _indent(option.indent_size)
***0	        _p(string.rep(' ', option.indent_size - 1))
***0	        if print_header_ix then
***0	            _p(string.format('--[[%s %d]] ', ttype, print_header_ix))
    	        end
***0	        for ix = 1,tlen do
***0	            local v = t[ix]
***0	            if formatter[type(v)] == nop_formatter or 
***0	               (option.filter_function and option.filter_function(v, ix, t)) then
    	               -- pass
    	            else
***0	                if option.wrap_array then
***0	                    wrapped = _n()
    	                end
***0	                _p(format(v)..', ')
    	            end
    	        end
    	
    	        -- hashmap part of the table, in contrast to array part
    	        local function is_hash_key(k)
***0	            local numkey = tonumber(k)
***0	            if numkey ~= k or numkey > tlen then
***0	                return true
    	            end
    	        end
    	
    	        local function print_kv(k, v, t)
    	            -- can't use option.show_x as obj may contain custom type
***0	            if formatter[type(v)] == nop_formatter or
***0	               formatter[type(k)] == nop_formatter or 
***0	               (option.filter_function and option.filter_function(v, k, t)) then
***0	                return
    	            end
***0	            wrapped = _n()
***0	            if is_plain_key(k) then
***0	                _p(k, true)
    	            else
***0	                _p('[')
    	                -- [[]] type string in key is illegal, needs to add spaces inbetween
***0	                local k = format(k)
***0	                if string.match(k, '%[%[') then
***0	                    _p(' '..k..' ', true)
    	                else
***0	                    _p(k, true)
    	                end
***0	                _p(']')
    	            end
***0	            _p(' = ', true)
***0	            _p(format(v), true)
***0	            _p(',', true)
    	        end
    	
***0	        if option.sort_keys then
***0	            local keys = {}
***0	            for k, _ in pairs(t) do
***0	                if is_hash_key(k) then
***0	                    table.insert(keys, k)
    	                end
    	            end
***0	            table.sort(keys, cmp)
***0	            for _, k in ipairs(keys) do
***0	                print_kv(k, t[k], t)
    	            end
    	        else
***0	            for k, v in pairs(t) do
***0	                if is_hash_key(k) then
***0	                    print_kv(k, v, t)
    	                end
    	            end
    	        end
    	
***0	        if option.show_metatable then
***0	            local mt = getmetatable(t)
***0	            if mt then
***0	                print_kv('__metatable', mt, t)
    	            end
    	        end
    	
***0	        _indent(-option.indent_size)
    	        -- make { } into {}
***0	        last = string.gsub(last, '^ +$', '')
    	        -- peek last to remove trailing comma
***0	        last = string.gsub(last, ',%s*$', ' ')
***0	        if wrapped then
***0	            _n()
    	        end
***0	        _p('}')
    	
***0	        return ''
    	    end
    	
    	    -- set formatters
***0	    formatter['nil'] = option.show_nil and tostring_formatter or nop_formatter
***0	    formatter['boolean'] = option.show_boolean and tostring_formatter or nop_formatter
***0	    formatter['number'] = option.show_number and number_formatter or nop_formatter -- need to handle math.huge
***0	    formatter['function'] = option.show_function and make_fixed_formatter('function', option.object_cache) or nop_formatter
***0	    formatter['thread'] = option.show_thread and make_fixed_formatter('thread', option.object_cache) or nop_formatter
***0	    formatter['userdata'] = option.show_userdata and make_fixed_formatter('userdata', option.object_cache) or nop_formatter
***0	    formatter['string'] = option.show_string and string_formatter or nop_formatter
***0	    formatter['table'] = option.show_table and table_formatter or nop_formatter
    	
***0	    if option.object_cache then
    	        -- needs to visit the table before start printing
***0	        cache_apperance(obj, cache, option)
    	    end
    	
***0	    _p(format(obj))
***0	    printer(last) -- close the buffered one
    	
    	    -- put cache back if global
***0	    if option.object_cache == 'global' then
***0	        pprint._cache = cache
    	    end
    	
***0	    return table.concat(buf)
    	end
    	
    	-- pprint all the arguments
   1	function pprint.pprint( ... )
***0	    local args = {...}
    	    -- select will get an accurate count of array len, counting trailing nils
***0	    local len = select('#', ...)
***0	    for ix = 1,len do
***0	        pprint.pformat(args[ix], nil, io.write)
***0	        io.write('\n')
    	    end
    	end
    	
   2	setmetatable(pprint, {
    	    __call = function (_, ...)
***0	        pprint.pprint(...)
    	    end
    	})
    	
   1	return pprint
    	

==============================================================================
./src/pprint.lua
==============================================================================
   1	local pprint = { VERSION = '0.1' }
    	
   1	pprint.defaults = {
    	    -- type display trigger, hide not useful datatypes by default
    	    -- custom types are treated as table
   1	    show_nil = true,
   1	    show_boolean = true,
   1	    show_number = true,
   1	    show_string = true,
   1	    show_table = true,
   1	    show_function = false,
   1	    show_thread = false,
   1	    show_userdata = false,
    	    -- additional display trigger
   1	    show_metatable = false,     -- show metatable
   1	    show_all = false,           -- override other show settings and show everything
   1	    use_tostring = false,       -- use __tostring to print table if available
   1	    filter_function = nil,      -- called like callback(value[,key, parent]), return truty value to hide
   1	    object_cache = 'local',     -- cache blob and table to give it a id, 'local' cache per print, 'global' cache
    	                                -- per process, falsy value to disable (might cause infinite loop)
    	    -- format settings
   1	    indent_size = 2,            -- indent for each nested table level
   1	    level_width = 80,           -- max width per indent level
   1	    wrap_string = true,         -- wrap string when it's longer than level_width
   1	    wrap_array = false,         -- wrap every array elements
   1	    sort_keys = true,           -- sort table keys
   1	}
    	
   1	local TYPES = {
   1	    ['nil'] = 1, ['boolean'] = 2, ['number'] = 3, ['string'] = 4, 
   1	    ['table'] = 5, ['function'] = 6, ['thread'] = 7, ['userdata'] = 8
    	}
    	
    	-- seems this is the only way to escape these, as lua don't know how to map char '\a' to 'a'
   1	local ESCAPE_MAP = {
   1	    ['\a'] = '\\a', ['\b'] = '\\b', ['\f'] = '\\f', ['\n'] = '\\n', ['\r'] = '\\r',
   1	    ['\t'] = '\\t', ['\v'] = '\\v', ['\\'] = '\\\\',
    	}
    	
    	-- generic utilities
    	local function escape(s)
***0	    s = s:gsub('([%c\\])', ESCAPE_MAP)
***0	    local dq = s:find('"') 
***0	    local sq = s:find("'")
***0	    if dq and sq then
***0	        return s:gsub('"', '\\"'), '"'
***0	    elseif sq then
***0	        return s, '"'
    	    else
***0	        return s, "'"
    	    end
    	end
    	
    	local function is_plain_key(key)
***0	    return type(key) == 'string' and key:match('^[%a_][%a%d_]*$')
    	end
    	
   1	local CACHE_TYPES = {
   1	    ['table'] = true, ['function'] = true, ['thread'] = true, ['userdata'] = true
    	}
    	
    	-- cache would be populated to be like:
    	-- {
    	--     function = { `fun1` = 1, _cnt = 1 }, -- object id
    	--     table = { `table1` = 1, `table2` = 2, _cnt = 2 },
    	--     visited_tables = { `table1` = 7, `table2` = 8  }, -- visit count
    	-- }
    	-- use weakrefs to avoid accidentall adding refcount
    	local function cache_apperance(obj, cache, option)
***0	    if not cache.visited_tables then
***0	        cache.visited_tables = setmetatable({}, {__mode = 'k'})
    	    end
***0	    local t = type(obj)
    	
    	    -- TODO can't test filter_function here as we don't have the ix and key,
    	    -- might cause different results?
    	    -- respect show_xxx and filter_function to be consistent with print results
***0	    if (not TYPES[t] and not option.show_table)
***0	        or (TYPES[t] and not option['show_'..t]) then
***0	        return
    	    end
    	
***0	    if CACHE_TYPES[t] or TYPES[t] == nil then
***0	        if not cache[t] then
***0	            cache[t] = setmetatable({}, {__mode = 'k'})
***0	            cache[t]._cnt = 0
    	        end
***0	        if not cache[t][obj] then
***0	            cache[t]._cnt = cache[t]._cnt + 1
***0	            cache[t][obj] = cache[t]._cnt
    	        end
    	    end
***0	    if t == 'table' or TYPES[t] == nil then
***0	        if cache.visited_tables[obj] == false then
    	            -- already printed, no need to mark this and its children anymore
***0	            return
***0	        elseif cache.visited_tables[obj] == nil then
***0	            cache.visited_tables[obj] = 1
    	        else
    	            -- visited already, increment and continue
***0	            cache.visited_tables[obj] = cache.visited_tables[obj] + 1
***0	            return
    	        end
***0	        for k, v in pairs(obj) do
***0	            cache_apperance(k, cache, option)
***0	            cache_apperance(v, cache, option)
    	        end
***0	        local mt = getmetatable(obj)
***0	        if mt and option.show_metatable then
***0	            cache_apperance(mt, cache, option)
    	        end
    	    end
    	end
    	
    	-- makes 'foo2' < 'foo100000'. string.sub makes substring anyway, no need to use index based method
    	local function str_natural_cmp(lhs, rhs)
***0	    while #lhs > 0 and #rhs > 0 do
***0	        local lmid, lend = lhs:find('%d+')
***0	        local rmid, rend = rhs:find('%d+')
***0	        if not (lmid and rmid) then return lhs < rhs end
    	
***0	        local lsub = lhs:sub(1, lmid-1)
***0	        local rsub = rhs:sub(1, rmid-1)
***0	        if lsub ~= rsub then
***0	            return lsub < rsub
    	        end
    	        
***0	        local lnum = tonumber(lhs:sub(lmid, lend))
***0	        local rnum = tonumber(rhs:sub(rmid, rend))
***0	        if lnum ~= rnum then
***0	            return lnum < rnum
    	        end
    	
***0	        lhs = lhs:sub(lend+1)
***0	        rhs = rhs:sub(rend+1)
    	    end
***0	    return lhs < rhs
    	end
    	
    	local function cmp(lhs, rhs)
***0	    local tleft = type(lhs)
***0	    local tright = type(rhs)
***0	    if tleft == 'number' and tright == 'number' then return lhs < rhs end
***0	    if tleft == 'string' and tright == 'string' then return str_natural_cmp(lhs, rhs) end
***0	    if tleft == tright then return str_natural_cmp(tostring(lhs), tostring(rhs)) end
    	
    	    -- allow custom types
***0	    local oleft = TYPES[tleft] or 9
***0	    local oright = TYPES[tright] or 9
***0	    return oleft < oright
    	end
    	
    	-- setup option with default
    	local function make_option(option)
***0	    if option == nil then
***0	        option = {}
    	    end
***0	    for k, v in pairs(pprint.defaults) do
***0	        if option[k] == nil then
***0	            option[k] = v
    	        end
***0	        if option.show_all then
***0	            for t, _ in pairs(TYPES) do
***0	                option['show_'..t] = true
    	            end
***0	            option.show_metatable = true
    	        end
    	    end
***0	    return option
    	end
    	
    	-- override defaults and take effects for all following calls
   1	function pprint.setup(option)
***0	    pprint.defaults = make_option(option)
    	end
    	
    	-- format lua object into a string
   1	function pprint.pformat(obj, option, printer)
***0	    option = make_option(option)
***0	    local buf = {}
    	    local function default_printer(s)
***0	        table.insert(buf, s)
    	    end
***0	    printer = printer or default_printer
    	
    	    local cache
***0	    if option.object_cache == 'global' then
    	        -- steal the cache into a local var so it's not visible from _G or anywhere
    	        -- still can't avoid user explicitly referentce pprint._cache but it shouldn't happen anyway
***0	        cache = pprint._cache or {}
***0	        pprint._cache = nil
***0	    elseif option.object_cache == 'local' then
***0	        cache = {}
    	    end
    	
***0	    local last = '' -- used for look back and remove trailing comma
***0	    local status = {
    	        indent = '', -- current indent
    	        len = 0,     -- current line length
    	    }
    	
    	    local wrapped_printer = function(s)
***0	        printer(last)
***0	        last = s
    	    end
    	
    	    local function _indent(d)
***0	        status.indent = string.rep(' ', d + #(status.indent))
    	    end
    	
    	    local function _n(d)
***0	        wrapped_printer('\n')
***0	        wrapped_printer(status.indent)
***0	        if d then
***0	            _indent(d)
    	        end
***0	        status.len = 0
***0	        return true -- used to close bracket correctly
    	    end
    	
    	    local function _p(s, nowrap)
***0	        status.len = status.len + #s
***0	        if not nowrap and status.len > option.level_width then
***0	            _n()
***0	            wrapped_printer(s)
***0	            status.len = #s
    	        else
***0	            wrapped_printer(s)
    	        end
    	    end
    	
***0	    local formatter = {}
    	    local function format(v)
***0	        local f = formatter[type(v)]
***0	        f = f or formatter.table -- allow patched type()
***0	        if option.filter_function and option.filter_function(v, nil, nil) then
***0	            return ''
    	        else
***0	            return f(v)
    	        end
    	    end
    	
    	    local function tostring_formatter(v)
***0	        return tostring(v)
    	    end
    	
    	    local function number_formatter(n)
***0	        return n == math.huge and '[[math.huge]]' or tostring(n)
    	    end
    	
    	    local function nop_formatter(v)
***0	        return ''
    	    end
    	
    	    local function make_fixed_formatter(t, has_cache)
***0	        if has_cache then
    	            return function (v)
***0	                return string.format('[[%s %d]]', t, cache[t][v])
    	            end
    	        else
    	            return function (v)
***0	                return '[['..t..']]'
    	            end
    	        end
    	    end
    	
    	    local function string_formatter(s, force_long_quote)
***0	        local s, quote = escape(s)
***0	        local quote_len = force_long_quote and 4 or 2
***0	        if quote_len + #s + status.len > option.level_width then
***0	            _n()
    	            -- only wrap string when is longer than level_width
***0	            if option.wrap_string and #s + quote_len > option.level_width then
    	                -- keep the quotes together
***0	                _p('[[')
***0	                while #s + status.len >= option.level_width do
***0	                    local seg = option.level_width - status.len
***0	                    _p(string.sub(s, 1, seg), true)
***0	                    _n()
***0	                    s = string.sub(s, seg+1)
    	                end
***0	                _p(s) -- print the remaining parts
***0	                return ']]' 
    	            end
    	        end
    	
***0	        return force_long_quote and '[['..s..']]' or quote..s..quote
    	    end
    	
    	    local function table_formatter(t)
***0	        if option.use_tostring then
***0	            local mt = getmetatable(t)
***0	            if mt and mt.__tostring then
***0	                return string_formatter(tostring(t), true)
    	            end
    	        end
    	
    	        local print_header_ix = nil
***0	        local ttype = type(t)
***0	        if option.object_cache then
***0	            local cache_state = cache.visited_tables[t]
***0	            local tix = cache[ttype][t]
    	            -- FIXME should really handle `cache_state == nil`
    	            -- as user might add things through filter_function
***0	            if cache_state == false then
    	                -- already printed, just print the the number
***0	                return string_formatter(string.format('%s %d', ttype, tix), true)
***0	            elseif cache_state > 1 then
    	                -- appeared more than once, print table header with number
***0	                print_header_ix = tix
***0	                cache.visited_tables[t] = false
    	            else
    	                -- appeared exactly once, print like a normal table
    	            end
    	        end
    	
***0	        local tlen = #t
***0	        local wrapped = false
***0	        _p('{')
***0	        _indent(option.indent_size)
***0	        _p(string.rep(' ', option.indent_size - 1))
***0	        if print_header_ix then
***0	            _p(string.format('--[[%s %d]] ', ttype, print_header_ix))
    	        end
***0	        for ix = 1,tlen do
***0	            local v = t[ix]
***0	            if formatter[type(v)] == nop_formatter or 
***0	               (option.filter_function and option.filter_function(v, ix, t)) then
    	               -- pass
    	            else
***0	                if option.wrap_array then
***0	                    wrapped = _n()
    	                end
***0	                _p(format(v)..', ')
    	            end
    	        end
    	
    	        -- hashmap part of the table, in contrast to array part
    	        local function is_hash_key(k)
***0	            local numkey = tonumber(k)
***0	            if numkey ~= k or numkey > tlen then
***0	                return true
    	            end
    	        end
    	
    	        local function print_kv(k, v, t)
    	            -- can't use option.show_x as obj may contain custom type
***0	            if formatter[type(v)] == nop_formatter or
***0	               formatter[type(k)] == nop_formatter or 
***0	               (option.filter_function and option.filter_function(v, k, t)) then
***0	                return
    	            end
***0	            wrapped = _n()
***0	            if is_plain_key(k) then
***0	                _p(k, true)
    	            else
***0	                _p('[')
    	                -- [[]] type string in key is illegal, needs to add spaces inbetween
***0	                local k = format(k)
***0	                if string.match(k, '%[%[') then
***0	                    _p(' '..k..' ', true)
    	                else
***0	                    _p(k, true)
    	                end
***0	                _p(']')
    	            end
***0	            _p(' = ', true)
***0	            _p(format(v), true)
***0	            _p(',', true)
    	        end
    	
***0	        if option.sort_keys then
***0	            local keys = {}
***0	            for k, _ in pairs(t) do
***0	                if is_hash_key(k) then
***0	                    table.insert(keys, k)
    	                end
    	            end
***0	            table.sort(keys, cmp)
***0	            for _, k in ipairs(keys) do
***0	                print_kv(k, t[k], t)
    	            end
    	        else
***0	            for k, v in pairs(t) do
***0	                if is_hash_key(k) then
***0	                    print_kv(k, v, t)
    	                end
    	            end
    	        end
    	
***0	        if option.show_metatable then
***0	            local mt = getmetatable(t)
***0	            if mt then
***0	                print_kv('__metatable', mt, t)
    	            end
    	        end
    	
***0	        _indent(-option.indent_size)
    	        -- make { } into {}
***0	        last = string.gsub(last, '^ +$', '')
    	        -- peek last to remove trailing comma
***0	        last = string.gsub(last, ',%s*$', ' ')
***0	        if wrapped then
***0	            _n()
    	        end
***0	        _p('}')
    	
***0	        return ''
    	    end
    	
    	    -- set formatters
***0	    formatter['nil'] = option.show_nil and tostring_formatter or nop_formatter
***0	    formatter['boolean'] = option.show_boolean and tostring_formatter or nop_formatter
***0	    formatter['number'] = option.show_number and number_formatter or nop_formatter -- need to handle math.huge
***0	    formatter['function'] = option.show_function and make_fixed_formatter('function', option.object_cache) or nop_formatter
***0	    formatter['thread'] = option.show_thread and make_fixed_formatter('thread', option.object_cache) or nop_formatter
***0	    formatter['userdata'] = option.show_userdata and make_fixed_formatter('userdata', option.object_cache) or nop_formatter
***0	    formatter['string'] = option.show_string and string_formatter or nop_formatter
***0	    formatter['table'] = option.show_table and table_formatter or nop_formatter
    	
***0	    if option.object_cache then
    	        -- needs to visit the table before start printing
***0	        cache_apperance(obj, cache, option)
    	    end
    	
***0	    _p(format(obj))
***0	    printer(last) -- close the buffered one
    	
    	    -- put cache back if global
***0	    if option.object_cache == 'global' then
***0	        pprint._cache = cache
    	    end
    	
***0	    return table.concat(buf)
    	end
    	
    	-- pprint all the arguments
   1	function pprint.pprint( ... )
***0	    local args = {...}
    	    -- select will get an accurate count of array len, counting trailing nils
***0	    local len = select('#', ...)
***0	    for ix = 1,len do
***0	        pprint.pformat(args[ix], nil, io.write)
***0	        io.write('\n')
    	    end
    	end
    	
   2	setmetatable(pprint, {
    	    __call = function (_, ...)
***0	        pprint.pprint(...)
    	    end
    	})
    	
   1	return pprint
    	

==============================================================================
/Users/louis77/.luarocks/share/lua/5.2/ltn12.lua
==============================================================================
    	-----------------------------------------------------------------------------
    	-- LTN12 - Filters, sources, sinks and pumps.
    	-- LuaSocket toolkit.
    	-- Author: Diego Nehab
    	-----------------------------------------------------------------------------
    	
    	-----------------------------------------------------------------------------
    	-- Declare module
    	-----------------------------------------------------------------------------
   1	local string = require("string")
   1	local table = require("table")
   1	local base = _G
   1	local _M = {}
   1	if module then -- heuristic for exporting a global package table
   1	    ltn12 = _M
    	end
   1	local filter,source,sink,pump = {},{},{},{}
    	
   1	_M.filter = filter
   1	_M.source = source
   1	_M.sink = sink
   1	_M.pump = pump
    	
    	-- 2048 seems to be better in windows...
   1	_M.BLOCKSIZE = 2048
   1	_M._VERSION = "LTN12 1.0.3"
    	
    	-----------------------------------------------------------------------------
    	-- Filter stuff
    	-----------------------------------------------------------------------------
    	-- returns a high level filter that cycles a low-level filter
   1	function filter.cycle(low, ctx, extra)
***0	    base.assert(low)
    	    return function(chunk)
    	        local ret
***0	        ret, ctx = low(ctx, chunk, extra)
***0	        return ret
    	    end
    	end
    	
    	-- chains a bunch of filters together
    	-- (thanks to Wim Couwenberg)
   1	function filter.chain(...)
***0	    local arg = {...}
***0	    local n = select('#',...)
***0	    local top, index = 1, 1
***0	    local retry = ""
    	    return function(chunk)
***0	        retry = chunk and retry
    	        while true do
***0	            if index == top then
***0	                chunk = arg[index](chunk)
***0	                if chunk == "" or top == n then return chunk
***0	                elseif chunk then index = index + 1
    	                else
***0	                    top = top+1
***0	                    index = top
    	                end
    	            else
***0	                chunk = arg[index](chunk or "")
***0	                if chunk == "" then
***0	                    index = index - 1
***0	                    chunk = retry
***0	                elseif chunk then
***0	                    if index == n then return chunk
***0	                    else index = index + 1 end
***0	                else base.error("filter returned inappropriate nil") end
    	            end
    	        end
    	    end
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Source stuff
    	-----------------------------------------------------------------------------
    	-- create an empty source
    	local function empty()
***0	    return nil
    	end
    	
   1	function source.empty()
***0	    return empty
    	end
    	
    	-- returns a source that just outputs an error
   1	function source.error(err)
    	    return function()
***0	        return nil, err
    	    end
    	end
    	
    	-- creates a file source
   1	function source.file(handle, io_err)
***0	    if handle then
    	        return function()
***0	            local chunk = handle:read(_M.BLOCKSIZE)
***0	            if not chunk then handle:close() end
***0	            return chunk
    	        end
***0	    else return source.error(io_err or "unable to open file") end
    	end
    	
    	-- turns a fancy source into a simple source
   1	function source.simplify(src)
***0	    base.assert(src)
    	    return function()
***0	        local chunk, err_or_new = src()
***0	        src = err_or_new or src
***0	        if not chunk then return nil, err_or_new
***0	        else return chunk end
    	    end
    	end
    	
    	-- creates string source
   1	function source.string(s)
   8	    if s then
   8	        local i = 1
    	        return function()
  16	            local chunk = string.sub(s, i, i+_M.BLOCKSIZE-1)
  16	            i = i + _M.BLOCKSIZE
  16	            if chunk ~= "" then return chunk
   8	            else return nil end
    	        end
***0	    else return source.empty() end
    	end
    	
    	-- creates rewindable source
   1	function source.rewind(src)
***0	    base.assert(src)
***0	    local t = {}
    	    return function(chunk)
***0	        if not chunk then
***0	            chunk = table.remove(t)
***0	            if not chunk then return src()
***0	            else return chunk end
    	        else
***0	            table.insert(t, chunk)
    	        end
    	    end
    	end
    	
   1	function source.chain(src, f)
***0	    base.assert(src and f)
***0	    local last_in, last_out = "", ""
***0	    local state = "feeding"
    	    local err
    	    return function()
***0	        if not last_out then
***0	            base.error('source is empty!', 2)
    	        end
    	        while true do
***0	            if state == "feeding" then
***0	                last_in, err = src()
***0	                if err then return nil, err end
***0	                last_out = f(last_in)
***0	                if not last_out then
***0	                    if last_in then
***0	                        base.error('filter returned inappropriate nil')
    	                    else
***0	                        return nil
    	                    end
***0	                elseif last_out ~= "" then
***0	                    state = "eating"
***0	                    if last_in then last_in = "" end
***0	                    return last_out
    	                end
    	            else
***0	                last_out = f(last_in)
***0	                if last_out == "" then
***0	                    if last_in == "" then
***0	                        state = "feeding"
    	                    else
***0	                        base.error('filter returned ""')
    	                    end
***0	                elseif not last_out then
***0	                    if last_in then
***0	                        base.error('filter returned inappropriate nil')
    	                    else
***0	                        return nil
    	                    end
    	                else
***0	                    return last_out
    	                end
    	            end
    	        end
    	    end
    	end
    	
    	-- creates a source that produces contents of several sources, one after the
    	-- other, as if they were concatenated
    	-- (thanks to Wim Couwenberg)
   1	function source.cat(...)
***0	    local arg = {...}
***0	    local src = table.remove(arg, 1)
    	    return function()
***0	        while src do
***0	            local chunk, err = src()
***0	            if chunk then return chunk end
***0	            if err then return nil, err end
***0	            src = table.remove(arg, 1)
    	        end
    	    end
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Sink stuff
    	-----------------------------------------------------------------------------
    	-- creates a sink that stores into a table
   1	function sink.table(t)
   8	    t = t or {}
    	    local f = function(chunk, err)
  16	        if chunk then table.insert(t, chunk) end
  16	        return 1
    	    end
   8	    return f, t
    	end
    	
    	-- turns a fancy sink into a simple sink
   1	function sink.simplify(snk)
***0	    base.assert(snk)
    	    return function(chunk, err)
***0	        local ret, err_or_new = snk(chunk, err)
***0	        if not ret then return nil, err_or_new end
***0	        snk = err_or_new or snk
***0	        return 1
    	    end
    	end
    	
    	-- creates a file sink
   1	function sink.file(handle, io_err)
***0	    if handle then
    	        return function(chunk, err)
***0	            if not chunk then
***0	                handle:close()
***0	                return 1
***0	            else return handle:write(chunk) end
    	        end
***0	    else return sink.error(io_err or "unable to open file") end
    	end
    	
    	-- creates a sink that discards data
    	local function null()
***0	    return 1
    	end
    	
   1	function sink.null()
***0	    return null
    	end
    	
    	-- creates a sink that just returns an error
   1	function sink.error(err)
    	    return function()
***0	        return nil, err
    	    end
    	end
    	
    	-- chains a sink with a filter
   1	function sink.chain(f, snk)
***0	    base.assert(f and snk)
    	    return function(chunk, err)
***0	        if chunk ~= "" then
***0	            local filtered = f(chunk)
***0	            local done = chunk and ""
    	            while true do
***0	                local ret, snkerr = snk(filtered, err)
***0	                if not ret then return nil, snkerr end
***0	                if filtered == done then return 1 end
***0	                filtered = f(done)
    	            end
***0	        else return 1 end
    	    end
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Pump stuff
    	-----------------------------------------------------------------------------
    	-- pumps one chunk from the source to the sink
   1	function pump.step(src, snk)
  32	    local chunk, src_err = src()
  32	    local ret, snk_err = snk(chunk, src_err)
  32	    if chunk and ret then return 1
  16	    else return nil, src_err or snk_err end
    	end
    	
    	-- pumps all data from a source to a sink, using a step function
   1	function pump.all(src, snk, step)
  16	    base.assert(src and snk)
  16	    step = step or pump.step
    	    while true do
  32	        local ret, err = step(src, snk)
  32	        if not ret then
  16	            if err then return nil, err
  16	            else return 1 end
    	        end
    	    end
    	end
    	
   1	return _M

==============================================================================
/Users/louis77/.luarocks/share/lua/5.2/mime.lua
==============================================================================
    	-----------------------------------------------------------------------------
    	-- MIME support for the Lua language.
    	-- Author: Diego Nehab
    	-- Conforming to RFCs 2045-2049
    	-----------------------------------------------------------------------------
    	
    	-----------------------------------------------------------------------------
    	-- Declare module and import dependencies
    	-----------------------------------------------------------------------------
   1	local base = _G
   1	local ltn12 = require("ltn12")
   1	local mime = require("mime.core")
   1	local io = require("io")
   1	local string = require("string")
   1	local _M = mime
    	
    	-- encode, decode and wrap algorithm tables
   1	local encodet, decodet, wrapt = {},{},{}
    	
   1	_M.encodet = encodet
   1	_M.decodet = decodet
   1	_M.wrapt   = wrapt  
    	
    	-- creates a function that chooses a filter by name from a given table
    	local function choose(table)
    	    return function(name, opt1, opt2)
***0	        if base.type(name) ~= "string" then
***0	            name, opt1, opt2 = "default", name, opt1
    	        end
***0	        local f = table[name or "nil"]
***0	        if not f then 
***0	            base.error("unknown key (" .. base.tostring(name) .. ")", 3)
***0	        else return f(opt1, opt2) end
    	    end
    	end
    	
    	-- define the encoding filters
    	encodet['base64'] = function()
***0	    return ltn12.filter.cycle(_M.b64, "")
    	end
    	
    	encodet['quoted-printable'] = function(mode)
***0	    return ltn12.filter.cycle(_M.qp, "",
***0	        (mode == "binary") and "=0D=0A" or "\r\n")
    	end
    	
    	-- define the decoding filters
    	decodet['base64'] = function()
***0	    return ltn12.filter.cycle(_M.unb64, "")
    	end
    	
    	decodet['quoted-printable'] = function()
***0	    return ltn12.filter.cycle(_M.unqp, "")
    	end
    	
    	local function format(chunk)
***0	    if chunk then
***0	        if chunk == "" then return "''"
***0	        else return string.len(chunk) end
***0	    else return "nil" end
    	end
    	
    	-- define the line-wrap filters
    	wrapt['text'] = function(length)
***0	    length = length or 76
***0	    return ltn12.filter.cycle(_M.wrp, length, length)
    	end
   1	wrapt['base64'] = wrapt['text']
   1	wrapt['default'] = wrapt['text']
    	
    	wrapt['quoted-printable'] = function()
***0	    return ltn12.filter.cycle(_M.qpwrp, 76, 76)
    	end
    	
    	-- function that choose the encoding, decoding or wrap algorithm
   1	_M.encode = choose(encodet)
   1	_M.decode = choose(decodet)
   1	_M.wrap = choose(wrapt)
    	
    	-- define the end-of-line normalization filter
   1	function _M.normalize(marker)
***0	    return ltn12.filter.cycle(_M.eol, 0, marker)
    	end
    	
    	-- high level stuffing filter
   1	function _M.stuff()
***0	    return ltn12.filter.cycle(_M.dot, 2)
    	end
    	
   1	return _M

==============================================================================
/Users/louis77/.luarocks/share/lua/5.2/socket.lua
==============================================================================
    	-----------------------------------------------------------------------------
    	-- LuaSocket helper module
    	-- Author: Diego Nehab
    	-----------------------------------------------------------------------------
    	
    	-----------------------------------------------------------------------------
    	-- Declare module and import dependencies
    	-----------------------------------------------------------------------------
   1	local base = _G
   1	local string = require("string")
   1	local math = require("math")
   1	local socket = require("socket.core")
    	
   1	local _M = socket
    	
    	-----------------------------------------------------------------------------
    	-- Exported auxiliar functions
    	-----------------------------------------------------------------------------
   1	function _M.connect4(address, port, laddress, lport)
***0	    return socket.connect(address, port, laddress, lport, "inet")
    	end
    	
   1	function _M.connect6(address, port, laddress, lport)
***0	    return socket.connect(address, port, laddress, lport, "inet6")
    	end
    	
   1	function _M.bind(host, port, backlog)
***0	    if host == "*" then host = "0.0.0.0" end
***0	    local addrinfo, err = socket.dns.getaddrinfo(host);
***0	    if not addrinfo then return nil, err end
    	    local sock, res
***0	    err = "no info on address"
***0	    for i, alt in base.ipairs(addrinfo) do
***0	        if alt.family == "inet" then
***0	            sock, err = socket.tcp()
    	        else
***0	            sock, err = socket.tcp6()
    	        end
***0	        if not sock then return nil, err end
***0	        sock:setoption("reuseaddr", true)
***0	        res, err = sock:bind(alt.addr, port)
***0	        if not res then 
***0	            sock:close()
    	        else 
***0	            res, err = sock:listen(backlog)
***0	            if not res then 
***0	                sock:close()
    	            else
***0	                return sock
    	            end
    	        end 
    	    end
***0	    return nil, err
    	end
    	
   1	_M.try = _M.newtry()
    	
   1	function _M.choose(table)
    	    return function(name, opt1, opt2)
  16	        if base.type(name) ~= "string" then
***0	            name, opt1, opt2 = "default", name, opt1
    	        end
  16	        local f = table[name or "nil"]
  16	        if not f then base.error("unknown key (".. base.tostring(name) ..")", 3)
  16	        else return f(opt1, opt2) end
    	    end
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Socket sources and sinks, conforming to LTN12
    	-----------------------------------------------------------------------------
    	-- create namespaces inside LuaSocket namespace
   1	local sourcet, sinkt = {}, {}
   1	_M.sourcet = sourcet
   1	_M.sinkt = sinkt
    	
   1	_M.BLOCKSIZE = 2048
    	
    	sinkt["close-when-done"] = function(sock)
***0	    return base.setmetatable({
    	        getfd = function() return sock:getfd() end,
***0	        dirty = function() return sock:dirty() end
***0	    }, {
    	        __call = function(self, chunk, err)
***0	            if not chunk then
***0	                sock:close()
***0	                return 1
***0	            else return sock:send(chunk) end
    	        end
    	    })
    	end
    	
    	sinkt["keep-open"] = function(sock)
  16	    return base.setmetatable({
   8	        getfd = function() return sock:getfd() end,
   8	        dirty = function() return sock:dirty() end
   8	    }, {
    	        __call = function(self, chunk, err)
  16	            if chunk then return sock:send(chunk)
   8	            else return 1 end
    	        end
   8	    })
    	end
    	
   1	sinkt["default"] = sinkt["keep-open"]
    	
   1	_M.sink = _M.choose(sinkt)
    	
    	sourcet["by-length"] = function(sock, length)
***0	    return base.setmetatable({
    	        getfd = function() return sock:getfd() end,
***0	        dirty = function() return sock:dirty() end
***0	    }, {
    	        __call = function()
***0	            if length <= 0 then return nil end
***0	            local size = math.min(socket.BLOCKSIZE, length)
***0	            local chunk, err = sock:receive(size)
***0	            if err then return nil, err end
***0	            length = length - string.len(chunk)
***0	            return chunk
    	        end
    	    })
    	end
    	
    	sourcet["until-closed"] = function(sock)
    	    local done
***0	    return base.setmetatable({
    	        getfd = function() return sock:getfd() end,
***0	        dirty = function() return sock:dirty() end
***0	    }, {
    	        __call = function()
***0	            if done then return nil end
***0	            local chunk, err, partial = sock:receive(socket.BLOCKSIZE)
***0	            if not err then return chunk
***0	            elseif err == "closed" then
***0	                sock:close()
***0	                done = 1
***0	                return partial
***0	            else return nil, err end
    	        end
    	    })
    	end
    	
    	
   1	sourcet["default"] = sourcet["until-closed"]
    	
   1	_M.source = _M.choose(sourcet)
    	
   1	return _M

==============================================================================
/Users/louis77/.luarocks/share/lua/5.2/socket/headers.lua
==============================================================================
    	-----------------------------------------------------------------------------
    	-- Canonic header field capitalization
    	-- LuaSocket toolkit.
    	-- Author: Diego Nehab
    	-----------------------------------------------------------------------------
   1	local socket = require("socket")
   1	socket.headers = {}
   1	local _M = socket.headers
    	
   1	_M.canonic = {
   1	    ["accept"] = "Accept",
   1	    ["accept-charset"] = "Accept-Charset",
   1	    ["accept-encoding"] = "Accept-Encoding",
   1	    ["accept-language"] = "Accept-Language",
   1	    ["accept-ranges"] = "Accept-Ranges",
   1	    ["action"] = "Action",
   1	    ["alternate-recipient"] = "Alternate-Recipient",
   1	    ["age"] = "Age",
   1	    ["allow"] = "Allow",
   1	    ["arrival-date"] = "Arrival-Date",
   1	    ["authorization"] = "Authorization",
   1	    ["bcc"] = "Bcc",
   1	    ["cache-control"] = "Cache-Control",
   1	    ["cc"] = "Cc",
   1	    ["comments"] = "Comments",
   1	    ["connection"] = "Connection",
   1	    ["content-description"] = "Content-Description",
   1	    ["content-disposition"] = "Content-Disposition",
   1	    ["content-encoding"] = "Content-Encoding",
   1	    ["content-id"] = "Content-ID",
   1	    ["content-language"] = "Content-Language",
   1	    ["content-length"] = "Content-Length",
   1	    ["content-location"] = "Content-Location",
   1	    ["content-md5"] = "Content-MD5",
   1	    ["content-range"] = "Content-Range",
   1	    ["content-transfer-encoding"] = "Content-Transfer-Encoding",
   1	    ["content-type"] = "Content-Type",
   1	    ["cookie"] = "Cookie",
   1	    ["date"] = "Date",
   1	    ["diagnostic-code"] = "Diagnostic-Code",
   1	    ["dsn-gateway"] = "DSN-Gateway",
   1	    ["etag"] = "ETag",
   1	    ["expect"] = "Expect",
   1	    ["expires"] = "Expires",
   1	    ["final-log-id"] = "Final-Log-ID",
   1	    ["final-recipient"] = "Final-Recipient",
   1	    ["from"] = "From",
   1	    ["host"] = "Host",
   1	    ["if-match"] = "If-Match",
   1	    ["if-modified-since"] = "If-Modified-Since",
   1	    ["if-none-match"] = "If-None-Match",
   1	    ["if-range"] = "If-Range",
   1	    ["if-unmodified-since"] = "If-Unmodified-Since",
   1	    ["in-reply-to"] = "In-Reply-To",
   1	    ["keywords"] = "Keywords",
   1	    ["last-attempt-date"] = "Last-Attempt-Date",
   1	    ["last-modified"] = "Last-Modified",
   1	    ["location"] = "Location",
   1	    ["max-forwards"] = "Max-Forwards",
   1	    ["message-id"] = "Message-ID",
   1	    ["mime-version"] = "MIME-Version",
   1	    ["original-envelope-id"] = "Original-Envelope-ID",
   1	    ["original-recipient"] = "Original-Recipient",
   1	    ["pragma"] = "Pragma",
   1	    ["proxy-authenticate"] = "Proxy-Authenticate",
   1	    ["proxy-authorization"] = "Proxy-Authorization",
   1	    ["range"] = "Range",
   1	    ["received"] = "Received",
   1	    ["received-from-mta"] = "Received-From-MTA",
   1	    ["references"] = "References",
   1	    ["referer"] = "Referer",
   1	    ["remote-mta"] = "Remote-MTA",
   1	    ["reply-to"] = "Reply-To",
   1	    ["reporting-mta"] = "Reporting-MTA",
   1	    ["resent-bcc"] = "Resent-Bcc",
   1	    ["resent-cc"] = "Resent-Cc",
   1	    ["resent-date"] = "Resent-Date",
   1	    ["resent-from"] = "Resent-From",
   1	    ["resent-message-id"] = "Resent-Message-ID",
   1	    ["resent-reply-to"] = "Resent-Reply-To",
   1	    ["resent-sender"] = "Resent-Sender",
   1	    ["resent-to"] = "Resent-To",
   1	    ["retry-after"] = "Retry-After",
   1	    ["return-path"] = "Return-Path",
   1	    ["sender"] = "Sender",
   1	    ["server"] = "Server",
   1	    ["smtp-remote-recipient"] = "SMTP-Remote-Recipient",
   1	    ["status"] = "Status",
   1	    ["subject"] = "Subject",
   1	    ["te"] = "TE",
   1	    ["to"] = "To",
   1	    ["trailer"] = "Trailer",
   1	    ["transfer-encoding"] = "Transfer-Encoding",
   1	    ["upgrade"] = "Upgrade",
   1	    ["user-agent"] = "User-Agent",
   1	    ["vary"] = "Vary",
   1	    ["via"] = "Via",
   1	    ["warning"] = "Warning",
   1	    ["will-retry-until"] = "Will-Retry-Until",
   1	    ["www-authenticate"] = "WWW-Authenticate",
   1	    ["x-mailer"] = "X-Mailer",
   1	}
    	
   1	return _M

==============================================================================
/Users/louis77/.luarocks/share/lua/5.2/socket/http.lua
==============================================================================
    	-----------------------------------------------------------------------------
    	-- HTTP/1.1 client support for the Lua language.
    	-- LuaSocket toolkit.
    	-- Author: Diego Nehab
    	-----------------------------------------------------------------------------
    	
    	-----------------------------------------------------------------------------
    	-- Declare module and import dependencies
    	-------------------------------------------------------------------------------
   1	local socket = require("socket")
   1	local url = require("socket.url")
   1	local ltn12 = require("ltn12")
   1	local mime = require("mime")
   1	local string = require("string")
   1	local headers = require("socket.headers")
   1	local base = _G
   1	local table = require("table")
   1	socket.http = {}
   1	local _M = socket.http
    	
    	-----------------------------------------------------------------------------
    	-- Program constants
    	-----------------------------------------------------------------------------
    	-- connection timeout in seconds
   1	TIMEOUT = 60
    	-- default port for document retrieval
   1	_M.PORT = 80
    	-- user agent field sent in request
   1	_M.USERAGENT = socket._VERSION
    	
    	-----------------------------------------------------------------------------
    	-- Reads MIME headers from a connection, unfolding where needed
    	-----------------------------------------------------------------------------
    	local function receiveheaders(sock, headers)
    	    local line, name, value, err
  16	    headers = headers or {}
    	    -- get first line
  16	    line, err = sock:receive()
  16	    if err then return nil, err end
    	    -- headers go until a blank line is found
 110	    while line ~= "" do
    	        -- get field-name and value
  94	        name, value = socket.skip(2, string.find(line, "^(.-):%s*(.*)"))
  94	        if not (name and value) then return nil, "malformed reponse headers" end
  94	        name = string.lower(name)
    	        -- get next line (value might be folded)
  94	        line, err  = sock:receive()
  94	        if err then return nil, err end
    	        -- unfold any folded values
  94	        while string.find(line, "^%s") do
***0	            value = value .. line
***0	            line = sock:receive()
***0	            if err then return nil, err end
    	        end
    	        -- save pair in table
  94	        if headers[name] then headers[name] = headers[name] .. ", " .. value
  94	        else headers[name] = value end
    	    end
  16	    return headers
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Extra sources and sinks
    	-----------------------------------------------------------------------------
   1	socket.sourcet["http-chunked"] = function(sock, headers)
  16	    return base.setmetatable({
   8	        getfd = function() return sock:getfd() end,
   8	        dirty = function() return sock:dirty() end
   8	    }, {
    	        __call = function()
    	            -- get chunk size, skip extention
  16	            local line, err = sock:receive()
  16	            if err then return nil, err end
  16	            local size = base.tonumber(string.gsub(line, ";.*", ""), 16)
  16	            if not size then return nil, "invalid chunk size" end
    	            -- was it the last chunk?
  16	            if size > 0 then
    	                -- if not, get chunk and skip terminating CRLF
   8	                local chunk, err, part = sock:receive(size)
   8	                if chunk then sock:receive() end
   8	                return chunk, err
    	            else
    	                -- if it was, read trailers into headers table
   8	                headers, err = receiveheaders(sock, headers)
   8	                if not headers then return nil, err end
    	            end
    	        end
   8	    })
    	end
    	
   1	socket.sinkt["http-chunked"] = function(sock)
***0	    return base.setmetatable({
    	        getfd = function() return sock:getfd() end,
***0	        dirty = function() return sock:dirty() end
***0	    }, {
    	        __call = function(self, chunk, err)
***0	            if not chunk then return sock:send("0\r\n\r\n") end
***0	            local size = string.format("%X\r\n", string.len(chunk))
***0	            return sock:send(size ..  chunk .. "\r\n")
    	        end
    	    })
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Low level HTTP API
    	-----------------------------------------------------------------------------
   1	local metat = { __index = {} }
    	
   1	function _M.open(host, port, create)
    	    -- create socket with user connect function, or with default
   8	    local c = socket.try((create or socket.tcp)())
   8	    local h = base.setmetatable({ c = c }, metat)
    	    -- create finalized try
   8	    h.try = socket.newtry(function() h:close() end)
    	    -- set timeout before connecting
   8	    h.try(c:settimeout(_M.TIMEOUT))
   8	    h.try(c:connect(host, port or _M.PORT))
    	    -- here everything worked
   8	    return h
    	end
    	
   2	function metat.__index:sendrequestline(method, uri)
   8	    local reqline = string.format("%s %s HTTP/1.1\r\n", method or "GET", uri)
   8	    return self.try(self.c:send(reqline))
    	end
    	
   2	function metat.__index:sendheaders(tosend)
   8	    local canonic = headers.canonic
   8	    local h = "\r\n"
  65	    for f, v in base.pairs(tosend) do
  57	        h = (canonic[f] or f) .. ": " .. v .. "\r\n" .. h
    	    end
   8	    self.try(self.c:send(h))
   8	    return 1
    	end
    	
   2	function metat.__index:sendbody(headers, source, step)
   8	    source = source or ltn12.source.empty()
   8	    step = step or ltn12.pump.step
    	    -- if we don't know the size in advance, send chunked and hope for the best
   8	    local mode = "http-chunked"
   8	    if headers["content-length"] then mode = "keep-open" end
   8	    return self.try(ltn12.pump.all(source, socket.sink(mode, self.c), step))
    	end
    	
   2	function metat.__index:receivestatusline()
   8	    local status = self.try(self.c:receive(5))
    	    -- identify HTTP/0.9 responses, which do not contain a status line
    	    -- this is just a heuristic, but is what the RFC recommends
   8	    if status ~= "HTTP/" then return nil, status end
    	    -- otherwise proceed reading a status line
   8	    status = self.try(self.c:receive("*l", status))
   8	    local code = socket.skip(2, string.find(status, "HTTP/%d*%.%d* (%d%d%d)"))
   8	    return self.try(base.tonumber(code), status)
    	end
    	
   2	function metat.__index:receiveheaders()
   8	    return self.try(receiveheaders(self.c))
    	end
    	
   2	function metat.__index:receivebody(headers, sink, step)
   8	    sink = sink or ltn12.sink.null()
   8	    step = step or ltn12.pump.step
   8	    local length = base.tonumber(headers["content-length"])
   8	    local t = headers["transfer-encoding"] -- shortcut
   8	    local mode = "default" -- connection close
   8	    if t and t ~= "identity" then mode = "http-chunked"
***0	    elseif base.tonumber(headers["content-length"]) then mode = "by-length" end
  16	    return self.try(ltn12.pump.all(socket.source(mode, self.c, length),
  16	        sink, step))
    	end
    	
   2	function metat.__index:receive09body(status, sink, step)
***0	    local source = ltn12.source.rewind(socket.source("until-closed", self.c))
***0	    source(status)
***0	    return self.try(ltn12.pump.all(source, sink, step))
    	end
    	
   2	function metat.__index:close()
   8	    return self.c:close()
    	end
    	
    	-----------------------------------------------------------------------------
    	-- High level HTTP API
    	-----------------------------------------------------------------------------
    	local function adjusturi(reqt)
   8	    local u = reqt
    	    -- if there is a proxy, we need the full url. otherwise, just a part.
   8	    if not reqt.proxy and not PROXY then
   8	        u = {
   8	           path = socket.try(reqt.path, "invalid path 'nil'"),
   8	           params = reqt.params,
   8	           query = reqt.query,
   8	           fragment = reqt.fragment
   8	        }
    	    end
   8	    return url.build(u)
    	end
    	
    	local function adjustproxy(reqt)
   8	    local proxy = reqt.proxy or PROXY
   8	    if proxy then
***0	        proxy = url.parse(proxy)
***0	        return proxy.host, proxy.port or 3128
    	    else
   8	        return reqt.host, reqt.port
    	    end
    	end
    	
    	local function adjustheaders(reqt)
    	    -- default headers
   8	    local lower = {
   8	        ["user-agent"] = _M.USERAGENT,
   8	        ["host"] = reqt.host,
   8	        ["connection"] = "close, TE",
   8	        ["te"] = "trailers"
    	    }
    	    -- if we have authentication information, pass it along
   8	    if reqt.user and reqt.password then
***0	        lower["authorization"] = 
***0	            "Basic " ..  (mime.b64(reqt.user .. ":" .. reqt.password))
    	    end
    	    -- override with user headers
  33	    for i,v in base.pairs(reqt.headers or lower) do
  25	        lower[string.lower(i)] = v
    	    end
   8	    return lower
    	end
    	
    	-- default url parts
   1	local default = {
   1	    host = "",
   1	    port = _M.PORT,
   1	    path ="/",
   1	    scheme = "http"
    	}
    	
    	local function adjustrequest(reqt)
    	    -- parse url if provided
   8	    local nreqt = reqt.url and url.parse(reqt.url, default) or {}
    	    -- explicit components override url
  88	    for i,v in base.pairs(reqt) do nreqt[i] = v end
   8	    if nreqt.port == "" then nreqt.port = 80 end
  16	    socket.try(nreqt.host and nreqt.host ~= "", 
   8	        "invalid host '" .. base.tostring(nreqt.host) .. "'")
    	    -- compute uri if user hasn't overriden
   8	    nreqt.uri = reqt.uri or adjusturi(nreqt)
    	    -- ajust host and port if there is a proxy
   8	    nreqt.host, nreqt.port = adjustproxy(nreqt)
    	    -- adjust headers in request
   8	    nreqt.headers = adjustheaders(nreqt)
   8	    return nreqt
    	end
    	
    	local function shouldredirect(reqt, code, headers)
   8	    return headers.location and
***0	           string.gsub(headers.location, "%s", "") ~= "" and
***0	           (reqt.redirect ~= false) and
***0	           (code == 301 or code == 302 or code == 303 or code == 307) and
***0	           (not reqt.method or reqt.method == "GET" or reqt.method == "HEAD")
   8	           and (not reqt.nredirects or reqt.nredirects < 5)
    	end
    	
    	local function shouldreceivebody(reqt, code)
   8	    if reqt.method == "HEAD" then return nil end
   8	    if code == 204 or code == 304 then return nil end
   8	    if code >= 100 and code < 200 then return nil end
   8	    return 1
    	end
    	
    	-- forward declarations
    	local trequest, tredirect
    	
   1	--[[local]] function tredirect(reqt, location)
***0	    local result, code, headers, status = trequest {
    	        -- the RFC says the redirect URL has to be absolute, but some
    	        -- servers do not respect that
    	        url = url.absolute(reqt.url, location),
    	        source = reqt.source,
    	        sink = reqt.sink,
    	        headers = reqt.headers,
    	        proxy = reqt.proxy, 
    	        nredirects = (reqt.nredirects or 0) + 1,
***0	        create = reqt.create
    	    }   
    	    -- pass location header back as a hint we redirected
***0	    headers = headers or {}
***0	    headers.location = headers.location or location
***0	    return result, code, headers, status
    	end
    	
   1	--[[local]] function trequest(reqt)
    	    -- we loop until we get what we want, or
    	    -- until we are sure there is no way to get it
   8	    local nreqt = adjustrequest(reqt)
   8	    local h = _M.open(nreqt.host, nreqt.port, nreqt.create)
    	    -- send request line and headers
   8	    h:sendrequestline(nreqt.method, nreqt.uri)
   8	    h:sendheaders(nreqt.headers)
    	    -- if there is a body, send it
   8	    if nreqt.source then
   8	        h:sendbody(nreqt.headers, nreqt.source, nreqt.step) 
    	    end
   8	    local code, status = h:receivestatusline()
    	    -- if it is an HTTP/0.9 server, simply get the body and we are done
   8	    if not code then
***0	        h:receive09body(status, nreqt.sink, nreqt.step)
***0	        return 1, 200
    	    end
    	    local headers
    	    -- ignore any 100-continue messages
   8	    while code == 100 do 
***0	        headers = h:receiveheaders()
***0	        code, status = h:receivestatusline()
    	    end
   8	    headers = h:receiveheaders()
    	    -- at this point we should have a honest reply from the server
    	    -- we can't redirect if we already used the source, so we report the error 
   8	    if shouldredirect(nreqt, code, headers) and not nreqt.source then
***0	        h:close()
***0	        return tredirect(reqt, headers.location)
    	    end
    	    -- here we are finally done
   8	    if shouldreceivebody(nreqt, code) then
   8	        h:receivebody(headers, nreqt.sink, nreqt.step)
    	    end
   8	    h:close()
   8	    return 1, code, headers, status
    	end
    	
    	local function srequest(u, b)
***0	    local t = {}
***0	    local reqt = {
    	        url = u,
***0	        sink = ltn12.sink.table(t)
    	    }
***0	    if b then
***0	        reqt.source = ltn12.source.string(b)
***0	        reqt.headers = {
    	            ["content-length"] = string.len(b),
***0	            ["content-type"] = "application/x-www-form-urlencoded"
    	        }
***0	        reqt.method = "POST"
    	    end
***0	    local code, headers, status = socket.skip(1, trequest(reqt))
***0	    return table.concat(t), code, headers, status
    	end
    	
   2	_M.request = socket.protect(function(reqt, body)
   8	    if base.type(reqt) == "string" then return srequest(reqt, body)
   8	    else return trequest(reqt) end
    	end)
    	
   1	return _M

==============================================================================
/Users/louis77/.luarocks/share/lua/5.2/socket/url.lua
==============================================================================
    	-----------------------------------------------------------------------------
    	-- URI parsing, composition and relative URL resolution
    	-- LuaSocket toolkit.
    	-- Author: Diego Nehab
    	-----------------------------------------------------------------------------
    	
    	-----------------------------------------------------------------------------
    	-- Declare module
    	-----------------------------------------------------------------------------
   1	local string = require("string")
   1	local base = _G
   1	local table = require("table")
   1	local socket = require("socket")
    	
   1	socket.url = {}
   1	local _M = socket.url
    	
    	-----------------------------------------------------------------------------
    	-- Module version
    	-----------------------------------------------------------------------------
   1	_M._VERSION = "URL 1.0.3"
    	
    	-----------------------------------------------------------------------------
    	-- Encodes a string into its escaped hexadecimal representation
    	-- Input
    	--   s: binary string to be encoded
    	-- Returns
    	--   escaped representation of string binary
    	-----------------------------------------------------------------------------
   1	function _M.escape(s)
***0	    return (string.gsub(s, "([^A-Za-z0-9_])", function(c)
***0	        return string.format("%%%02x", string.byte(c))
    	    end))
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Protects a path segment, to prevent it from interfering with the
    	-- url parsing.
    	-- Input
    	--   s: binary string to be encoded
    	-- Returns
    	--   escaped representation of string binary
    	-----------------------------------------------------------------------------
    	local function make_set(t)
   1	    local s = {}
  17	    for i,v in base.ipairs(t) do
  16	        s[t[i]] = 1
    	    end
   1	    return s
    	end
    	
    	-- these are allowed withing a path segment, along with alphanum
    	-- other characters must be escaped
   2	local segment_set = make_set {
   1	    "-", "_", ".", "!", "~", "*", "'", "(",
   1	    ")", ":", "@", "&", "=", "+", "$", ",",
   1	}
    	
    	local function protect_segment(s)
  96	    return string.gsub(s, "([^A-Za-z0-9_])", function (c)
***0	        if segment_set[c] then return c
***0	        else return string.format("%%%02x", string.byte(c)) end
    	    end)
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Encodes a string into its escaped hexadecimal representation
    	-- Input
    	--   s: binary string to be encoded
    	-- Returns
    	--   escaped representation of string binary
    	-----------------------------------------------------------------------------
   1	function _M.unescape(s)
  96	    return (string.gsub(s, "%%(%x%x)", function(hex)
***0	        return string.char(base.tonumber(hex, 16))
    	    end))
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Builds a path from a base path and a relative path
    	-- Input
    	--   base_path
    	--   relative_path
    	-- Returns
    	--   corresponding absolute path
    	-----------------------------------------------------------------------------
    	local function absolute_path(base_path, relative_path)
***0	    if string.sub(relative_path, 1, 1) == "/" then return relative_path end
***0	    local path = string.gsub(base_path, "[^/]*$", "")
***0	    path = path .. relative_path
***0	    path = string.gsub(path, "([^/]*%./)", function (s)
***0	        if s ~= "./" then return s else return "" end
    	    end)
***0	    path = string.gsub(path, "/%.$", "/")
    	    local reduced
***0	    while reduced ~= path do
***0	        reduced = path
***0	        path = string.gsub(reduced, "([^/]*/%.%./)", function (s)
***0	            if s ~= "../../" then return "" else return s end
    	        end)
    	    end
***0	    path = string.gsub(reduced, "([^/]*/%.%.)$", function (s)
***0	        if s ~= "../.." then return "" else return s end
    	    end)
***0	    return path
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Parses a url and returns a table with all its parts according to RFC 2396
    	-- The following grammar describes the names given to the URL parts
    	-- <url> ::= <scheme>://<authority>/<path>;<params>?<query>#<fragment>
    	-- <authority> ::= <userinfo>@<host>:<port>
    	-- <userinfo> ::= <user>[:<password>]
    	-- <path> :: = {<segment>/}<segment>
    	-- Input
    	--   url: uniform resource locator of request
    	--   default: table with default values for each field
    	-- Returns
    	--   table with the following fields, where RFC naming conventions have
    	--   been preserved:
    	--     scheme, authority, userinfo, user, password, host, port,
    	--     path, params, query, fragment
    	-- Obs:
    	--   the leading '/' in {/<path>} is considered part of <path>
    	-----------------------------------------------------------------------------
   1	function _M.parse(url, default)
    	    -- initialize default parameters
  16	    local parsed = {}
  56	    for i,v in base.pairs(default or parsed) do parsed[i] = v end
    	    -- empty url is parsed to nil
  16	    if not url or url == "" then return nil, "invalid url" end
    	    -- remove whitespace
    	    -- url = string.gsub(url, "%s", "")
    	    -- get fragment
  32	    url = string.gsub(url, "#(.*)$", function(f)
***0	        parsed.fragment = f
***0	        return ""
    	    end)
    	    -- get scheme
  32	    url = string.gsub(url, "^([%w][%w%+%-%.]*)%:",
  48	        function(s) parsed.scheme = s; return "" end)
    	    -- get authority
  32	    url = string.gsub(url, "^//([^/]*)", function(n)
  16	        parsed.authority = n
  16	        return ""
    	    end)
    	    -- get query string
  32	    url = string.gsub(url, "%?(.*)", function(q)
***0	        parsed.query = q
***0	        return ""
    	    end)
    	    -- get params
  32	    url = string.gsub(url, "%;(.*)", function(p)
***0	        parsed.params = p
***0	        return ""
    	    end)
    	    -- path is whatever was left
  16	    if url ~= "" then parsed.path = url end
  16	    local authority = parsed.authority
  16	    if not authority then return parsed end
  32	    authority = string.gsub(authority,"^([^@]*)@",
  32	        function(u) parsed.userinfo = u; return "" end)
  32	    authority = string.gsub(authority, ":([^:%]]*)$",
  40	        function(p) parsed.port = p; return "" end)
  16	    if authority ~= "" then 
    	        -- IPv6?
  16	        parsed.host = string.match(authority, "^%[(.+)%]$") or authority 
    	    end
  16	    local userinfo = parsed.userinfo
  16	    if not userinfo then return parsed end
    	    userinfo = string.gsub(userinfo, ":([^:]*)$",
***0	        function(p) parsed.password = p; return "" end)
***0	    parsed.user = userinfo
***0	    return parsed
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Rebuilds a parsed URL from its components.
    	-- Components are protected if any reserved or unallowed characters are found
    	-- Input
    	--   parsed: parsed URL, as returned by parse
    	-- Returns
    	--   a stringing with the corresponding URL
    	-----------------------------------------------------------------------------
   1	function _M.build(parsed)
  16	    local ppath = _M.parse_path(parsed.path or "")
  16	    local url = _M.build_path(ppath)
  16	    if parsed.params then url = url .. ";" .. parsed.params end
  16	    if parsed.query then url = url .. "?" .. parsed.query end
  16	    local authority = parsed.authority
  16	    if parsed.host then
   8	        authority = parsed.host
   8	        if string.find(authority, ":") then -- IPv6?
***0	            authority = "[" .. authority .. "]"
    	        end
   8	        if parsed.port then authority = authority .. ":" .. parsed.port end
   8	        local userinfo = parsed.userinfo
   8	        if parsed.user then
***0	            userinfo = parsed.user
***0	            if parsed.password then
***0	                userinfo = userinfo .. ":" .. parsed.password
    	            end
    	        end
   8	        if userinfo then authority = userinfo .. "@" .. authority end
    	    end
  16	    if authority then url = "//" .. authority .. url end
  16	    if parsed.scheme then url = parsed.scheme .. ":" .. url end
  16	    if parsed.fragment then url = url .. "#" .. parsed.fragment end
    	    -- url = string.gsub(url, "%s", "")
  16	    return url
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Builds a absolute URL from a base and a relative URL according to RFC 2396
    	-- Input
    	--   base_url
    	--   relative_url
    	-- Returns
    	--   corresponding absolute url
    	-----------------------------------------------------------------------------
   1	function _M.absolute(base_url, relative_url)
***0	    if base.type(base_url) == "table" then
***0	        base_parsed = base_url
***0	        base_url = _M.build(base_parsed)
    	    else
***0	        base_parsed = _M.parse(base_url)
    	    end
***0	    local relative_parsed = _M.parse(relative_url)
***0	    if not base_parsed then return relative_url
***0	    elseif not relative_parsed then return base_url
***0	    elseif relative_parsed.scheme then return relative_url
    	    else
***0	        relative_parsed.scheme = base_parsed.scheme
***0	        if not relative_parsed.authority then
***0	            relative_parsed.authority = base_parsed.authority
***0	            if not relative_parsed.path then
***0	                relative_parsed.path = base_parsed.path
***0	                if not relative_parsed.params then
***0	                    relative_parsed.params = base_parsed.params
***0	                    if not relative_parsed.query then
***0	                        relative_parsed.query = base_parsed.query
    	                    end
    	                end
    	            else    
***0	                relative_parsed.path = absolute_path(base_parsed.path or "",
***0	                    relative_parsed.path)
    	            end
    	        end
***0	        return _M.build(relative_parsed)
    	    end
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Breaks a path into its segments, unescaping the segments
    	-- Input
    	--   path
    	-- Returns
    	--   segment: a table with one entry per segment
    	-----------------------------------------------------------------------------
   1	function _M.parse_path(path)
  16	    local parsed = {}
  16	    path = path or ""
    	    --path = string.gsub(path, "%s", "")
  64	    string.gsub(path, "([^/]+)", function (s) table.insert(parsed, s) end)
  64	    for i = 1, #parsed do
  48	        parsed[i] = _M.unescape(parsed[i])
    	    end
  16	    if string.sub(path, 1, 1) == "/" then parsed.is_absolute = 1 end
  16	    if string.sub(path, -1, -1) == "/" then parsed.is_directory = 1 end
  16	    return parsed
    	end
    	
    	-----------------------------------------------------------------------------
    	-- Builds a path component from its segments, escaping protected characters.
    	-- Input
    	--   parsed: path segments
    	--   unsafe: if true, segments are not protected before path is built
    	-- Returns
    	--   path: corresponding path stringing
    	-----------------------------------------------------------------------------
   1	function _M.build_path(parsed, unsafe)
  16	    local path = ""
  16	    local n = #parsed
  16	    if unsafe then
***0	        for i = 1, n-1 do
***0	            path = path .. parsed[i]
***0	            path = path .. "/"
    	        end
***0	        if n > 0 then
***0	            path = path .. parsed[n]
***0	            if parsed.is_directory then path = path .. "/" end
    	        end
    	    else
  48	        for i = 1, n-1 do
  32	            path = path .. protect_segment(parsed[i])
  32	            path = path .. "/"
    	        end
  16	        if n > 0 then
  16	            path = path .. protect_segment(parsed[n])
  16	            if parsed.is_directory then path = path .. "/" end
    	        end
    	    end
  16	    if parsed.is_absolute then path = "/" .. path end
  16	    return path
    	end
    	
   1	return _M

==============================================================================
/usr/local/share/lua/5.2/busted/block.lua
==============================================================================
***0	local getfenv = require 'busted.compatibility'.getfenv
***0	local unpack = require 'busted.compatibility'.unpack
***0	local shuffle = require 'busted.utils'.shuffle
    	
    	local function sort(elements)
***0	  table.sort(elements, function(t1, t2)
***0	    if t1.name and t2.name then
***0	      return t1.name < t2.name
    	    end
***0	    return t2.name ~= nil
    	  end)
***0	  return elements
    	end
    	
    	return function(busted)
   1	  local block = {}
    	
   1	  function block.reject(descriptor, element)
 162	    local env = getfenv(element.run)
 162	    if env[descriptor] then
 136	      element.env[descriptor] = function(...)
***0	        error("'" .. descriptor .. "' not supported inside current context block", 2)
    	      end
    	    end
    	  end
    	
   1	  function block.rejectAll(element)
   9	    block.reject('randomize', element)
 162	    for descriptor, _ in pairs(busted.executors) do
 153	      block.reject(descriptor, element)
    	    end
    	  end
    	
    	  local function exec(descriptor, element)
   2	    if not element.env then element.env = {} end
   2	    block.rejectAll(element)
   2	    local ret = { busted.safe(descriptor, element.run, element) }
   2	    return unpack(ret)
    	  end
    	
   1	  function block.execAllOnce(descriptor, current, err)
  28	    local parent = busted.context.parent(current)
    	
  28	    if parent then
  21	      local success = block.execAllOnce(descriptor, parent)
  21	      if not success then
***0	        return success
    	      end
    	    end
    	
  28	    if not current[descriptor] then
   5	      current[descriptor] = {}
    	    end
  28	    local list = current[descriptor]
  28	    if list.success ~= nil then
  23	      return list.success
    	    end
    	
   5	    local success = true
   5	    for _, v in ipairs(list) do
***0	      if not exec(descriptor, v):success() then
***0	        if err then err(descriptor) end
***0	        success = false
    	      end
    	    end
    	
   5	    list.success = success
    	
   5	    return success
    	  end
    	
   1	  function block.execAll(descriptor, current, propagate, err)
  33	    local parent = busted.context.parent(current)
    	
  33	    if propagate and parent then
  21	      local success, ancestor = block.execAll(descriptor, parent, propagate)
  21	      if not success then
***0	        return success, ancestor
    	      end
    	    end
    	
  33	    local list = current[descriptor] or {}
    	
  33	    local success = true
  34	    for _, v in ipairs(list) do
   1	      if not exec(descriptor, v):success() then
***0	        if err then err(descriptor) end
***0	        success = nil
    	      end
    	    end
  33	    return success, current
    	  end
    	
   1	  function block.dexecAll(descriptor, current, propagate, err)
  38	    local parent = busted.context.parent(current)
  38	    local list = current[descriptor] or {}
    	
  38	    local success = true
  39	    for _, v in ipairs(list) do
   1	      if not exec(descriptor, v):success() then
***0	        if err then err(descriptor) end
***0	        success = nil
    	      end
    	    end
    	
  38	    if propagate and parent then
  21	      if not block.dexecAll(descriptor, parent, propagate) then
***0	        success = nil
    	      end
    	    end
  38	    return success
    	  end
    	
   1	  function block.lazySetup(element, err)
   7	    return block.execAllOnce('lazy_setup', element, err)
    	  end
    	
   1	  function block.lazyTeardown(element, err)
   5	    if element.lazy_setup and element.lazy_setup.success ~= nil then
   5	      block.dexecAll('lazy_teardown', element, nil, err)
   5	      element.lazy_setup.success = nil
    	    end
    	  end
    	
   1	  function block.setup(element, err)
   5	      return block.execAll('strict_setup', element, nil, err)
    	  end
    	
   1	  function block.teardown(element, err)
   5	      return block.dexecAll('strict_teardown', element, nil, err)
    	  end
    	
   1	  function block.execute(descriptor, element)
   4	    if not element.env then element.env = {} end
    	
   4	    local randomize = busted.randomize
   4	    element.env.randomize = function(...)
***0	      randomize = (select('#', ...) == 0 or ...)
    	    end
    	
   4	    if busted.safe(descriptor, element.run, element):success() then
   4	      if randomize then
***0	        element.randomseed = busted.randomseed
***0	        shuffle(busted.context.children(element), busted.randomseed)
   4	      elseif busted.sort then
***0	        sort(busted.context.children(element))
    	      end
    	
   4	      if block.setup(element) then
   4	        busted.execute(element)
    	      end
    	
   4	      block.lazyTeardown(element)
   4	      block.teardown(element)
    	    end
    	  end
    	
   1	  return block
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/compatibility.lua
==============================================================================
***0	return {
***0	  getfenv = getfenv or function(f)
 162	    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
    	    local name, value
 162	    local up = 0
    	
    	    repeat
 486	      up = up + 1
 486	      name, value = debug.getupvalue(f, up)
 486	    until name == '_ENV' or name == nil
    	
 162	    return name and value or _G
    	  end,
    	
***0	  setfenv = setfenv or function(f, t)
   1	    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
    	    local name
   1	    local up = 0
    	
    	    repeat
   1	      up = up + 1
   1	      name = debug.getupvalue(f, up)
   1	    until name == '_ENV' or name == nil
    	
   1	    if name then
   1	      debug.upvaluejoin(f, up, function() return name end, 1)
   1	      debug.setupvalue(f, up, t)
    	    end
    	
   1	    if f ~= 0 then return f end
    	  end,
    	
    	  unpack = table.unpack or unpack,
    	
    	  exit = function(code)
***0	    if code ~= 0 and _VERSION:match('^Lua 5%.[12]$') then
***0	      error()
***0	    elseif code ~= 0 then
***0	      code = 1
    	    end
***0	    if _VERSION == 'Lua 5.1' and
***0	      (type(jit) ~= 'table' or not jit.version or jit.version_num < 20000) then
    	      -- From Lua 5.1 manual:
    	      -- > The userdata itself is freed only in the next
    	      -- > garbage-collection cycle.
    	      -- Call collectgarbage() while collectgarbage('count')
    	      -- changes + 3 times, at least 3 times,
    	      -- at max 100 times (to prevent infinite loop).
***0	      local times_const = 0
***0	      for i = 1, 100 do
***0	        local count_before = collectgarbage("count")
***0	        collectgarbage()
***0	        local count_after = collectgarbage("count")
***0	        if count_after == count_before then
***0	          times_const = times_const + 1
***0	          if times_const > 3 then
    	            break
    	          end
    	        else
***0	          times_const = 0
    	        end
    	      end
    	    end
***0	    os.exit(code, true)
    	  end,
    	
    	  execute = require 'pl.utils'.execute,
    	}

==============================================================================
/usr/local/share/lua/5.2/busted/context.lua
==============================================================================
***0	local tablex = require 'pl.tablex'
    	
    	local function save()
   1	  local g = {}
  41	  for k,_ in next, _G, nil do
  40	    g[k] = rawget(_G, k)
    	  end
   1	  return {
   1	    gmt = debug.getmetatable(_G),
   1	    g = g,
   1	    loaded = tablex.copy(package.loaded)
   1	  }
    	end
    	
    	local function restore(state)
   1	  setmetatable(_G, state.gmt)
  44	  for k,_ in next, _G, nil do
  43	    rawset(_G, k, state.g[k])
    	  end
 132	  for k,_ in pairs(package.loaded) do
 131	    package.loaded[k] = state.loaded[k]
    	  end
    	end
    	
    	return function()
***0	  local context = {}
    	
***0	  local data = { descriptor = 'suite', attributes = {} }
***0	  local parents = {}
***0	  local children = {}
***0	  local stack = {}
***0	  local states = {}
    	
***0	  function context.ref()
***0	    local ref = {}
***0	    local ctx = data
    	
    	    local function unwrap(element, levels)
   2	      local levels = levels or 1
   2	      local parent = element
   4	      for i = 1, levels do
   2	        parent = ref.parent(parent)
   2	        if not parent then break end
    	      end
   2	      if not element.env then element.env = {} end
   4	      setmetatable(element.env, {
    	        __newindex = function(self, key, value)
***0	          if not parent then
***0	            _G[key] = value
    	          else
***0	            if not parent.env then parent.env = {} end
***0	            parent.env[key] = value
    	          end
    	        end
    	      })
    	    end
    	
    	    local function push_state(current)
  13	      local state = false
  13	      if current.attributes.envmode == 'insulate' then
   1	        state = save()
  12	      elseif current.attributes.envmode == 'unwrap' then
   2	        unwrap(current)
  10	      elseif current.attributes.envmode == 'expose' then
***0	        unwrap(current, 2)
    	      end
  13	      table.insert(states, state)
    	    end
    	
    	    local function pop_state(current)
  13	      local state = table.remove(states)
  13	      if current.attributes.envmode == 'expose' then
***0	        states[#states] = states[#states] and save()
    	      end
  13	      if state then
   1	        restore(state)
    	      end
    	    end
    	
***0	    function ref.get(key)
 213	      if not key then return ctx end
***0	      return ctx[key]
    	    end
    	
***0	    function ref.set(key, value)
***0	      ctx[key] = value
    	    end
    	
***0	    function ref.clear()
***0	      data = { descriptor = 'suite', attributes = {} }
***0	      parents = {}
***0	      children = {}
***0	      stack = {}
***0	      states = {}
***0	      ctx = data
    	    end
    	
***0	    function ref.attach(child)
  13	      if not children[ctx] then children[ctx] = {} end
  13	      parents[child] = ctx
  13	      table.insert(children[ctx], child)
    	    end
    	
***0	    function ref.children(parent)
   5	      return children[parent] or {}
    	    end
    	
***0	    function ref.parent(child)
 824	      return parents[child]
    	    end
    	
***0	    function ref.push(current)
  48	      if not parents[current] and current ~= data then error('Detached child. Cannot push.') end
  48	      if ctx ~= current then push_state(current) end
  48	      table.insert(stack, ctx)
  48	      ctx = current
    	    end
    	
***0	    function ref.pop()
  48	      local current = ctx
  48	      ctx = table.remove(stack)
  48	      if ctx ~= current then pop_state(current) end
  48	      if not ctx then error('Context stack empty. Cannot pop.') end
    	    end
    	
***0	    return ref
    	  end
    	
***0	  return context
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/core.lua
==============================================================================
***0	local getfenv = require 'busted.compatibility'.getfenv
***0	local setfenv = require 'busted.compatibility'.setfenv
***0	local unpack = require 'busted.compatibility'.unpack
***0	local path = require 'pl.path'
***0	local pretty = require 'pl.pretty'
***0	local throw = error
    	
***0	local failureMt = {
    	  __index = {},
    	  __tostring = function(e) return tostring(e.message) end,
***0	  __type = 'failure'
    	}
    	
***0	local failureMtNoString = {
    	  __index = {},
***0	  __type = 'failure'
    	}
    	
***0	local pendingMt = {
    	  __index = {},
    	  __tostring = function(p) return p.message end,
***0	  __type = 'pending'
    	}
    	
    	local function errortype(obj)
***0	  local mt = debug.getmetatable(obj)
***0	  if mt == failureMt or mt == failureMtNoString then
***0	    return 'failure'
***0	  elseif mt == pendingMt then
***0	    return 'pending'
    	  end
***0	  return 'error'
    	end
    	
    	local function hasToString(obj)
***0	  return type(obj) == 'string' or (debug.getmetatable(obj) or {}).__tostring
    	end
    	
    	local function isCallable(obj)
   1	  return type(obj) == 'function' or (debug.getmetatable(obj) or {}).__call
    	end
    	
    	return function()
***0	  local mediator = require 'mediator'()
    	
***0	  local busted = {}
***0	  busted.version = '2.0.rc11-0'
    	
***0	  local root = require 'busted.context'()
***0	  busted.context = root.ref()
    	
***0	  local environment = require 'busted.environment'(busted.context)
    	
***0	  busted.api = {}
***0	  busted.executors = {}
***0	  local executors = {}
***0	  local eattributes = {}
    	
***0	  busted.status = require 'busted.status'
    	
***0	  function busted.getTrace(element, level, msg)
  12	    level = level or  3
    	
  12	    local thisdir = path.dirname(debug.getinfo(1, 'Sl').source)
  12	    local info = debug.getinfo(level, 'Sl')
  12	    while info.what == 'C' or info.short_src:match('luassert[/\\].*%.lua$') or
  12	          (info.source:sub(1,1) == '@' and thisdir == path.dirname(info.source)) do
***0	      level = level + 1
***0	      info = debug.getinfo(level, 'Sl')
    	    end
    	
  12	    info.traceback = debug.traceback('', level)
  12	    info.message = msg
    	
  12	    local file = busted.getFile(element)
  12	    return file.getTrace(file.name, info)
    	  end
    	
***0	  function busted.rewriteMessage(element, message, trace)
***0	    local file = busted.getFile(element)
***0	    local msg = hasToString(message) and tostring(message)
***0	    msg = msg or (message ~= nil and pretty.write(message) or 'Nil error')
***0	    msg = (file.rewriteMessage and file.rewriteMessage(file.name, msg) or msg)
    	
***0	    local hasFileLine = msg:match('^[^\n]-:%d+: .*')
***0	    if not hasFileLine then
***0	      local trace = trace or busted.getTrace(element, 3, message)
***0	      local fileline = trace.short_src .. ':' .. trace.currentline .. ': '
***0	      msg = fileline .. msg
    	    end
    	
***0	    return msg
    	  end
    	
***0	  function busted.publish(...)
  38	    return mediator:publish(...)
    	  end
    	
***0	  function busted.subscribe(...)
  32	    return mediator:subscribe(...)
    	  end
    	
***0	  function busted.unsubscribe(...)
***0	    return mediator:removeSubscriber(...)
    	  end
    	
***0	  function busted.getFile(element)
  12	    local parent = busted.context.parent(element)
    	
  20	    while parent do
  20	      if parent.file then
   1	        local file = parent.file[1]
   1	        return {
   1	          name = file.name,
   1	          getTrace = file.run.getTrace,
   1	          rewriteMessage = file.run.rewriteMessage
   1	        }
    	      end
    	
  19	      if parent.descriptor == 'file' then
  11	        return {
  11	          name = parent.name,
  11	          getTrace = parent.run.getTrace,
  11	          rewriteMessage = parent.run.rewriteMessage
  11	        }
    	      end
    	
   8	      parent = busted.context.parent(parent)
    	    end
    	
***0	    return parent
    	  end
    	
***0	  function busted.fail(msg, level)
***0	    local rawlevel = (type(level) ~= 'number' or level <= 0) and level
***0	    local level = level or 1
***0	    local _, emsg = pcall(throw, msg, rawlevel or level+2)
***0	    local e = { message = emsg }
***0	    setmetatable(e, hasToString(msg) and failureMt or failureMtNoString)
***0	    throw(e, rawlevel or level+1)
    	  end
    	
***0	  function busted.pending(msg)
***0	    local p = { message = msg }
***0	    setmetatable(p, pendingMt)
***0	    throw(p)
    	  end
    	
***0	  function busted.bindfenv(callable, var, value)
***0	    local env = {}
***0	    local f = (debug.getmetatable(callable) or {}).__call or callable
***0	    setmetatable(env, { __index = getfenv(f) })
***0	    env[var] = value
***0	    setfenv(f, env)
    	  end
    	
***0	  function busted.wrap(callable)
   1	    if isCallable(callable) then
    	      -- prioritize __call if it exists, like in files
   1	      environment.wrap((debug.getmetatable(callable) or {}).__call or callable)
    	    end
    	  end
    	
***0	  function busted.safe(descriptor, run, element)
  48	    busted.context.push(element)
    	    local trace, message
  48	    local status = 'success'
    	
  96	    local ret = { xpcall(run, function(msg)
***0	      status = errortype(msg)
***0	      trace = busted.getTrace(element, 3, msg)
***0	      message = busted.rewriteMessage(element, msg, trace)
  96	    end) }
    	
  48	    if not ret[1] then
***0	      if status == 'success' then
***0	        status = 'error'
***0	        trace = busted.getTrace(element, 3, ret[2])
***0	        message = busted.rewriteMessage(element, ret[2], trace)
    	      end
***0	      busted.publish({ status, descriptor }, element, busted.context.parent(element), message, trace)
    	    end
  48	    ret[1] = busted.status(status)
    	
  48	    busted.context.pop()
  48	    return unpack(ret)
    	  end
    	
***0	  function busted.safe_publish(descriptor, channel, element, ...)
  24	    local args = {...}
  24	    local n = select('#', ...)
  48	    local status = busted.safe(descriptor, function()
  24	      busted.publish(channel, element, unpack(args, 1, n))
  48	    end, element)
  24	    return status:success()
    	  end
    	
***0	  function busted.exportApi(key, value)
***0	    busted.api[key] = value
    	  end
    	
***0	  function busted.export(key, value)
***0	    busted.exportApi(key, value)
***0	    environment.set(key, value)
    	  end
    	
***0	  function busted.register(descriptor, executor, attributes)
    	    local alias = nil
***0	    if type(executor) == 'string' then
***0	      alias = descriptor
***0	      descriptor = executor
***0	      executor = executors[descriptor]
***0	      attributes = attributes or eattributes[descriptor]
***0	      executors[alias] = executor
***0	      eattributes[alias] = attributes
    	    else
***0	      if executor ~= nil and not isCallable(executor) then
***0	        attributes = executor
***0	        executor = nil
    	      end
***0	      executors[descriptor] = executor
***0	      eattributes[descriptor] = attributes
    	    end
    	
    	    local publisher = function(name, fn)
  13	      if not fn and type(name) == 'function' then
   2	        fn = name
   2	        name = alias
    	      end
    	
    	      local trace
    	
  13	      local ctx = busted.context.get()
  13	      if busted.context.parent(ctx) then
  12	        trace = busted.getTrace(ctx, 3, name)
    	      end
    	
    	      local publish = function(f)
  13	        busted.publish({ 'register', descriptor }, name, f, trace, attributes)
    	      end
    	
  13	      if fn then publish(fn) else return publish end
    	    end
    	
***0	    local edescriptor = alias or descriptor
***0	    busted.executors[edescriptor] = publisher
***0	    if descriptor ~= 'file' then
***0	      busted.export(edescriptor, publisher)
    	    end
    	
***0	    busted.subscribe({ 'register', descriptor }, function(name, fn, trace, attributes)
  13	      local ctx = busted.context.get()
  13	      local plugin = {
  13	        descriptor = descriptor,
  13	        attributes = attributes or {},
  13	        name = name,
  13	        run = fn,
  13	        trace = trace
    	      }
    	
  13	      busted.context.attach(plugin)
    	
  13	      if not ctx[descriptor] then
   7	        ctx[descriptor] = { plugin }
    	      else
   6	        ctx[descriptor][#ctx[descriptor]+1] = plugin
    	      end
    	    end)
    	  end
    	
***0	  function busted.execute(current)
   5	    if not current then current = busted.context.get() end
  18	    for _, v in pairs(busted.context.children(current)) do
  13	      local executor = executors[v.descriptor]
  13	      if executor and not busted.skipAll then
  22	        busted.safe(v.descriptor, function() executor(v) end, v)
    	      end
    	    end
    	  end
    	
***0	  return busted
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/environment.lua
==============================================================================
***0	local setfenv = require 'busted.compatibility'.setfenv
    	
    	return function(context)
    	
***0	  local environment = {}
    	
    	  local function getEnv(self, key)
 823	    if not self then return nil end
***0	    return
 806	      self.env and self.env[key] or
 645	      getEnv(context.parent(self), key) or
 806	      _G[key]
    	  end
    	
    	  local function setEnv(self, key, value)
***0	    if not self.env then self.env = {} end
***0	    self.env[key] = value
    	  end
    	
    	  local function __index(self, key)
 178	    return getEnv(context.get(), key)
    	  end
    	
    	  local function __newindex(self, key, value)
***0	    setEnv(context.get(), key, value)
    	  end
    	
***0	  local env = setmetatable({}, { __index=__index, __newindex=__newindex })
    	
***0	  function environment.wrap(fn)
   1	    return setfenv(fn, env)
    	  end
    	
***0	  function environment.set(key, value)
***0	    local env = context.get('env')
    	
***0	    if not env then
***0	      env = {}
***0	      context.set('env', env)
    	    end
    	
***0	    env[key] = value
    	  end
***0	  return environment
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/execute.lua
==============================================================================
    	
    	return function(busted)
   1	  local block = require 'busted.block'(busted)
    	
    	  local function execute(runs, options)
   2	    busted.subscribe({'suite', 'reset'}, function()
***0	      local oldctx = busted.context.get()
***0	      local children = busted.context.children(oldctx)
    	
***0	      busted.context.clear()
***0	      local ctx = busted.context.get()
***0	      for k, v in pairs(oldctx) do
***0	        ctx[k] = v
    	      end
    	
***0	      for _, child in ipairs(children) do
***0	        for descriptor, _ in pairs(busted.executors) do
***0	          child[descriptor] = nil
    	        end
***0	        busted.context.attach(child)
    	      end
    	
***0	      busted.randomseed = tonumber(options.seed) or os.time()
    	
***0	      return nil, true
    	    end)
    	
   2	    for i = 1, runs do
   1	      if i > 1 then
***0	        busted.publish({ 'suite', 'reset' })
    	      end
    	
   1	      local root = busted.context.get()
   1	      local seed = (busted.randomize and busted.randomseed or nil)
   1	      if busted.safe_publish('suite', { 'suite', 'start' }, root, i, runs, seed) then
   1	        if block.setup(root) then
   1	          busted.execute()
    	        end
   1	        block.lazyTeardown(root)
   1	        block.teardown(root)
    	      end
   1	      busted.safe_publish('suite', { 'suite', 'end' }, root, i, runs)
    	
   1	      if busted.skipAll then
    	        break
    	      end
    	    end
    	  end
    	
   1	  return execute
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/init.lua
==============================================================================
    	local function init(busted)
***0	  local block = require 'busted.block'(busted)
    	
    	  local file = function(file)
   1	    busted.wrap(file.run)
   1	    if busted.safe_publish('file', { 'file', 'start' }, file) then
   1	      block.execute('file', file)
    	    end
   1	    busted.safe_publish('file', { 'file', 'end' }, file)
    	  end
    	
    	  local describe = function(describe)
   3	    local parent = busted.context.parent(describe)
   3	    if busted.safe_publish('describe', { 'describe', 'start' }, describe, parent) then
   3	      block.execute('describe', describe)
    	    end
   3	    busted.safe_publish('describe', { 'describe', 'end' }, describe, parent)
    	  end
    	
    	  local it = function(element)
   7	    local parent = busted.context.parent(element)
    	    local finally
    	
   7	    if not block.lazySetup(parent) then
    	      -- skip test if any setup failed
***0	      return
    	    end
    	
   7	    if not element.env then element.env = {} end
    	
   7	    block.rejectAll(element)
   7	    element.env.finally = function(fn) finally = fn end
   7	    element.env.pending = function(msg) busted.pending(msg) end
    	
   7	    local pass, ancestor = block.execAll('before_each', parent, true)
    	
   7	    if pass then
   7	      local status = busted.status('success')
   7	      if busted.safe_publish('it', { 'test', 'start' }, element, parent) then
   7	        status:update(busted.safe('it', element.run, element))
   7	        if finally then
***0	          block.reject('pending', element)
***0	          status:update(busted.safe('finally', finally, element))
    	        end
    	      else
***0	        status = busted.status('error')
    	      end
   7	      busted.safe_publish('it', { 'test', 'end' }, element, parent, tostring(status))
    	    end
    	
   7	    block.dexecAll('after_each', ancestor, true)
    	  end
    	
    	  local pending = function(element)
***0	    local parent = busted.context.parent(element)
***0	    local status = 'pending'
***0	    if not busted.safe_publish('it', { 'test', 'start' }, element, parent) then
***0	      status = 'error'
    	    end
***0	    busted.safe_publish('it', { 'test', 'end' }, element, parent, status)
    	  end
    	
***0	  busted.register('file', file, { envmode = 'insulate' })
    	
***0	  busted.register('describe', describe)
***0	  busted.register('insulate', 'describe', { envmode = 'insulate' })
***0	  busted.register('expose', 'describe', { envmode = 'expose' })
    	
***0	  busted.register('it', it)
    	
***0	  busted.register('pending', pending)
    	
***0	  busted.register('before_each', { envmode = 'unwrap' })
***0	  busted.register('after_each', { envmode = 'unwrap' })
    	
***0	  busted.register('lazy_setup', { envmode = 'unwrap' })
***0	  busted.register('lazy_teardown', { envmode = 'unwrap' })
***0	  busted.register('strict_setup', { envmode = 'unwrap' })
***0	  busted.register('strict_teardown', { envmode = 'unwrap' })
    	
***0	  busted.register('setup', 'strict_setup')
***0	  busted.register('teardown', 'strict_teardown')
    	
***0	  busted.register('context', 'describe')
***0	  busted.register('spec', 'it')
***0	  busted.register('test', 'it')
    	
***0	  local assert = require 'luassert'
***0	  local spy    = require 'luassert.spy'
***0	  local mock   = require 'luassert.mock'
***0	  local stub   = require 'luassert.stub'
    	
***0	  busted.export('assert', assert)
***0	  busted.export('spy', spy)
***0	  busted.export('mock', mock)
***0	  busted.export('stub', stub)
    	
***0	  busted.exportApi('publish', busted.publish)
***0	  busted.exportApi('subscribe', busted.subscribe)
***0	  busted.exportApi('unsubscribe', busted.unsubscribe)
    	
***0	  busted.exportApi('bindfenv', busted.bindfenv)
***0	  busted.exportApi('fail', busted.fail)
***0	  busted.exportApi('parent', busted.context.parent)
***0	  busted.exportApi('version', busted.version)
    	
***0	  busted.bindfenv(assert, 'error', busted.fail)
***0	  busted.bindfenv(assert.is_true, 'error', busted.fail)
    	
***0	  return busted
    	end
    	
***0	return setmetatable({}, {
    	  __call = function(self, busted)
***0	    init(busted)
    	
***0	    return setmetatable(self, {
    	      __index = function(self, key)
  38	        return busted.api[key]
    	      end,
    	
    	      __newindex = function(self, key, value)
***0	        error('Attempt to modify busted')
    	      end
    	    })
    	  end
    	})

==============================================================================
/usr/local/share/lua/5.2/busted/languages/en.lua
==============================================================================
   1	local s = require('say')
    	
   1	s:set_namespace('en')
    	
    	-- 'Pending: test.lua @ 12 \n description
   1	s:set('output.pending', 'Pending')
   1	s:set('output.failure', 'Failure')
   1	s:set('output.error', 'Error')
   1	s:set('output.success', 'Success')
    	
   1	s:set('output.pending_plural', 'pending')
   1	s:set('output.failure_plural', 'failures')
   1	s:set('output.error_plural', 'errors')
   1	s:set('output.success_plural', 'successes')
    	
   1	s:set('output.pending_zero', 'pending')
   1	s:set('output.failure_zero', 'failures')
   1	s:set('output.error_zero', 'errors')
   1	s:set('output.success_zero', 'successes')
    	
   1	s:set('output.pending_single', 'pending')
   1	s:set('output.failure_single', 'failure')
   1	s:set('output.error_single', 'error')
   1	s:set('output.success_single', 'success')
    	
   1	s:set('output.seconds', 'seconds')
    	
   1	s:set('output.no_test_files_match', 'No test files found matching Lua pattern: %s')
    	
    	-- definitions following are not used within the 'say' namespace
   1	return {
   1	  failure_messages = {
   1	    'You have %d busted specs',
   1	    'Your specs are busted',
   1	    'Your code is bad and you should feel bad',
   1	    'Your code is in the Danger Zone',
   1	    'Strange game. The only way to win is not to test',
   1	    'My grandmother wrote better specs on a 3 86',
   1	    'Every time there\'s a failure, drink another beer',
***0	    'Feels bad man'
   1	  },
   1	  success_messages = {
   1	    'Aww yeah, passing specs',
   1	    'Doesn\'t matter, had specs',
   1	    'Feels good, man',
   1	    'Great success',
    	    'Tests pass, drink another beer',
   1	  }
   1	}

==============================================================================
/usr/local/share/lua/5.2/busted/modules/files/lua.lua
==============================================================================
   1	local path = require 'pl.path'
    	
   1	local ret = {}
    	
    	local getTrace =  function(filename, info)
  12	  local index = info.traceback:find('\n%s*%[C]')
  12	  info.traceback = info.traceback:sub(1, index)
  12	  return info, false
    	end
    	
    	ret.match = function(busted, filename)
   1	  return path.extension(filename) == '.lua'
    	end
    	
    	
    	ret.load = function(busted, filename)
   1	  local file, err = loadfile(filename)
   1	  if not file then
***0	    busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
    	  end
   1	  return file, getTrace
    	end
    	
   1	return ret

==============================================================================
/usr/local/share/lua/5.2/busted/modules/files/moonscript.lua
==============================================================================
   1	local path = require 'pl.path'
    	
   2	local ok, moonscript, line_tables, util = pcall(function()
   1	  return require 'moonscript', require 'moonscript.line_tables', require 'moonscript.util'
    	end)
    	
   1	local _cache = {}
    	
    	-- find the line number of `pos` chars into fname
    	local lookup_line = function(fname, pos)
***0	  if not _cache[fname] then
***0	    local f = io.open(fname)
***0	    _cache[fname] = f:read('*a')
***0	    f:close()
    	  end
    	
***0	  return util.pos_to_line(_cache[fname], pos)
    	end
    	
    	local rewrite_linenumber = function(fname, lineno)
***0	  local tbl = line_tables['@' .. fname]
***0	  if fname and tbl then
***0	    for i = lineno, 0 ,-1 do
***0	      if tbl[i] then
***0	        return lookup_line(fname, tbl[i])
    	      end
    	    end
    	  end
    	
***0	  return lineno
    	end
    	
    	local rewrite_filename = function(filename)
    	  -- sometimes moonscript gives files like [string "./filename.moon"], so
    	  -- we'll chop it up to only get the filename.
***0	  return filename:match('string "(.+)"') or filename
    	end
    	
    	local rewrite_traceback = function(fname, trace)
    	  local rewrite_one = function(line, pattern, sub)
***0	    if line == nil then return '' end
    	
***0	    local fname, lineno = line:match(pattern)
    	
***0	    if fname and lineno then
***0	      fname = rewrite_filename(fname)
***0	      local new_lineno = rewrite_linenumber(fname, tonumber(lineno))
***0	      if new_lineno then
***0	        line = line:gsub(sub:format(tonumber(lineno)), sub:format(tonumber(new_lineno)))
    	      end
    	    end
    	
***0	    return line
    	  end
    	
***0	  local lines = {}
***0	  local j = 0
    	
***0	  for line in trace:gmatch('[^\r\n]+') do
***0	    j = j + 1
***0	    line = rewrite_one(line, '%s*(.-):(%d+): ', ':%d:')
***0	    line = rewrite_one(line, '<(.*):(%d+)>', ':%d>')
***0	    lines[j] = line
    	  end
    	
***0	  return '\n' .. table.concat(lines, trace:match('[\r\n]+')) .. '\n'
    	end
    	
   1	local ret = {}
    	
    	local getTrace =  function(filename, info)
***0	  local index = info.traceback:find('\n%s*%[C]')
***0	  info.traceback = info.traceback:sub(1, index)
    	
***0	  info.short_src = rewrite_filename(info.short_src)
***0	  info.traceback = rewrite_traceback(filename, info.traceback)
***0	  info.linedefined = rewrite_linenumber(filename, info.linedefined)
***0	  info.currentline = rewrite_linenumber(filename, info.currentline)
    	
***0	  return info
    	end
    	
    	local rewriteMessage = function(filename, message)
***0	  local fname, line, msg = message:match('^([^\n]-):(%d+): (.*)')
***0	  if not fname then
***0	    return message
    	  end
    	
***0	  fname = rewrite_filename(fname)
***0	  line = rewrite_linenumber(fname, tonumber(line))
    	
***0	  return fname .. ':' .. tostring(line) .. ': ' .. msg
    	end
    	
    	ret.match = function(busted, filename)
***0	  return ok and path.extension(filename) == '.moon'
    	end
    	
    	
    	ret.load = function(busted, filename)
***0	  local file, err = moonscript.loadfile(filename)
***0	  if not file then
***0	    busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
    	  end
***0	  return file, getTrace, rewriteMessage
    	end
    	
   1	return ret

==============================================================================
/usr/local/share/lua/5.2/busted/modules/filter_loader.lua
==============================================================================
    	return function()
    	  local function filter(busted, options)
    	    local getFullName = function(name)
   7	      local parent = busted.context.get()
   7	      local names = { name }
    	
  21	      while parent and (parent.name or parent.descriptor) and
  21	            parent.descriptor ~= 'file' do
  14	        table.insert(names, 1, parent.name or parent.descriptor)
  14	        parent = busted.context.parent(parent)
    	      end
    	
   7	      return table.concat(names, ' ')
    	    end
    	
    	    local hasTag = function(name, tag)
***0	      local found = name:find('#' .. tag)
***0	      return (found ~= nil)
    	    end
    	
    	    local filterExcludeTags = function(name)
  10	      for i, tag in pairs(options.excludeTags) do
***0	        if hasTag(name, tag) then
***0	          return nil, false
    	        end
    	      end
  10	      return nil, true
    	    end
    	
    	    local filterTags = function(name)
   7	      local fullname = getFullName(name)
   7	      for i, tag in pairs(options.tags) do
***0	        if hasTag(fullname, tag) then
***0	          return nil, true
    	        end
    	      end
   7	      return nil, (#options.tags == 0)
    	    end
    	
    	    local filterOutNames = function(name)
  10	      for _, filter in pairs(options.filterOut) do
***0	        if getFullName(name):find(filter) ~= nil then
***0	          return nil, false
    	        end
    	      end
  10	      return nil, true
    	    end
    	
    	    local filterNames = function(name)
   7	      for _, filter in pairs(options.filter) do
***0	        if getFullName(name):find(filter) ~= nil then
***0	          return nil, true
    	        end
    	      end
   7	      return nil, (#options.filter == 0)
    	    end
    	
    	    local printNameOnly = function(name, fn, trace)
***0	      local fullname = getFullName(name)
***0	      if trace and trace.what == 'Lua' then
***0	        print(trace.short_src .. ':' .. trace.currentline .. ': ' .. fullname)
    	      else
***0	        print(fullname)
    	      end
***0	      return nil, false
    	    end
    	
    	    local ignoreAll = function()
***0	      return nil, false
    	    end
    	
    	    local skipOnError = function()
***0	      return nil, not busted.skipAll
    	    end
    	
    	    local applyFilter = function(descriptors, name, fn)
   8	      if options[name] and options[name] ~= '' then
  14	        for _, descriptor in ipairs(descriptors) do
  10	          busted.subscribe({ 'register', descriptor }, fn, { priority = 1 })
    	        end
    	      end
    	    end
    	
   1	    if options.list then
***0	      busted.subscribe({ 'suite', 'start' }, ignoreAll, { priority = 1 })
***0	      busted.subscribe({ 'suite', 'end' }, ignoreAll, { priority = 1 })
***0	      applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'list', ignoreAll)
***0	      applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'list', ignoreAll)
***0	      applyFilter({ 'strict_setup', 'strict_teardown' }, 'list', ignoreAll)
***0	      applyFilter({ 'it', 'pending' }, 'list', printNameOnly)
    	    end
    	
   1	    applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'nokeepgoing', skipOnError)
   1	    applyFilter({ 'strict_setup', 'strict_teardown' }, 'nokeepgoing', skipOnError)
   1	    applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'nokeepgoing', skipOnError)
   1	    applyFilter({ 'file', 'describe', 'it', 'pending' }, 'nokeepgoing', skipOnError)
    	
    	    -- The following filters are applied in reverse order
   1	    applyFilter({ 'it', 'pending' }            , 'filter'     , filterNames      )
   1	    applyFilter({ 'describe', 'it', 'pending' }, 'filterOut'  , filterOutNames   )
   1	    applyFilter({ 'it', 'pending' }            , 'tags'       , filterTags       )
   1	    applyFilter({ 'describe', 'it', 'pending' }, 'excludeTags', filterExcludeTags)
    	  end
    	
***0	  return filter
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/modules/output_handler_loader.lua
==============================================================================
***0	local path = require 'pl.path'
***0	local hasMoon, moonscript = pcall(require, 'moonscript')
    	
    	return function()
    	  local loadOutputHandler = function(busted, output, options)
    	    local handler
    	
   2	    local success, err = pcall(function()
   1	      if output:match('%.lua$') then
***0	        handler = dofile(path.normpath(output))
   1	      elseif hasMoon and output:match('%.moon$') then
***0	        handler = moonscript.dofile(path.normpath(output))
    	      else
   1	        handler = require('busted.outputHandlers.' .. output)
    	      end
    	    end)
    	
   1	    if not success and err:match("module '.-' not found:") then
***0	      success, err = pcall(function() handler = require(output) end)
    	    end
    	
   1	    if not success then
***0	      busted.publish({ 'error', 'output' }, { descriptor = 'output', name = output }, nil, err, {})
***0	      handler = require('busted.outputHandlers.' .. options.defaultOutput)
    	    end
    	
   1	    if options.enableSound then
***0	      require 'busted.outputHandlers.sound'(options)
    	    end
    	
   1	    handler(options):subscribe(options)
    	  end
    	
***0	  return loadOutputHandler
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/modules/test_file_loader.lua
==============================================================================
   1	local s = require 'say'
    	
    	return function(busted, loaders)
   1	  local path = require 'pl.path'
   1	  local dir = require 'pl.dir'
   1	  local tablex = require 'pl.tablex'
   1	  local shuffle = require 'busted.utils'.shuffle
   1	  local fileLoaders = {}
    	
   3	  for _, v in pairs(loaders) do
   2	    local loader = require('busted.modules.files.'..v)
   2	    fileLoaders[#fileLoaders+1] = loader
    	  end
    	
    	  local getTestFiles = function(rootFile, pattern, options)
    	    local fileList
    	
   1	    if path.isfile(rootFile) then
***0	      fileList = { rootFile }
   1	    elseif path.isdir(rootFile) then
   1	      local getfiles = options.recursive and dir.getallfiles or dir.getfiles
   1	      fileList = getfiles(rootFile)
    	
   2	      fileList = tablex.filter(fileList, function(filename)
   1	        return path.basename(filename):find(pattern)
    	      end)
    	
   2	      fileList = tablex.filter(fileList, function(filename)
   1	        if path.is_windows then
***0	          return not filename:find('%\\%.%w+.%w+')
    	        else
   1	          return not filename:find('/%.%w+.%w+')
    	        end
    	      end)
    	    else
***0	      fileList = {}
    	    end
    	
   1	    return fileList
    	  end
    	
    	  local getAllTestFiles = function(rootFiles, pattern, options)
   1	    local fileList = {}
   2	    for _, root in ipairs(rootFiles) do
   1	      tablex.insertvalues(fileList, getTestFiles(root, pattern, options))
    	    end
   1	    return fileList
    	  end
    	
    	  -- runs a testfile, loading its tests
    	  local loadTestFile = function(busted, filename)
   1	    for _, v in pairs(fileLoaders) do
   1	      if v.match(busted, filename) then
   1	        return v.load(busted, filename)
    	      end
    	    end
    	  end
    	
    	  local loadTestFiles = function(rootFiles, pattern, options)
   1	    local fileList = getAllTestFiles(rootFiles, pattern, options)
    	
   1	    if options.shuffle then
***0	      shuffle(fileList, options.seed)
   1	    elseif options.sort then
***0	      table.sort(fileList)
    	    end
    	
   2	    for i, fileName in ipairs(fileList) do
   1	      local testFile, getTrace, rewriteMessage = loadTestFile(busted, fileName)
    	
   1	      if testFile then
   2	        local file = setmetatable({
   1	          getTrace = getTrace,
   1	          rewriteMessage = rewriteMessage
   1	        }, {
   1	          __call = testFile
    	        })
    	
   1	        busted.executors.file(fileName, file)
    	      end
    	    end
    	
   1	    if #fileList == 0 then
***0	      busted.publish({ 'error' }, {}, nil, s('output.no_test_files_match'):format(pattern), {})
    	    end
    	
   1	    return fileList
    	  end
    	
   1	  return loadTestFiles, loadTestFile, getAllTestFiles
    	end
    	

==============================================================================
/usr/local/share/lua/5.2/busted/outputHandlers/base.lua
==============================================================================
   1	local socket = require 'socket'
    	
    	return function()
   1	  local busted = require 'busted'
   1	  local handler = {
   1	    successes = {},
   1	    successesCount = 0,
   1	    pendings = {},
   1	    pendingsCount = 0,
   1	    failures = {},
   1	    failuresCount = 0,
   1	    errors = {},
   1	    errorsCount = 0,
   1	    inProgress = {}
    	  }
    	
    	  handler.cancelOnPending = function(element, parent, status)
  21	    return not ((element.descriptor == 'pending' or status == 'pending') and handler.options.suppressPending)
    	  end
    	
    	  handler.subscribe = function(handler, options)
   1	    require('busted.languages.en')
   1	    handler.options = options
    	
   1	    if options.language ~= 'en' then
***0	      require('busted.languages.' .. options.language)
    	    end
    	
   1	    busted.subscribe({ 'suite', 'reset' }, handler.baseSuiteReset, { priority = 1 })
   1	    busted.subscribe({ 'suite', 'start' }, handler.baseSuiteStart, { priority = 1 })
   1	    busted.subscribe({ 'suite', 'end' }, handler.baseSuiteEnd, { priority = 1 })
   1	    busted.subscribe({ 'test', 'start' }, handler.baseTestStart, { priority = 1, predicate = handler.cancelOnPending })
   1	    busted.subscribe({ 'test', 'end' }, handler.baseTestEnd, { priority = 1, predicate = handler.cancelOnPending })
   1	    busted.subscribe({ 'pending' }, handler.basePending, { priority = 1, predicate = handler.cancelOnPending })
   1	    busted.subscribe({ 'failure', 'it' }, handler.baseTestFailure, { priority = 1 })
   1	    busted.subscribe({ 'error', 'it' }, handler.baseTestError, { priority = 1 })
   1	    busted.subscribe({ 'failure' }, handler.baseError, { priority = 1 })
   1	    busted.subscribe({ 'error' }, handler.baseError, { priority = 1 })
    	  end
    	
    	  handler.getFullName = function(context)
   7	    local parent = busted.parent(context)
   7	    local names = { (context.name or context.descriptor) }
    	
  21	    while parent and (parent.name or parent.descriptor) and
  21	          parent.descriptor ~= 'file' do
    	
  14	      table.insert(names, 1, parent.name or parent.descriptor)
  14	      parent = busted.parent(parent)
    	    end
    	
   7	    return table.concat(names, ' ')
    	  end
    	
    	  handler.format = function(element, parent, message, debug, isError)
   7	    local formatted = {
   7	      trace = debug or element.trace,
   7	      element = {
   7	        name = element.name,
   7	        descriptor = element.descriptor,
   7	        attributes = element.attributes,
   7	        trace = element.trace or debug,
   7	      },
   7	      name = handler.getFullName(element),
   7	      message = message,
   7	      randomseed = parent and parent.randomseed,
   7	      isError = isError
    	    }
    	
   7	    return formatted
    	  end
    	
    	  handler.getDuration = function()
   1	    if not handler.endTime or not handler.startTime then
***0	      return 0
    	    end
    	
   1	    return handler.endTime - handler.startTime
    	  end
    	
    	  handler.baseSuiteStart = function()
   1	    handler.startTime = socket.gettime()
   1	    return nil, true
    	  end
    	
    	  handler.baseSuiteReset = function()
***0	    handler.successes = {}
***0	    handler.successesCount = 0
***0	    handler.pendings = {}
***0	    handler.pendingsCount = 0
***0	    handler.failures = {}
***0	    handler.failuresCount = 0
***0	    handler.errors = {}
***0	    handler.errorsCount = 0
***0	    handler.inProgress = {}
    	
***0	    return nil, true
    	  end
    	
    	  handler.baseSuiteEnd = function()
   1	    handler.endTime = socket.gettime()
   1	    return nil, true
    	  end
    	
    	  handler.baseTestStart = function(element, parent)
   7	    handler.inProgress[tostring(element)] = {}
   7	    return nil, true
    	  end
    	
    	  handler.baseTestEnd = function(element, parent, status, debug)
    	    local insertTable
    	
   7	    if status == 'success' then
   7	      insertTable = handler.successes
   7	      handler.successesCount = handler.successesCount + 1
***0	    elseif status == 'pending' then
***0	      insertTable = handler.pendings
***0	      handler.pendingsCount = handler.pendingsCount + 1
***0	    elseif status == 'failure' then
    	      -- failure already saved in failure handler
***0	      handler.failuresCount = handler.failuresCount + 1
***0	      return nil, true
***0	    elseif status == 'error' then
    	      -- error count already incremented and saved in error handler
***0	      insertTable = handler.errors
***0	      return nil, true
    	    end
    	
   7	    local formatted = handler.format(element, parent, element.message, debug)
    	
   7	    local id = tostring(element)
   7	    if handler.inProgress[id] then
   7	      for k, v in pairs(handler.inProgress[id]) do
***0	        formatted[k] = v
    	      end
    	
   7	      handler.inProgress[id] = nil
    	    end
    	
   7	    table.insert(insertTable, formatted)
    	
   7	    return nil, true
    	  end
    	
    	  handler.basePending = function(element, parent, message, debug)
***0	    local id = tostring(element)
***0	    handler.inProgress[id].message = message
***0	    handler.inProgress[id].trace = debug
***0	    return nil, true
    	  end
    	
    	  handler.baseTestFailure = function(element, parent, message, debug)
***0	    table.insert(handler.failures, handler.format(element, parent, message, debug))
***0	    return nil, true
    	  end
    	
    	  handler.baseTestError = function(element, parent, message, debug)
***0	    handler.errorsCount = handler.errorsCount + 1
***0	    table.insert(handler.errors, handler.format(element, parent, message, debug, true))
***0	    return nil, true
    	  end
    	
    	  handler.baseError = function(element, parent, message, debug)
***0	    if element.descriptor ~= 'it' then
***0	      handler.errorsCount = handler.errorsCount + 1
***0	      table.insert(handler.errors, handler.format(element, parent, message, debug, true))
    	    end
    	
***0	    return nil, true
    	  end
    	
   1	  return handler
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/outputHandlers/utfTerminal.lua
==============================================================================
   1	local s = require 'say'
   1	local pretty = require 'pl.pretty'
    	
    	local colors
    	
   1	if package.config:sub(1,1) == '\\' and not os.getenv("ANSICON") then
    	  -- Disable colors on Windows.
***0	  colors = setmetatable({}, {__index = function() return function(s) return s end end})
    	else
   1	  colors = require 'term.colors'
    	end
    	
    	return function(options)
   1	  local busted = require 'busted'
   1	  local handler = require 'busted.outputHandlers.base'()
    	
   1	  local successDot = colors.green('●')
   1	  local failureDot = colors.red('◼')
   1	  local errorDot   = colors.magenta('✱')
   1	  local pendingDot = colors.yellow('◌')
    	
    	  local pendingDescription = function(pending)
***0	    local name = pending.name
    	
***0	    local string = colors.yellow(s('output.pending')) .. ' → ' ..
***0	      colors.cyan(pending.trace.short_src) .. ' @ ' ..
***0	      colors.cyan(pending.trace.currentline)  ..
***0	      '\n' .. colors.bright(name)
    	
***0	    if type(pending.message) == 'string' then
***0	      string = string .. '\n' .. pending.message
***0	    elseif pending.message ~= nil then
***0	      string = string .. '\n' .. pretty.write(pending.message)
    	    end
    	
***0	    return string
    	  end
    	
    	  local failureMessage = function(failure)
***0	    local string = failure.randomseed and ('Random seed: ' .. failure.randomseed .. '\n') or ''
***0	    if type(failure.message) == 'string' then
***0	      string = string .. failure.message
***0	    elseif failure.message == nil then
***0	      string = string .. 'Nil error'
    	    else
***0	      string = string .. pretty.write(failure.message)
    	    end
    	
***0	    return string
    	  end
    	
    	  local failureDescription = function(failure, isError)
***0	    local string = colors.red(s('output.failure')) .. ' → '
***0	    if isError then
***0	      string = colors.magenta(s('output.error')) .. ' → '
    	    end
    	
***0	    if not failure.element.trace or not failure.element.trace.short_src then
***0	      string = string ..
***0	        colors.cyan(failureMessage(failure)) .. '\n' ..
***0	        colors.bright(failure.name)
    	    else
***0	      string = string ..
***0	        colors.cyan(failure.element.trace.short_src) .. ' @ ' ..
***0	        colors.cyan(failure.element.trace.currentline) .. '\n' ..
***0	        colors.bright(failure.name) .. '\n' ..
***0	        failureMessage(failure)
    	    end
    	
***0	    if options.verbose and failure.trace and failure.trace.traceback then
***0	      string = string .. '\n' .. failure.trace.traceback
    	    end
    	
***0	    return string
    	  end
    	
    	  local statusString = function()
   1	    local successString = s('output.success_plural')
   1	    local failureString = s('output.failure_plural')
   1	    local pendingString = s('output.pending_plural')
   1	    local errorString = s('output.error_plural')
    	
   1	    local sec = handler.getDuration()
   1	    local successes = handler.successesCount
   1	    local pendings = handler.pendingsCount
   1	    local failures = handler.failuresCount
   1	    local errors = handler.errorsCount
    	
   1	    if successes == 0 then
***0	      successString = s('output.success_zero')
   1	    elseif successes == 1 then
***0	      successString = s('output.success_single')
    	    end
    	
   1	    if failures == 0 then
   1	      failureString = s('output.failure_zero')
***0	    elseif failures == 1 then
***0	      failureString = s('output.failure_single')
    	    end
    	
   1	    if pendings == 0 then
   1	      pendingString = s('output.pending_zero')
***0	    elseif pendings == 1 then
***0	      pendingString = s('output.pending_single')
    	    end
    	
   1	    if errors == 0 then
   1	      errorString = s('output.error_zero')
***0	    elseif errors == 1 then
***0	      errorString = s('output.error_single')
    	    end
    	
   1	    local formattedTime = ('%.6f'):format(sec):gsub('([0-9])0+$', '%1')
    	
   1	    return colors.green(successes) .. ' ' .. successString .. ' / ' ..
   1	      colors.red(failures) .. ' ' .. failureString .. ' / ' ..
   1	      colors.magenta(errors) .. ' ' .. errorString .. ' / ' ..
   1	      colors.yellow(pendings) .. ' ' .. pendingString .. ' : ' ..
   1	      colors.bright(formattedTime) .. ' ' .. s('output.seconds')
    	  end
    	
    	  handler.testEnd = function(element, parent, status, debug)
   7	    if not options.deferPrint then
   7	      local string = successDot
    	
   7	      if status == 'pending' then
***0	        string = pendingDot
   7	      elseif status == 'failure' then
***0	        string = failureDot
   7	      elseif status == 'error' then
***0	        string = errorDot
    	      end
    	
   7	      io.write(string)
   7	      io.flush()
    	    end
    	
   7	    return nil, true
    	  end
    	
    	  handler.suiteStart = function(suite, count, total)
   1	    local runString = (total > 1 and '\nRepeating all tests (run %d of %d) . . .\n\n' or '')
   1	    io.write(runString:format(count, total))
   1	    io.flush()
    	
   1	    return nil, true
    	  end
    	
    	  handler.suiteEnd = function(suite, count, total)
   1	    print('')
   1	    print(statusString())
    	
   1	    for i, pending in pairs(handler.pendings) do
***0	      print('')
***0	      print(pendingDescription(pending))
    	    end
    	
   1	    for i, err in pairs(handler.failures) do
***0	      print('')
***0	      print(failureDescription(err))
    	    end
    	
   1	    for i, err in pairs(handler.errors) do
***0	      print('')
***0	      print(failureDescription(err, true))
    	    end
    	
   1	    return nil, true
    	  end
    	
    	  handler.error = function(element, parent, message, debug)
***0	    io.write(errorDot)
***0	    io.flush()
    	
***0	    return nil, true
    	  end
    	
   1	  busted.subscribe({ 'test', 'end' }, handler.testEnd, { predicate = handler.cancelOnPending })
   1	  busted.subscribe({ 'suite', 'start' }, handler.suiteStart)
   1	  busted.subscribe({ 'suite', 'end' }, handler.suiteEnd)
   1	  busted.subscribe({ 'error', 'file' }, handler.error)
   1	  busted.subscribe({ 'failure', 'file' }, handler.error)
   1	  busted.subscribe({ 'error', 'describe' }, handler.error)
   1	  busted.subscribe({ 'failure', 'describe' }, handler.error)
    	
   1	  return handler
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/runner.lua
==============================================================================
    	-- Busted command-line runner
    	
***0	local path = require 'pl.path'
***0	local tablex = require 'pl.tablex'
***0	local term = require 'term'
***0	local utils = require 'busted.utils'
***0	local exit = require 'busted.compatibility'.exit
***0	local loaded = false
    	
    	return function(options)
   1	  if loaded then return else loaded = true end
    	
***0	  options = tablex.update(require 'busted.options', options or {})
***0	  options.defaultOutput = term.isatty(io.stdout) and 'utfTerminal' or 'plainTerminal'
    	
***0	  local busted = require 'busted.core'()
    	
***0	  local cli = require 'busted.modules.cli'(options)
***0	  local filterLoader = require 'busted.modules.filter_loader'()
***0	  local helperLoader = require 'busted.modules.helper_loader'()
***0	  local outputHandlerLoader = require 'busted.modules.output_handler_loader'()
    	
***0	  local luacov = require 'busted.modules.luacov'()
    	
***0	  require 'busted'(busted)
    	
***0	  local level = 2
***0	  local info = debug.getinfo(level, 'Sf')
***0	  local source = info.source
***0	  local fileName = source:sub(1,1) == '@' and source:sub(2) or source
    	
    	  -- Parse the cli arguments
***0	  local appName = path.basename(fileName)
***0	  cli:set_name(appName)
***0	  local cliArgs, err = cli:parse(arg)
***0	  if not cliArgs then
***0	    io.stderr:write(err .. '\n')
***0	    exit(1)
    	  end
    	
***0	  if cliArgs.version then
    	    -- Return early if asked for the version
***0	    print(busted.version)
***0	    exit(0)
    	  end
    	
    	  -- Load current working directory
***0	  local _, err = path.chdir(path.normpath(cliArgs.directory))
***0	  if err then
***0	    io.stderr:write(appName .. ': error: ' .. err .. '\n')
***0	    exit(1)
    	  end
    	
    	  -- If coverage arg is passed in, load LuaCovsupport
***0	  if cliArgs.coverage then
***0	    luacov()
    	  end
    	
    	  -- If auto-insulate is disabled, re-register file without insulation
   1	  if not cliArgs['auto-insulate'] then
***0	    busted.register('file', 'file', {})
    	  end
    	
    	  -- If lazy is enabled, make lazy setup/teardown the default
   1	  if cliArgs.lazy then
***0	    busted.register('setup', 'lazy_setup')
***0	    busted.register('teardown', 'lazy_teardown')
    	  end
    	
    	  -- Add additional package paths based on lpath and cpath cliArgs
   1	  if #cliArgs.lpath > 0 then
   1	    package.path = (cliArgs.lpath .. ';' .. package.path):gsub(';;',';')
    	  end
    	
   1	  if #cliArgs.cpath > 0 then
   1	    package.cpath = (cliArgs.cpath .. ';' .. package.cpath):gsub(';;',';')
    	  end
    	
    	  -- watch for test errors and failures
   1	  local failures = 0
   1	  local errors = 0
   1	  local quitOnError = not cliArgs['keep-going']
    	
   2	  busted.subscribe({ 'error', 'output' }, function(element, parent, message)
***0	    io.stderr:write(appName .. ': error: Cannot load output library: ' .. element.name .. '\n' .. message .. '\n')
***0	    return nil, true
    	  end)
    	
   2	  busted.subscribe({ 'error', 'helper' }, function(element, parent, message)
***0	    io.stderr:write(appName .. ': error: Cannot load helper script: ' .. element.name .. '\n' .. message .. '\n')
***0	    return nil, true
    	  end)
    	
   2	  busted.subscribe({ 'error' }, function(element, parent, message)
***0	    errors = errors + 1
***0	    busted.skipAll = quitOnError
***0	    return nil, true
    	  end)
    	
   2	  busted.subscribe({ 'failure' }, function(element, parent, message)
***0	    if element.descriptor == 'it' then
***0	      failures = failures + 1
    	    else
***0	      errors = errors + 1
    	    end
***0	    busted.skipAll = quitOnError
***0	    return nil, true
    	  end)
    	
    	  -- Set up randomization options
   1	  busted.sort = cliArgs['sort-tests']
   1	  busted.randomize = cliArgs['shuffle-tests']
   1	  busted.randomseed = tonumber(cliArgs.seed) or os.time()
    	
    	  -- Set up output handler to listen to events
   2	  outputHandlerLoader(busted, cliArgs.output, {
   1	    defaultOutput = options.defaultOutput,
   1	    enableSound = cliArgs['enable-sound'],
   1	    verbose = cliArgs.verbose,
   1	    suppressPending = cliArgs['suppress-pending'],
   1	    language = cliArgs.lang,
   1	    deferPrint = cliArgs['defer-print'],
   1	    arguments = cliArgs.Xoutput,
    	  })
    	
    	  -- Load tag and test filters
   2	  filterLoader(busted, {
   1	    tags = cliArgs.tags,
   1	    excludeTags = cliArgs['exclude-tags'],
   1	    filter = cliArgs.filter,
   1	    filterOut = cliArgs['filter-out'],
   1	    list = cliArgs.list,
   1	    nokeepgoing = not cliArgs['keep-going'],
    	  })
    	
    	  -- Set up helper script
   1	  if cliArgs.helper and cliArgs.helper ~= '' then
***0	    helperLoader(busted, cliArgs.helper, {
    	      verbose = cliArgs.verbose,
    	      language = cliArgs.lang,
***0	      arguments = cliArgs.Xhelper
    	    })
    	  end
    	
    	  -- Load test directory
   1	  local rootFiles = cliArgs.ROOT or { fileName }
   1	  local pattern = cliArgs.pattern
   1	  local testFileLoader = require 'busted.modules.test_file_loader'(busted, cliArgs.loaders)
   2	  testFileLoader(rootFiles, pattern, {
   1	    verbose = cliArgs.verbose,
   1	    sort = cliArgs['sort-files'],
   1	    shuffle = cliArgs['shuffle-files'],
   1	    recursive = cliArgs['recursive'],
   1	    seed = busted.randomseed
    	  })
    	
    	  -- If running standalone, setup test file to be compatible with live coding
   1	  if options.standalone then
***0	    local ctx = busted.context.get()
***0	    local children = busted.context.children(ctx)
***0	    local file = children[#children]
***0	    debug.getmetatable(file.run).__call = info.func
    	  end
    	
   1	  local runs = cliArgs['repeat']
   1	  local execute = require 'busted.execute'(busted)
   1	  execute(runs, { seed = cliArgs.seed })
    	
   1	  busted.publish({ 'exit' })
    	
   1	  if options.standalone or failures > 0 or errors > 0 then
***0	    exit(failures + errors)
    	  end
    	end

==============================================================================
/usr/local/share/lua/5.2/busted/status.lua
==============================================================================
    	local function get_status(status)
  62	  local smap = {
  62	    ['success'] = 'success',
  62	    ['pending'] = 'pending',
  62	    ['failure'] = 'failure',
  62	    ['error'] = 'error',
  62	    ['true'] = 'success',
  62	    ['false'] = 'failure',
  62	    ['nil'] = 'error',
    	  }
  62	  return smap[tostring(status)] or 'error'
    	end
    	
    	return function(inital_status)
  55	  local objstat = get_status(inital_status)
  55	  local obj = {
  85	    success = function(self) return (objstat == 'success') end,
  55	    pending = function(self) return (objstat == 'pending') end,
  55	    failure = function(self) return (objstat == 'failure') end,
  55	    error   = function(self) return (objstat == 'error') end,
    	
    	    get = function(self)
***0	      return objstat
    	    end,
    	
    	    set = function(self, status)
***0	      objstat = get_status(status)
    	    end,
    	
    	    update = function(self, status)
    	      -- prefer current failure/error status over new status
   7	      status = get_status(status)
   7	      if objstat == 'success' or (objstat == 'pending' and status ~= 'success') then
   7	        objstat = status
    	      end
    	    end
    	  }
    	
 110	  return setmetatable(obj, {
  55	    __index = {},
  69	    __tostring = function(self) return objstat end
  55	  })
    	end

==============================================================================
/usr/local/share/lua/5.2/luarocks/deps.lua
==============================================================================
    	
    	--- Dependency handling functions.
    	-- Dependencies are represented in LuaRocks through strings with
    	-- a package name followed by a comma-separated list of constraints.
    	-- Each constraint consists of an operator and a version number.
    	-- In this string format, version numbers are represented as
    	-- naturally as possible, like they are used by upstream projects
    	-- (e.g. "2.0beta3"). Internally, LuaRocks converts them to a purely
    	-- numeric representation, allowing comparison following some
    	-- "common sense" heuristics. The precise specification of the
    	-- comparison criteria is the source code of this module, but the
    	-- test/test_deps.lua file included with LuaRocks provides some
    	-- insights on what these criteria are.
    	--module("luarocks.deps", package.seeall)
***0	local deps = {}
***0	package.loaded["luarocks.deps"] = deps
    	
***0	local cfg = require("luarocks.cfg")
***0	local manif_core = require("luarocks.manif_core")
***0	local path = require("luarocks.path")
***0	local dir = require("luarocks.dir")
***0	local util = require("luarocks.util")
    	
***0	local operators = {
    	   ["=="] = "==",
    	   ["~="] = "~=",
    	   [">"] = ">",
    	   ["<"] = "<",
    	   [">="] = ">=",
    	   ["<="] = "<=",
    	   ["~>"] = "~>",
    	   -- plus some convenience translations
    	   [""] = "==",
    	   ["="] = "==",
***0	   ["!="] = "~="
    	}
    	
***0	local deltas = {
    	   scm =    1100,
    	   cvs =    1000,
    	   rc =    -1000,
    	   pre =   -10000,
    	   beta =  -100000,
***0	   alpha = -1000000
    	}
    	
***0	local version_mt = {
    	   --- Equality comparison for versions.
    	   -- All version numbers must be equal.
    	   -- If both versions have revision numbers, they must be equal;
    	   -- otherwise the revision number is ignored.
    	   -- @param v1 table: version table to compare.
    	   -- @param v2 table: version table to compare.
    	   -- @return boolean: true if they are considered equivalent.
    	   __eq = function(v1, v2)
***0	      if #v1 ~= #v2 then
***0	         return false
    	      end
***0	      for i = 1, #v1 do
***0	         if v1[i] ~= v2[i] then
***0	            return false
    	         end
    	      end
***0	      if v1.revision and v2.revision then
***0	         return (v1.revision == v2.revision)
    	      end
***0	      return true
    	   end,
    	   --- Size comparison for versions.
    	   -- All version numbers are compared.
    	   -- If both versions have revision numbers, they are compared;
    	   -- otherwise the revision number is ignored.
    	   -- @param v1 table: version table to compare.
    	   -- @param v2 table: version table to compare.
    	   -- @return boolean: true if v1 is considered lower than v2.
    	   __lt = function(v1, v2)
   4	      for i = 1, math.max(#v1, #v2) do
   3	         local v1i, v2i = v1[i] or 0, v2[i] or 0
   3	         if v1i ~= v2i then
***0	            return (v1i < v2i)
    	         end
    	      end
   1	      if v1.revision and v2.revision then
   1	         return (v1.revision < v2.revision)
    	      end
***0	      return false
    	   end
    	}
    	
***0	local version_cache = {}
***0	setmetatable(version_cache, {
***0	   __mode = "kv"
    	})
    	
    	--- Parse a version string, converting to table format.
    	-- A version table contains all components of the version string
    	-- converted to numeric format, stored in the array part of the table.
    	-- If the version contains a revision, it is stored numerically
    	-- in the 'revision' field. The original string representation of
    	-- the string is preserved in the 'string' field.
    	-- Returned version tables use a metatable
    	-- allowing later comparison through relational operators.
    	-- @param vstring string: A version number in string format.
    	-- @return table or nil: A version table or nil
    	-- if the input string contains invalid characters.
***0	function deps.parse_version(vstring)
   8	   if not vstring then return nil end
   8	   assert(type(vstring) == "string")
    	
   8	   local cached = version_cache[vstring]
   8	   if cached then
***0	      return cached
    	   end
    	
   8	   local version = {}
   8	   local i = 1
    	
    	   local function add_token(number)
  20	      version[i] = version[i] and version[i] + number/100000 or number
  20	      i = i + 1
    	   end
    	   
    	   -- trim leading and trailing spaces
   8	   vstring = vstring:match("^%s*(.*)%s*$")
   8	   version.string = vstring
    	   -- store revision separately if any
   8	   local main, revision = vstring:match("(.*)%-(%d+)$")
   8	   if revision then
   8	      vstring = main
   8	      version.revision = tonumber(revision)
    	   end
  30	   while #vstring > 0 do
    	      -- extract a number
  22	      local token, rest = vstring:match("^(%d+)[%.%-%_]*(.*)")
  22	      if token then
  20	         add_token(tonumber(token))
    	      else
    	         -- extract a word
   2	         token, rest = vstring:match("^(%a+)[%.%-%_]*(.*)")
   2	         if not token then
***0	            util.printerr("Warning: version number '"..vstring.."' could not be parsed.")
***0	            version[i] = 0
    	            break
    	         end
   2	         version[i] = deltas[token] or (token:byte() / 1000)
    	      end
  22	      vstring = rest
    	   end
   8	   setmetatable(version, version_mt)
   8	   version_cache[vstring] = version
   8	   return version
    	end
    	
    	--- Utility function to compare version numbers given as strings.
    	-- @param a string: one version.
    	-- @param b string: another version.
    	-- @return boolean: True if a > b.
***0	function deps.compare_versions(a, b)
***0	   return deps.parse_version(a) > deps.parse_version(b)
    	end
    	
    	--- Consumes a constraint from a string, converting it to table format.
    	-- For example, a string ">= 1.0, > 2.0" is converted to a table in the
    	-- format {op = ">=", version={1,0}} and the rest, "> 2.0", is returned
    	-- back to the caller.
    	-- @param input string: A list of constraints in string format.
    	-- @return (table, string) or nil: A table representing the same
    	-- constraints and the string with the unused input, or nil if the
    	-- input string is invalid.
    	local function parse_constraint(input)
***0	   assert(type(input) == "string")
    	
***0	   local no_upgrade, op, version, rest = input:match("^(@?)([<>=~!]*)%s*([%w%.%_%-]+)[%s,]*(.*)")
***0	   local _op = operators[op]
***0	   version = deps.parse_version(version)
***0	   if not _op then
***0	      return nil, "Encountered bad constraint operator: '"..tostring(op).."' in '"..input.."'"
    	   end
***0	   if not version then 
***0	      return nil, "Could not parse version from constraint: '"..input.."'"
    	   end
***0	   return { op = _op, version = version, no_upgrade = no_upgrade=="@" and true or nil }, rest
    	end
    	
    	--- Convert a list of constraints from string to table format.
    	-- For example, a string ">= 1.0, < 2.0" is converted to a table in the format
    	-- {{op = ">=", version={1,0}}, {op = "<", version={2,0}}}.
    	-- Version tables use a metatable allowing later comparison through
    	-- relational operators.
    	-- @param input string: A list of constraints in string format.
    	-- @return table or nil: A table representing the same constraints,
    	-- or nil if the input string is invalid.
***0	function deps.parse_constraints(input)
***0	   assert(type(input) == "string")
    	
***0	   local constraints, constraint, oinput = {}, nil, input
***0	   while #input > 0 do
***0	      constraint, input = parse_constraint(input)
***0	      if constraint then
***0	         table.insert(constraints, constraint)
    	      else
***0	         return nil, "Failed to parse constraint '"..tostring(oinput).."' with error: ".. input
    	      end
    	   end
***0	   return constraints
    	end
    	
    	--- Convert a dependency from string to table format.
    	-- For example, a string "foo >= 1.0, < 2.0"
    	-- is converted to a table in the format
    	-- {name = "foo", constraints = {{op = ">=", version={1,0}},
    	-- {op = "<", version={2,0}}}}. Version tables use a metatable
    	-- allowing later comparison through relational operators.
    	-- @param dep string: A dependency in string format
    	-- as entered in rockspec files.
    	-- @return table or nil: A table representing the same dependency relation,
    	-- or nil if the input string is invalid.
***0	function deps.parse_dep(dep)
***0	   assert(type(dep) == "string")
    	
***0	   local name, rest = dep:match("^%s*([a-zA-Z0-9][a-zA-Z0-9%.%-%_]*)%s*(.*)")
***0	   if not name then return nil, "failed to extract dependency name from '"..tostring(dep).."'" end
***0	   local constraints, err = deps.parse_constraints(rest)
***0	   if not constraints then return nil, err end
***0	   return { name = name, constraints = constraints }
    	end
    	
    	--- Convert a version table to a string.
    	-- @param v table: The version table
    	-- @param internal boolean or nil: Whether to display versions in their
    	-- internal representation format or how they were specified.
    	-- @return string: The dependency information pretty-printed as a string.
***0	function deps.show_version(v, internal)
***0	   assert(type(v) == "table")
***0	   assert(type(internal) == "boolean" or not internal)
    	
***0	   return (internal
***0	           and table.concat(v, ":")..(v.revision and tostring(v.revision) or "")
***0	           or v.string)
    	end
    	
    	--- Convert a dependency in table format to a string.
    	-- @param dep table: The dependency in table format
    	-- @param internal boolean or nil: Whether to display versions in their
    	-- internal representation format or how they were specified.
    	-- @return string: The dependency information pretty-printed as a string.
***0	function deps.show_dep(dep, internal)
***0	   assert(type(dep) == "table")
***0	   assert(type(internal) == "boolean" or not internal)
    	   
***0	   local pretty = {}
***0	   for _, c in ipairs(dep.constraints) do
***0	      table.insert(pretty, c.op .. " " .. deps.show_version(c.version, internal))
    	   end
***0	   return dep.name.." "..table.concat(pretty, ", ")
    	end
    	
    	--- A more lenient check for equivalence between versions.
    	-- This returns true if the requested components of a version
    	-- match and ignore the ones that were not given. For example,
    	-- when requesting "2", then "2", "2.1", "2.3.5-9"... all match.
    	-- When requesting "2.1", then "2.1", "2.1.3" match, but "2.2"
    	-- doesn't.
    	-- @param version string or table: Version to be tested; may be
    	-- in string format or already parsed into a table.
    	-- @param requested string or table: Version requested; may be
    	-- in string format or already parsed into a table.
    	-- @return boolean: True if the tested version matches the requested
    	-- version, false otherwise.
    	local function partial_match(version, requested)
***0	   assert(type(version) == "string" or type(version) == "table")
***0	   assert(type(requested) == "string" or type(version) == "table")
    	
***0	   if type(version) ~= "table" then version = deps.parse_version(version) end
***0	   if type(requested) ~= "table" then requested = deps.parse_version(requested) end
***0	   if not version or not requested then return false end
    	   
***0	   for i, ri in ipairs(requested) do
***0	      local vi = version[i] or 0
***0	      if ri ~= vi then return false end
    	   end
***0	   if requested.revision then
***0	      return requested.revision == version.revision
    	   end
***0	   return true
    	end
    	
    	--- Check if a version satisfies a set of constraints.
    	-- @param version table: A version in table format
    	-- @param constraints table: An array of constraints in table format.
    	-- @return boolean: True if version satisfies all constraints,
    	-- false otherwise.
***0	function deps.match_constraints(version, constraints)
***0	   assert(type(version) == "table")
***0	   assert(type(constraints) == "table")
***0	   local ok = true
***0	   setmetatable(version, version_mt)
***0	   for _, constr in pairs(constraints) do
***0	      if type(constr.version) == "string" then
***0	         constr.version = deps.parse_version(constr.version)
    	      end
***0	      local constr_version, constr_op = constr.version, constr.op
***0	      setmetatable(constr_version, version_mt)
***0	      if     constr_op == "==" then ok = version == constr_version
***0	      elseif constr_op == "~=" then ok = version ~= constr_version
***0	      elseif constr_op == ">"  then ok = version >  constr_version
***0	      elseif constr_op == "<"  then ok = version <  constr_version
***0	      elseif constr_op == ">=" then ok = version >= constr_version
***0	      elseif constr_op == "<=" then ok = version <= constr_version
***0	      elseif constr_op == "~>" then ok = partial_match(version, constr_version)
    	      end
***0	      if not ok then break end
    	   end
***0	   return ok
    	end
    	
    	--- Attempt to match a dependency to an installed rock.
    	-- @param dep table: A dependency parsed in table format.
    	-- @param blacklist table: Versions that can't be accepted. Table where keys
    	-- are program versions and values are 'true'.
    	-- @return table or nil: A table containing fields 'name' and 'version'
    	-- representing an installed rock which matches the given dependency,
    	-- or nil if it could not be matched.
    	local function match_dep(dep, blacklist, deps_mode)
***0	   assert(type(dep) == "table")
    	
***0	   local versions = cfg.rocks_provided[dep.name]
***0	   if cfg.rocks_provided[dep.name] then
    	      -- provided rocks have higher priority than manifest's rocks
***0	      versions = { cfg.rocks_provided[dep.name] }
    	   else
***0	      versions = manif_core.get_versions(dep.name, deps_mode)
    	   end
***0	   if not versions then
***0	      return nil
    	   end
***0	   if blacklist then
***0	      local i = 1
***0	      while versions[i] do
***0	         if blacklist[versions[i]] then
***0	            table.remove(versions, i)
    	         else
***0	            i = i + 1
    	         end
    	      end
    	   end
***0	   local candidates = {}
***0	   for _, vstring in ipairs(versions) do
***0	      local version = deps.parse_version(vstring)
***0	      if deps.match_constraints(version, dep.constraints) then
***0	         table.insert(candidates, version)
    	      end
    	   end
***0	   if #candidates == 0 then
***0	      return nil
    	   else
***0	      table.sort(candidates)
***0	      return {
    	         name = dep.name,
***0	         version = candidates[#candidates].string
    	      }
    	   end
    	end
    	
    	--- Attempt to match dependencies of a rockspec to installed rocks.
    	-- @param rockspec table: The rockspec loaded as a table.
    	-- @param blacklist table or nil: Program versions to not use as valid matches.
    	-- Table where keys are program names and values are tables where keys
    	-- are program versions and values are 'true'.
    	-- @return table, table, table: A table where keys are dependencies parsed
    	-- in table format and values are tables containing fields 'name' and
    	-- version' representing matches; a table of missing dependencies
    	-- parsed as tables; and a table of "no-upgrade" missing dependencies
    	-- (to be used in plugin modules so that a plugin does not force upgrade of
    	-- its parent application).
***0	function deps.match_deps(rockspec, blacklist, deps_mode)
***0	   assert(type(rockspec) == "table")
***0	   assert(type(blacklist) == "table" or not blacklist)
***0	   local matched, missing, no_upgrade = {}, {}, {}
    	   
***0	   for _, dep in ipairs(rockspec.dependencies) do
***0	      local found = match_dep(dep, blacklist and blacklist[dep.name] or nil, deps_mode)
***0	      if found then
***0	         if not cfg.rocks_provided[dep.name] then
***0	            matched[dep] = found
    	         end
    	      else
***0	         if dep.constraints[1] and dep.constraints[1].no_upgrade then
***0	            no_upgrade[dep.name] = dep
    	         else
***0	            missing[dep.name] = dep
    	         end
    	      end
    	   end
***0	   return matched, missing, no_upgrade
    	end
    	
    	--- Return a set of values of a table.
    	-- @param tbl table: The input table.
    	-- @return table: The array of keys.
    	local function values_set(tbl)
***0	   local set = {}
***0	   for _, v in pairs(tbl) do
***0	      set[v] = true
    	   end
***0	   return set
    	end
    	
    	--- Check dependencies of a rock and attempt to install any missing ones.
    	-- Packages are installed using the LuaRocks "install" command.
    	-- Aborts the program if a dependency could not be fulfilled.
    	-- @param rockspec table: A rockspec in table format.
    	-- @return boolean or (nil, string, [string]): True if no errors occurred, or
    	-- nil and an error message if any test failed, followed by an optional
    	-- error code.
***0	function deps.fulfill_dependencies(rockspec, deps_mode)
    	
***0	   local search = require("luarocks.search")
***0	   local install = require("luarocks.install")
    	
***0	   if rockspec.supported_platforms then
***0	      if not deps.platforms_set then
***0	         deps.platforms_set = values_set(cfg.platforms)
    	      end
    	      local supported = nil
***0	      for _, plat in pairs(rockspec.supported_platforms) do
***0	         local neg, plat = plat:match("^(!?)(.*)")
***0	         if neg == "!" then
***0	            if deps.platforms_set[plat] then
***0	               return nil, "This rockspec for "..rockspec.package.." does not support "..plat.." platforms."
    	            end
    	         else
***0	            if deps.platforms_set[plat] then
***0	               supported = true
    	            else
***0	               if supported == nil then
***0	                  supported = false
    	               end
    	            end
    	         end
    	      end
***0	      if supported == false then
***0	         local plats = table.concat(cfg.platforms, ", ")
***0	         return nil, "This rockspec for "..rockspec.package.." does not support "..plats.." platforms."
    	      end
    	   end
    	
***0	   local _, missing, no_upgrade = deps.match_deps(rockspec, nil, deps_mode)
    	
***0	   if next(no_upgrade) then
***0	      util.printerr("Missing dependencies for "..rockspec.name.." "..rockspec.version..":")
***0	      for _, dep in pairs(no_upgrade) do
***0	         util.printerr(deps.show_dep(dep))
    	      end
***0	      if next(missing) then
***0	         for _, dep in pairs(missing) do
***0	            util.printerr(deps.show_dep(dep))
    	         end
    	      end
***0	      util.printerr()
***0	      for _, dep in pairs(no_upgrade) do
***0	         util.printerr("This version of "..rockspec.name.." is designed for use with")
***0	         util.printerr(deps.show_dep(dep)..", but is configured to avoid upgrading it")
***0	         util.printerr("automatically. Please upgrade "..dep.name.." with")
***0	         util.printerr("   luarocks install "..dep.name)
***0	         util.printerr("or choose an older version of "..rockspec.name.." with")
***0	         util.printerr("   luarocks search "..rockspec.name)
    	      end
***0	      return nil, "Failed matching dependencies."
    	   end
    	
***0	   if next(missing) then
***0	      util.printerr()
***0	      util.printerr("Missing dependencies for "..rockspec.name..":")
***0	      for _, dep in pairs(missing) do
***0	         util.printerr(deps.show_dep(dep))
    	      end
***0	      util.printerr()
    	
***0	      for _, dep in pairs(missing) do
    	         -- Double-check in case dependency was filled during recursion.
***0	         if not match_dep(dep, nil, deps_mode) then
***0	            local rock = search.find_suitable_rock(dep)
***0	            if not rock then
***0	               return nil, "Could not satisfy dependency: "..deps.show_dep(dep)
    	            end
***0	            local ok, err, errcode = install.run(rock)
***0	            if not ok then
***0	               return nil, "Failed installing dependency: "..rock.." - "..err, errcode
    	            end
    	         end
    	      end
    	   end
***0	   return true
    	end
    	
    	--- If filename matches a pattern, return the capture.
    	-- For example, given "libfoo.so" and "lib?.so" is a pattern,
    	-- returns "foo" (which can then be used to build names
    	-- based on other patterns.
    	-- @param file string: a filename
    	-- @param pattern string: a pattern, where ? is to be matched by the filename.
    	-- @return string The pattern, if found, or nil.
    	local function deconstruct_pattern(file, pattern)
***0	   local depattern = "^"..(pattern:gsub("%.", "%%."):gsub("%*", ".*"):gsub("?", "(.*)")).."$"
***0	   return (file:match(depattern))
    	end
    	
    	--- Construct all possible patterns for a name and add to the files array.
    	-- Run through the patterns array replacing all occurrences of "?"
    	-- with the given file name and store them in the files array.
    	-- @param file string A raw name (e.g. "foo")
    	-- @param array of string An array of patterns with "?" as the wildcard
    	-- (e.g. {"?.so", "lib?.so"})
    	-- @param files The array of constructed names
    	local function add_all_patterns(file, patterns, files)
***0	   for _, pattern in ipairs(patterns) do
***0	      table.insert(files, (pattern:gsub("?", file)))
    	   end
    	end
    	
    	--- Set up path-related variables for external dependencies.
    	-- For each key in the external_dependencies table in the
    	-- rockspec file, four variables are created: <key>_DIR, <key>_BINDIR,
    	-- <key>_INCDIR and <key>_LIBDIR. These are not overwritten
    	-- if already set (e.g. by the LuaRocks config file or through the
    	-- command-line). Values in the external_dependencies table
    	-- are tables that may contain a "header" or a "library" field,
    	-- with filenames to be tested for existence.
    	-- @param rockspec table: The rockspec table.
    	-- @param mode string: if "build" is given, checks all files;
    	-- if "install" is given, do not scan for headers.
    	-- @return boolean or (nil, string): True if no errors occurred, or
    	-- nil and an error message if any test failed.
***0	function deps.check_external_deps(rockspec, mode)
***0	   assert(type(rockspec) == "table")
    	
***0	   local fs = require("luarocks.fs")
    	   
***0	   local vars = rockspec.variables
***0	   local patterns = cfg.external_deps_patterns
***0	   local subdirs = cfg.external_deps_subdirs
***0	   if mode == "install" then
***0	      patterns = cfg.runtime_external_deps_patterns
***0	      subdirs = cfg.runtime_external_deps_subdirs
    	   end
***0	   if rockspec.external_dependencies then
***0	      for name, ext_files in util.sortedpairs(rockspec.external_dependencies) do
***0	         local ok = true
***0	         local failed_files = {program = {}, header = {}, library = {}}
    	         local failed_dirname
    	         local failed_testfile
***0	         for _, extdir in ipairs(cfg.external_deps_dirs) do
***0	            ok = true
***0	            local prefix = vars[name.."_DIR"]
***0	            local dirs = {
    	               BINDIR = { subdir = subdirs.bin, testfile = "program", pattern = patterns.bin },
    	               INCDIR = { subdir = subdirs.include, testfile = "header", pattern = patterns.include },
***0	               LIBDIR = { subdir = subdirs.lib, testfile = "library", pattern = patterns.lib }
    	            }
***0	            if mode == "install" then
***0	               dirs.INCDIR = nil
    	            end
***0	            if not prefix then
***0	               prefix = extdir
    	            end
***0	            if type(prefix) == "table" then
***0	               if prefix.bin then
***0	                  dirs.BINDIR.subdir = prefix.bin
    	               end
***0	               if prefix.include then
***0	                  if dirs.INCDIR then
***0	                     dirs.INCDIR.subdir = prefix.include
    	                  end
    	               end
***0	               if prefix.lib then
***0	                  dirs.LIBDIR.subdir = prefix.lib
    	               end
***0	               prefix = prefix.prefix
    	            end
***0	            for dirname, dirdata in util.sortedpairs(dirs) do
    	               local paths
***0	               local path_var_value = vars[name.."_"..dirname]
***0	               if path_var_value then
***0	                  paths = { path_var_value }
***0	               elseif type(dirdata.subdir) == "table" then
***0	                  paths = {}
***0	                  for i,v in ipairs(dirdata.subdir) do
***0	                     paths[i] = dir.path(prefix, v)
    	                  end
    	               else
***0	                  paths = { dir.path(prefix, dirdata.subdir) }
    	               end
***0	               dirdata.dir = paths[1]
***0	               local file = ext_files[dirdata.testfile]
***0	               if file then
***0	                  local files = {}
***0	                  if not file:match("%.") then
***0	                     add_all_patterns(file, dirdata.pattern, files)
    	                  else
***0	                     for _, pattern in ipairs(dirdata.pattern) do
***0	                        local matched = deconstruct_pattern(file, pattern)
***0	                        if matched then
***0	                           add_all_patterns(matched, dirdata.pattern, files)
    	                        end
    	                     end
***0	                     table.insert(files, file)
    	                  end
***0	                  local found = false
***0	                  for _, f in ipairs(files) do
    	
    	                     -- small convenience hack
***0	                     if f:match("%.so$") or f:match("%.dylib$") or f:match("%.dll$") then
***0	                        f = f:gsub("%.[^.]+$", "."..cfg.external_lib_extension)
    	                     end
    	
    	                     local pattern
***0	                     if f:match("%*") then
***0	                        pattern = f:gsub("%.", "%%."):gsub("%*", ".*")
***0	                        f = "matching "..f
    	                     end
    	
***0	                     for _, d in ipairs(paths) do
***0	                        if pattern then
***0	                           for entry in fs.dir(d) do
***0	                              if entry:match(pattern) then
***0	                                 found = true
    	                                 break
    	                              end
    	                           end
    	                        else
***0	                           found = fs.is_file(dir.path(d, f))
    	                        end
***0	                        if found then
***0	                           dirdata.dir = d
    	                           break
    	                        else
***0	                           table.insert(failed_files[dirdata.testfile], f.." in "..d)
    	                        end
    	                     end
***0	                     if found then
    	                        break
    	                     end
    	                  end
***0	                  if not found then
***0	                     ok = false
***0	                     failed_dirname = dirname
***0	                     failed_testfile = dirdata.testfile
    	                     break
    	                  end
    	               end
    	            end
***0	            if ok then
***0	               for dirname, dirdata in pairs(dirs) do
***0	                  vars[name.."_"..dirname] = dirdata.dir
    	               end
***0	               vars[name.."_DIR"] = prefix
    	               break
    	            end
    	         end
***0	         if not ok then
***0	            local lines = {"Could not find "..failed_testfile.." file for "..name}
    	
***0	            local failed_paths = {}
***0	            for _, failed_file in ipairs(failed_files[failed_testfile]) do
***0	               if not failed_paths[failed_file] then
***0	                  failed_paths[failed_file] = true
***0	                  table.insert(lines, "  No file "..failed_file)
    	               end
    	            end
    	
***0	            table.insert(lines, "You may have to install "..name.." in your system and/or pass "..name.."_DIR or "..name.."_"..failed_dirname.." to the luarocks command.")
***0	            table.insert(lines, "Example: luarocks install "..rockspec.name.." "..name.."_DIR=/usr/local")
    	
***0	            return nil, table.concat(lines, "\n"), "dependency"
    	         end
    	      end
    	   end
***0	   return true
    	end
    	
    	--- Recursively scan dependencies, to build a transitive closure of all
    	-- dependent packages.
    	-- @param results table: The results table being built.
    	-- @param missing table: The table of missing dependencies being recursively built.
    	-- @param manifest table: The manifest table containing dependencies.
    	-- @param name string: Package name.
    	-- @param version string: Package version.
    	-- @return (table, table): The results and a table of missing dependencies.
***0	function deps.scan_deps(results, missing, manifest, name, version, deps_mode)
***0	   assert(type(results) == "table")
***0	   assert(type(missing) == "table")
***0	   assert(type(manifest) == "table")
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
    	
***0	   local fetch = require("luarocks.fetch")
    	
    	   local err
***0	   if results[name] then
***0	      return results, missing
    	   end
***0	   if not manifest.dependencies then manifest.dependencies = {} end
***0	   local dependencies = manifest.dependencies
***0	   if not dependencies[name] then dependencies[name] = {} end
***0	   local dependencies_name = dependencies[name]
***0	   local deplist = dependencies_name[version]
    	   local rockspec, err
***0	   if not deplist then
***0	      rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version), false)
***0	      if err then
***0	         missing[name.." "..version] = err
***0	         return results, missing
    	      end
***0	      dependencies_name[version] = rockspec.dependencies
    	   else
***0	      rockspec = { dependencies = deplist }
    	   end
***0	   local matched, failures = deps.match_deps(rockspec, nil, deps_mode)
***0	   results[name] = results
***0	   for _, match in pairs(matched) do
***0	      results, missing = deps.scan_deps(results, missing, manifest, match.name, match.version, deps_mode)
    	   end
***0	   if next(failures) then
***0	      for _, failure in pairs(failures) do
***0	         missing[deps.show_dep(failure)] = "failed"
    	      end
    	   end
***0	   results[name] = version
***0	   return results, missing
    	end
    	
***0	local valid_deps_modes = {
    	   one = true,
    	   order = true,
    	   all = true,
    	   none = true,
    	}
    	
***0	function deps.check_deps_mode_flag(flag)
***0	   return valid_deps_modes[flag]
    	end
    	
***0	function deps.get_deps_mode(flags)
***0	   if flags["deps-mode"] then
***0	      return flags["deps-mode"]
    	   else
***0	      return cfg.deps_mode
    	   end
    	end
    	
***0	function deps.deps_mode_to_flag(deps_mode)
***0	   return "--deps-mode="..deps_mode
    	end
    	
***0	return deps

==============================================================================
/usr/local/share/lua/5.2/luarocks/loader.lua
==============================================================================
    	
    	--- A module which installs a Lua package loader that is LuaRocks-aware.
    	-- This loader uses dependency information from the LuaRocks tree to load
    	-- correct versions of modules. It does this by constructing a "context"
    	-- table in the environment, which records which versions of packages were
    	-- used to load previous modules, so that the loader chooses versions
    	-- that are declared to be compatible with the ones loaded earlier.
***0	local loaders = package.loaders or package.searchers
    	local package, require, ipairs, pairs, table, type, next, tostring, error =
***0	      package, require, ipairs, pairs, table, type, next, tostring, error
***0	local unpack = unpack or table.unpack
    	
    	--module("luarocks.loader")
***0	local loader = {}
***0	package.loaded["luarocks.loader"] = loader
    	
***0	local cfg = require("luarocks.cfg")
***0	cfg.init_package_paths()
    	
***0	local path = require("luarocks.path")
***0	local manif_core = require("luarocks.manif_core")
***0	local deps = require("luarocks.deps")
    	
***0	loader.context = {}
    	
    	-- Contains a table when rocks trees are loaded,
    	-- or 'false' to indicate rocks trees failed to load.
    	-- 'nil' indicates rocks trees were not attempted to be loaded yet.
***0	loader.rocks_trees = nil
    	
    	local function load_rocks_trees() 
***0	   local any_ok = false
***0	   local trees = {}
***0	   for _, tree in ipairs(cfg.rocks_trees) do
***0	      local manifest, err = manif_core.load_local_manifest(path.rocks_dir(tree))
***0	      if manifest then
***0	         any_ok = true
***0	         table.insert(trees, {tree=tree, manifest=manifest})
    	      end
    	   end
***0	   if not any_ok then
***0	      loader.rocks_trees = false
***0	      return false
    	   end
***0	   loader.rocks_trees = trees
***0	   return true
    	end
    	
    	--- Process the dependencies of a package to determine its dependency
    	-- chain for loading modules.
    	-- @param name string: The name of an installed rock.
    	-- @param version string: The version of the rock, in string format
***0	function loader.add_context(name, version)
    	   -- assert(type(name) == "string")
    	   -- assert(type(version) == "string")
    	
  27	   if loader.context[name] then
  20	      return
    	   end
   7	   loader.context[name] = version
    	
   7	   if not loader.rocks_trees and not load_rocks_trees() then
***0	      return nil
    	   end
    	
   9	   for _, tree in ipairs(loader.rocks_trees) do
   8	      local manifest = tree.manifest
    	
    	      local pkgdeps
   8	      if manifest.dependencies and manifest.dependencies[name] then
   2	         pkgdeps = manifest.dependencies[name][version]
    	      end
   8	      if not pkgdeps then
   6	         return nil
    	      end
   4	      for _, dep in ipairs(pkgdeps) do
   2	         local pkg, constraints = dep.name, dep.constraints
    	   
   6	         for _, tree in ipairs(loader.rocks_trees) do
   4	            local entries = tree.manifest.repository[pkg]
   4	            if entries then
***0	               for version, pkgs in pairs(entries) do
***0	                  if (not constraints) or deps.match_constraints(deps.parse_version(version), constraints) then
***0	                     loader.add_context(pkg, version)
    	                  end
    	               end
    	            end
    	         end
    	      end
    	   end
    	end
    	
    	--- Internal sorting function.
    	-- @param a table: A provider table.
    	-- @param b table: Another provider table.
    	-- @return boolean: True if the version of a is greater than that of b.
    	local function sort_versions(a,b)
   1	   return a.version > b.version
    	end
    	
    	--- Request module to be loaded through other loaders,
    	-- once the proper name of the module has been determined.
    	-- For example, in case the module "socket.core" has been requested
    	-- to the LuaRocks loader and it determined based on context that
    	-- the version 2.0.2 needs to be loaded and it is not the current
    	-- version, the module requested for the other loaders will be
    	-- "socket.core_2_0_2".
    	-- @param module The module name requested by the user, such as "socket.core"
    	-- @param name The rock name, such as "luasocket"
    	-- @param version The rock version, such as "2.0.2-1"
    	-- @param module_name The actual module name, such as "socket.core" or "socket.core_2_0_2".
    	-- @return table or (nil, string): The module table as returned by some other loader,
    	-- or nil followed by an error message if no other loader managed to load the module.
    	local function call_other_loaders(module, name, version, module_name)
 113	   for i, a_loader in ipairs(loaders) do
 113	      if a_loader ~= loader.luarocks_loader then
  86	         local results = { a_loader(module_name) }
  86	         if type(results[1]) == "function" then
  27	            return unpack(results)
    	         end
    	      end
    	   end
***0	   return "Failed loading module "..module.." in LuaRocks rock "..name.." "..version
    	end
    	
    	--- Search for a module in the rocks trees
    	-- @param module string: module name (eg. "socket.core")
    	-- @param filter_module_name function(string, string, string, string, number):
    	-- a function that takes the module name (eg "socket.core"), the rock name
    	-- (eg "luasocket"), the version (eg "2.0.2-1"), the path of the rocks tree
    	-- (eg "/usr/local"), and the numeric index of the matching entry, so the
    	-- filter function can know if the matching module was the first entry or not.
    	-- @return string, string, string, (string or table):
    	-- * name of the rock containing the module (eg. "luasocket")
    	-- * version of the rock (eg. "2.0.2-1")
    	-- * name of the module (eg. "socket.core", or "socket.core_2_0_2" if file is stored versioned).
    	-- * tree of the module (string or table in `rocks_trees` format)
    	local function select_module(module, filter_module_name)
    	   --assert(type(module) == "string")
    	   --assert(type(filter_module_name) == "function")
    	
  34	   if not loader.rocks_trees and not load_rocks_trees() then
***0	      return nil
    	   end
    	
  34	   local providers = {}
  75	   for _, tree in ipairs(loader.rocks_trees) do
  61	      local entries = tree.manifest.modules[module]
  61	      if entries then
  36	         for i, entry in ipairs(entries) do
  28	            local name, version = entry:match("^([^/]*)/(.*)$")
  28	            local module_name = tree.manifest.repository[name][version][1].modules[module]
  28	            if type(module_name) ~= "string" then
***0	               error("Invalid data in manifest file for module "..tostring(module).." (invalid data for "..tostring(name).." "..tostring(version)..")")
    	            end
  28	            module_name = filter_module_name(module_name, name, version, tree.tree, i)
  28	            if loader.context[name] == version then
  20	               return name, version, module_name
    	            end
   8	            version = deps.parse_version(version)
   8	            table.insert(providers, {name = name, version = version, module_name = module_name, tree = tree})
    	         end
    	      end
    	   end
    	
  14	   if next(providers) then
   7	      table.sort(providers, sort_versions)
   7	      local first = providers[1]
   7	      return first.name, first.version.string, first.module_name, first.tree
    	   end
    	end
    	
    	--- Search for a module
    	-- @param module string: module name (eg. "socket.core")
    	-- @return string, string, string, (string or table):
    	-- * name of the rock containing the module (eg. "luasocket")
    	-- * version of the rock (eg. "2.0.2-1")
    	-- * name of the module (eg. "socket.core", or "socket.core_2_0_2" if file is stored versioned).
    	-- * tree of the module (string or table in `rocks_trees` format)
    	local function pick_module(module)
***0	   return
  68	      select_module(module, function(module_name, name, version, tree, i)
  28	         if i > 1 then
***0	            module_name = path.versioned_name(module_name, "", name, version)
    	         end
  28	         module_name = path.path_to_module(module_name)
  28	         return module_name
    	      end)
    	end
    	
    	--- Return the pathname of the file that would be loaded for a module.
    	-- @param module string: module name (eg. "socket.core")
    	-- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
***0	function loader.which(module)
***0	   local name, version, module_name = select_module(module, path.which_i)
***0	   return module_name
    	end
    	
    	--- Package loader for LuaRocks support.
    	-- A module is searched in installed rocks that match the
    	-- current LuaRocks context. If module is not part of the
    	-- context, or if a context has not yet been set, the module
    	-- in the package with the highest version is used.
    	-- @param module string: The module name, like in plain require().
    	-- @return table: The module table (typically), like in plain
    	-- require(). See <a href="http://www.lua.org/manual/5.1/manual.html#pdf-require">require()</a>
    	-- in the Lua reference manual for details.
***0	function loader.luarocks_loader(module)
  34	   local name, version, module_name = pick_module(module)
  34	   if not name then
   7	      return "No LuaRocks module found for "..module
    	   else
  27	      loader.add_context(name, version)
  27	      return call_other_loaders(module, name, version, module_name)
    	   end
    	end
    	
***0	table.insert(loaders, 1, loader.luarocks_loader)
    	
***0	return loader

==============================================================================
/usr/local/share/lua/5.2/luarocks/path.lua
==============================================================================
    	
    	--- LuaRocks-specific path handling functions.
    	-- All paths are configured in this module, making it a single
    	-- point where the layout of the local installation is defined in LuaRocks.
    	--module("luarocks.path", package.seeall)
***0	local path = {}
    	
***0	local dir = require("luarocks.dir")
***0	local cfg = require("luarocks.cfg")
***0	local util = require("luarocks.util")
    	
    	--- Infer rockspec filename from a rock filename.
    	-- @param rock_name string: Pathname of a rock file.
    	-- @return string: Filename of the rockspec, without path.
***0	function path.rockspec_name_from_rock(rock_name)
***0	   assert(type(rock_name) == "string")
***0	   local base_name = dir.base_name(rock_name)
***0	   return base_name:match("(.*)%.[^.]*.rock") .. ".rockspec"
    	end
    	
***0	function path.rocks_dir(tree)
***0	   if type(tree) == "string" then
***0	      return dir.path(tree, cfg.rocks_subdir)
    	   else
***0	      assert(type(tree) == "table")
***0	      return tree.rocks_dir or dir.path(tree.root, cfg.rocks_subdir)
    	   end
    	end
    	
***0	function path.root_dir(rocks_dir)
***0	   assert(type(rocks_dir) == "string")
***0	   return rocks_dir:match("(.*)" .. util.matchquote(cfg.rocks_subdir) .. ".*$")
    	end
    	
***0	function path.rocks_tree_to_string(tree)
***0	   if type(tree) == "string" then
***0	      return tree
    	   else
***0	      assert(type(tree) == "table")
***0	      return tree.root
    	   end
    	end
    	
***0	function path.deploy_bin_dir(tree)
***0	   if type(tree) == "string" then
***0	      return dir.path(tree, "bin")
    	   else
***0	      assert(type(tree) == "table")
***0	      return tree.bin_dir or dir.path(tree.root, "bin")
    	   end
    	end
    	
***0	function path.deploy_lua_dir(tree)
***0	   if type(tree) == "string" then
***0	      return dir.path(tree, cfg.lua_modules_path)
    	   else
***0	      assert(type(tree) == "table")
***0	      return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)
    	   end
    	end
    	
***0	function path.deploy_lib_dir(tree)
***0	   if type(tree) == "string" then
***0	      return dir.path(tree, cfg.lib_modules_path)
    	   else
***0	      assert(type(tree) == "table")
***0	      return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)
    	   end
    	end
    	
***0	function path.manifest_file(tree)
***0	   if type(tree) == "string" then
***0	      return dir.path(tree, cfg.rocks_subdir, "manifest")
    	   else
***0	      assert(type(tree) == "table")
***0	      return (tree.rocks_dir and dir.path(tree.rocks_dir, "manifest")) or dir.path(tree.root, cfg.rocks_subdir, "manifest")
    	   end
    	end
    	
    	--- Get the directory for all versions of a package in a tree.
    	-- @param name string: The package name. 
    	-- @return string: The resulting path -- does not guarantee that
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- the package (and by extension, the path) exists.
***0	function path.versions_dir(name, tree)
***0	   assert(type(name) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name)
    	end
    	
    	--- Get the local installation directory (prefix) for a package.
    	-- @param name string: The package name. 
    	-- @param version string: The package version.
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- @return string: The resulting path -- does not guarantee that
    	-- the package (and by extension, the path) exists.
***0	function path.install_dir(name, version, tree)
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name, version)
    	end
    	
    	--- Get the local filename of the rockspec of an installed rock.
    	-- @param name string: The package name. 
    	-- @param version string: The package version.
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- @return string: The resulting path -- does not guarantee that
    	-- the package (and by extension, the file) exists.
***0	function path.rockspec_file(name, version, tree)
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name, version, name.."-"..version..".rockspec")
    	end
    	
    	--- Get the local filename of the rock_manifest file of an installed rock.
    	-- @param name string: The package name. 
    	-- @param version string: The package version.
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- @return string: The resulting path -- does not guarantee that
    	-- the package (and by extension, the file) exists.
***0	function path.rock_manifest_file(name, version, tree)
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name, version, "rock_manifest")
    	end
    	
    	--- Get the local installation directory for C libraries of a package.
    	-- @param name string: The package name. 
    	-- @param version string: The package version.
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- @return string: The resulting path -- does not guarantee that
    	-- the package (and by extension, the path) exists.
***0	function path.lib_dir(name, version, tree)
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name, version, "lib")
    	end
    	
    	--- Get the local installation directory for Lua modules of a package.
    	-- @param name string: The package name. 
    	-- @param version string: The package version.
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- @return string: The resulting path -- does not guarantee that
    	-- the package (and by extension, the path) exists.
***0	function path.lua_dir(name, version, tree)
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name, version, "lua")
    	end
    	
    	--- Get the local installation directory for documentation of a package.
    	-- @param name string: The package name. 
    	-- @param version string: The package version.
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- @return string: The resulting path -- does not guarantee that
    	-- the package (and by extension, the path) exists.
***0	function path.doc_dir(name, version, tree)
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name, version, "doc")
    	end
    	
    	--- Get the local installation directory for configuration files of a package.
    	-- @param name string: The package name. 
    	-- @param version string: The package version.
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- @return string: The resulting path -- does not guarantee that
    	-- the package (and by extension, the path) exists.
***0	function path.conf_dir(name, version, tree)
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name, version, "conf")
    	end
    	
    	--- Get the local installation directory for command-line scripts
    	-- of a package.
    	-- @param name string: The package name. 
    	-- @param version string: The package version.
    	-- @param tree string or nil: If given, specifies the local tree to use.
    	-- @return string: The resulting path -- does not guarantee that
    	-- the package (and by extension, the path) exists.
***0	function path.bin_dir(name, version, tree)
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   tree = tree or cfg.root_dir
***0	   return dir.path(path.rocks_dir(tree), name, version, "bin")
    	end
    	
    	--- Extract name, version and arch of a rock filename,
    	-- or name, version and "rockspec" from a rockspec name.
    	-- @param file_name string: pathname of a rock or rockspec
    	-- @return (string, string, string) or nil: name, version and arch
    	-- or nil if name could not be parsed
***0	function path.parse_name(file_name)
***0	   assert(type(file_name) == "string")
***0	   if file_name:match("%.rock$") then
***0	      return dir.base_name(file_name):match("(.*)-([^-]+-%d+)%.([^.]+)%.rock$")
    	   else
***0	      return dir.base_name(file_name):match("(.*)-([^-]+-%d+)%.(rockspec)")
    	   end
    	end
    	
    	--- Make a rockspec or rock URL.
    	-- @param pathname string: Base URL or pathname.
    	-- @param name string: Package name.
    	-- @param version string: Package version.
    	-- @param arch string: Architecture identifier, or "rockspec" or "installed".
    	-- @return string: A URL or pathname following LuaRocks naming conventions.
***0	function path.make_url(pathname, name, version, arch)
***0	   assert(type(pathname) == "string")
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
***0	   assert(type(arch) == "string")
    	
***0	   local filename = name.."-"..version
***0	   if arch == "installed" then
***0	      filename = dir.path(name, version, filename..".rockspec")
***0	   elseif arch == "rockspec" then
***0	      filename = filename..".rockspec"
    	   else
***0	      filename = filename.."."..arch..".rock"
    	   end
***0	   return dir.path(pathname, filename)
    	end
    	
    	--- Convert a pathname to a module identifier.
    	-- In Unix, for example, a path "foo/bar/baz.lua" is converted to
    	-- "foo.bar.baz"; "bla/init.lua" returns "bla"; "foo.so" returns "foo".
    	-- @param file string: Pathname of module
    	-- @return string: The module identifier, or nil if given path is
    	-- not a conformant module path (the function does not check if the
    	-- path actually exists).
***0	function path.path_to_module(file)
  28	   assert(type(file) == "string")
    	
  28	   local name = file:match("(.*)%."..cfg.lua_extension.."$")
  28	   if name then
  23	      name = name:gsub(dir.separator, ".")
  23	      local init = name:match("(.*)%.init$")
  23	      if init then
   2	         name = init
    	      end
    	   else
   5	      name = file:match("(.*)%."..cfg.lib_extension.."$")
   5	      if name then
   5	         name = name:gsub(dir.separator, ".")
    	      end
    	   end
  28	   if not name then name = file end
  28	   name = name:gsub("^%.+", ""):gsub("%.+$", "")
  28	   return name
    	end
    	
    	--- Obtain the directory name where a module should be stored.
    	-- For example, on Unix, "foo.bar.baz" will return "foo/bar".
    	-- @param mod string: A module name in Lua dot-separated format.
    	-- @return string: A directory name using the platform's separator.
***0	function path.module_to_path(mod)
***0	   assert(type(mod) == "string")
***0	   return (mod:gsub("[^.]*$", ""):gsub("%.", dir.separator))
    	end
    	
    	--- Set up path-related variables for a given rock.
    	-- Create a "variables" table in the rockspec table, containing
    	-- adjusted variables according to the configuration file.
    	-- @param rockspec table: The rockspec table.
***0	function path.configure_paths(rockspec)
***0	   assert(type(rockspec) == "table")
***0	   local vars = {}
***0	   for k,v in pairs(cfg.variables) do
***0	      vars[k] = v
    	   end
***0	   local name, version = rockspec.name, rockspec.version
***0	   vars.PREFIX = path.install_dir(name, version)
***0	   vars.LUADIR = path.lua_dir(name, version)
***0	   vars.LIBDIR = path.lib_dir(name, version)
***0	   vars.CONFDIR = path.conf_dir(name, version)
***0	   vars.BINDIR = path.bin_dir(name, version)
***0	   vars.DOCDIR = path.doc_dir(name, version)
***0	   rockspec.variables = vars
    	end
    	
    	--- Produce a versioned version of a filename.
    	-- @param file string: filename (must start with prefix)
    	-- @param prefix string: Path prefix for file
    	-- @param name string: Rock name
    	-- @param version string: Rock version
    	-- @return string: a pathname with the same directory parts and a versioned basename.
***0	function path.versioned_name(file, prefix, name, version)
***0	   assert(type(file) == "string")
***0	   assert(type(name) == "string")
***0	   assert(type(version) == "string")
    	
***0	   local rest = file:sub(#prefix+1):gsub("^/*", "")
***0	   local name_version = (name.."_"..version):gsub("%-", "_"):gsub("%.", "_")
***0	   return dir.path(prefix, name_version.."-"..rest)
    	end
    	
***0	function path.use_tree(tree)
***0	   cfg.root_dir = tree
***0	   cfg.rocks_dir = path.rocks_dir(tree)
***0	   cfg.deploy_bin_dir = path.deploy_bin_dir(tree)
***0	   cfg.deploy_lua_dir = path.deploy_lua_dir(tree)
***0	   cfg.deploy_lib_dir = path.deploy_lib_dir(tree)
    	end
    	
    	--- Apply a given function to the active rocks trees based on chosen dependency mode.
    	-- @param deps_mode string: Dependency mode: "one" for the current default tree,
    	-- "all" for all trees, "order" for all trees with priority >= the current default,
    	-- "none" for no trees (this function becomes a nop).
    	-- @param fn function: function to be applied, with the tree dir (string) as the first
    	-- argument and the remaining varargs of map_trees as the following arguments.
    	-- @return a table with all results of invocations of fn collected.
***0	function path.map_trees(deps_mode, fn, ...)
***0	   local result = {}
***0	   if deps_mode == "one" then
***0	      table.insert(result, (fn(cfg.root_dir, ...)) or 0)
***0	   elseif deps_mode == "all" or deps_mode == "order" then
***0	      local use = false
***0	      if deps_mode == "all" then
***0	         use = true
    	      end
***0	      for _, tree in ipairs(cfg.rocks_trees) do
***0	         if dir.normalize(path.rocks_tree_to_string(tree)) == dir.normalize(path.rocks_tree_to_string(cfg.root_dir)) then
***0	            use = true
    	         end
***0	         if use then
***0	            table.insert(result, (fn(tree, ...)) or 0)
    	         end
    	      end
    	   end
***0	   return result
    	end
    	
***0	local is_src_extension = { [".lua"] = true, [".tl"] = true, [".tld"] = true, [".moon"] = true }
    	
    	--- Return the pathname of the file that would be loaded for a module, indexed.
    	-- @param module_name string: module name (eg. "socket.core")
    	-- @param name string: name of the package (eg. "luasocket")
    	-- @param version string: version number (eg. "2.0.2-1")
    	-- @param tree string: repository path (eg. "/usr/local")
    	-- @param i number: the index, 1 if version is the current default, > 1 otherwise.
    	-- This is done this way for use by select_module in luarocks.loader.
    	-- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
***0	function path.which_i(module_name, name, version, tree, i)
    	   local deploy_dir
***0	   local extension = module_name:match("%.[a-z]+$")
***0	   if is_src_extension[extension] then
***0	      deploy_dir = path.deploy_lua_dir(tree)
***0	      module_name = dir.path(deploy_dir, module_name)
    	   else
***0	      deploy_dir = path.deploy_lib_dir(tree)
***0	      module_name = dir.path(deploy_dir, module_name)
    	   end
***0	   if i > 1 then
***0	      module_name = path.versioned_name(module_name, deploy_dir, name, version)
    	   end
***0	   return module_name
    	end
    	
    	--- Return the pathname of the file that would be loaded for a module, 
    	-- returning the versioned pathname if given version is not the default version
    	-- in the given manifest.
    	-- @param module_name string: module name (eg. "socket.core")
    	-- @param name string: name of the package (eg. "luasocket")
    	-- @param version string: version number (eg. "2.0.2-1")
    	-- @param tree string: repository path (eg. "/usr/local")
    	-- @param manifest table: the manifest table for the tree.
    	-- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
***0	function path.which(module_name, filename, name, version, tree, manifest)
***0	   local versions = manifest.modules[module_name]
***0	   assert(versions)
***0	   for i, name_version in ipairs(versions) do
***0	      if name_version == name.."/"..version then
***0	         return path.which_i(filename, name, version, tree, i):gsub("//", "/")
    	      end
    	   end
***0	   assert(false)
    	end
    	
***0	return path

==============================================================================
/usr/local/share/lua/5.2/luassert/assert.lua
==============================================================================
***0	local s = require 'say'
***0	local astate = require 'luassert.state'
***0	local util = require 'luassert.util'
***0	local unpack = require 'luassert.compatibility'.unpack
    	local obj   -- the returned module table
    	
    	-- list of namespaces
***0	local namespace = require 'luassert.namespaces'
    	
    	local function geterror(assertion_message, failure_message, args)
***0	  if util.hastostring(failure_message) then
***0	    failure_message = tostring(failure_message)
***0	  elseif failure_message ~= nil then
***0	    failure_message = astate.format_argument(failure_message)
    	  end
***0	  local message = s(assertion_message, obj:format(args))
***0	  if message and failure_message then
***0	    message = failure_message .. "\n" .. message
    	  end
***0	  return message or failure_message
    	end
    	
***0	local __state_meta = {
    	
    	  __call = function(self, ...)
  13	    local keys = util.extract_keys("assertion", self.tokens)
  13	    self.tokens = {}
    	
    	    local assertion
    	
  37	    for _, key in ipairs(keys) do
  24	      assertion = namespace.assertion[key] or assertion
    	    end
    	
  13	    if assertion then
  37	      for _, key in ipairs(keys) do
  24	        if namespace.modifier[key] then
  11	          namespace.modifier[key].callback(self)
    	        end
    	      end
    	
  13	      local arguments = {...}
  13	      arguments.n = select('#', ...) -- add argument count for trailing nils
  13	      local val, retargs = assertion.callback(self, arguments, util.errorlevel())
    	
  13	      if not val == self.mod then
***0	        local message = assertion.positive_message
***0	        if not self.mod then
***0	          message = assertion.negative_message
    	        end
***0	        local err = geterror(message, rawget(self,"failure_message"), arguments)
***0	        error(err or "assertion failed!", util.errorlevel())
    	      end
    	
  13	      if retargs then
***0	        return unpack(retargs)
    	      end
  13	      return ...
    	    else
***0	      local arguments = {...}
***0	      arguments.n = select('#', ...)
    	
***0	      for _, key in ipairs(keys) do
***0	        if namespace.modifier[key] then
***0	          namespace.modifier[key].callback(self, arguments, util.errorlevel())
    	        end
    	      end
    	    end
    	
***0	    return self
    	  end,
    	
    	  __index = function(self, key)
  48	    for token in key:lower():gmatch('[^_]+') do
  24	      table.insert(self.tokens, token)
    	    end
    	
  24	    return self
    	  end
    	}
    	
***0	obj = {
  13	  state = function() return setmetatable({mod=true, tokens={}}, __state_meta) end,
    	
    	  -- registers a function in namespace
    	  register = function(self, nspace, name, callback, positive_message, negative_message)
***0	    local lowername = name:lower()
***0	    if not namespace[nspace] then
***0	      namespace[nspace] = {}
    	    end
***0	    namespace[nspace][lowername] = {
    	      callback = callback,
    	      name = lowername,
    	      positive_message=positive_message,
***0	      negative_message=negative_message
    	    }
    	  end,
    	
    	  -- unregisters a function in a namespace
    	  unregister = function(self, nspace, name)
***0	    local lowername = name:lower()
***0	    if not namespace[nspace] then
***0	      namespace[nspace] = {}
    	    end
***0	    namespace[nspace][lowername] = nil
    	  end,
    	
    	  -- registers a formatter
    	  -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument
    	  add_formatter = function(self, callback)
***0	    astate.add_formatter(callback)
    	  end,
    	
    	  -- unregisters a formatter
    	  remove_formatter = function(self, fmtr)
***0	    astate.remove_formatter(fmtr)
    	  end,
    	
    	  format = function(self, args)
    	    -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost
***0	    local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted
***0	    local fmtargs = args.fmtargs or {} -- additional arguments to be passed to formatter
***0	    for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils
***0	      if not nofmt[i] then
***0	        local val = args[i]
***0	        local valfmt = astate.format_argument(val, nil, fmtargs[i])
***0	        if valfmt == nil then valfmt = tostring(val) end -- no formatter found
***0	        args[i] = valfmt
    	      end
    	    end
***0	    return args
    	  end,
    	
    	  set_parameter = function(self, name, value)
***0	    astate.set_parameter(name, value)
    	  end,
    	  
    	  get_parameter = function(self, name)
***0	    return astate.get_parameter(name)
    	  end,  
    	  
    	  add_spy = function(self, spy)
***0	    astate.add_spy(spy)
    	  end,
    	  
    	  snapshot = function(self)
***0	    return astate.snapshot()
    	  end,
    	}
    	
***0	local __meta = {
    	
    	  __call = function(self, bool, message, level, ...)
  10	    if not bool then
***0	      local level = (level or 1) + 1
***0	      error(message or "assertion failed!", level)
    	    end
  10	    return bool , message , level , ...
    	  end,
    	
    	  __index = function(self, key)
  13	    return rawget(self, key) or self.state()[key]
    	  end,
    	
    	}
    	
***0	return setmetatable(obj, __meta)

==============================================================================
/usr/local/share/lua/5.2/luassert/assertions.lua
==============================================================================
    	-- module will not return anything, only register assertions with the main assert engine
    	
    	-- assertions take 2 parameters;
    	-- 1) state
    	-- 2) arguments list. The list has a member 'n' with the argument count to check for trailing nils
    	-- 3) level The level of the error position relative to the called function
    	-- returns; boolean; whether assertion passed
    	
***0	local assert = require('luassert.assert')
***0	local astate = require ('luassert.state')
***0	local util = require ('luassert.util')
***0	local s = require('say')
    	
    	local function format(val)
***0	  return astate.format_argument(val) or tostring(val)
    	end
    	
    	local function set_failure_message(state, message)
  13	  if message ~= nil then
***0	    state.failure_message = message
    	  end
    	end
    	
    	local function unique(state, arguments, level)
***0	  local list = arguments[1]
    	  local deep
***0	  local argcnt = arguments.n
***0	  if type(arguments[2]) == "boolean" or (arguments[2] == nil and argcnt > 2) then
***0	    deep = arguments[2]
***0	    set_failure_message(state, arguments[3])
    	  else
***0	    if type(arguments[3]) == "boolean" then
***0	      deep = arguments[3]
    	    end
***0	    set_failure_message(state, arguments[2])
    	  end
***0	  for k,v in pairs(list) do
***0	    for k2, v2 in pairs(list) do
***0	      if k ~= k2 then
***0	        if deep and util.deepcompare(v, v2, true) then
***0	          return false
    	        else
***0	          if v == v2 then
***0	            return false
    	          end
    	        end
    	      end
    	    end
    	  end
***0	  return true
    	end
    	
    	local function near(state, arguments, level)
***0	  local level = (level or 1) + 1
***0	  local argcnt = arguments.n
***0	  assert(argcnt > 2, s("assertion.internal.argtolittle", { "near", 3, tostring(argcnt) }), level)
***0	  local expected = tonumber(arguments[1])
***0	  local actual = tonumber(arguments[2])
***0	  local tolerance = tonumber(arguments[3])
***0	  local numbertype = "number or object convertible to a number"
***0	  assert(expected, s("assertion.internal.badargtype", { 1, "near", numbertype, format(arguments[1]) }), level)
***0	  assert(actual, s("assertion.internal.badargtype", { 2, "near", numbertype, format(arguments[2]) }), level)
***0	  assert(tolerance, s("assertion.internal.badargtype", { 3, "near", numbertype, format(arguments[3]) }), level)
    	  -- switch arguments for proper output message
***0	  util.tinsert(arguments, 1, util.tremove(arguments, 2))
***0	  arguments[3] = tolerance
***0	  arguments.nofmt = arguments.nofmt or {}
***0	  arguments.nofmt[3] = true
***0	  set_failure_message(state, arguments[4])
***0	  return (actual >= expected - tolerance and actual <= expected + tolerance)
    	end
    	
    	local function matches(state, arguments, level)
***0	  local level = (level or 1) + 1
***0	  local argcnt = arguments.n
***0	  assert(argcnt > 1, s("assertion.internal.argtolittle", { "matches", 2, tostring(argcnt) }), level)
***0	  local pattern = arguments[1]
    	  local actual = nil
***0	  if util.hastostring(arguments[2]) or type(arguments[2]) == "number" then
***0	    actual = tostring(arguments[2])
    	  end
    	  local err_message
***0	  local init_arg_num = 3
***0	  for i=3,argcnt,1 do
***0	    if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
***0	      if i == 3 then init_arg_num = init_arg_num + 1 end
***0	      err_message = util.tremove(arguments, i)
    	      break
    	    end
    	  end
***0	  local init = arguments[3]
***0	  local plain = arguments[4]
***0	  local stringtype = "string or object convertible to a string"
***0	  assert(type(pattern) == "string", s("assertion.internal.badargtype", { 1, "matches", "string", type(arguments[1]) }), level)
***0	  assert(actual, s("assertion.internal.badargtype", { 2, "matches", stringtype, format(arguments[2]) }), level)
***0	  assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)
    	  -- switch arguments for proper output message
***0	  util.tinsert(arguments, 1, util.tremove(arguments, 2))
***0	  set_failure_message(state, err_message)
    	  local retargs
    	  local ok
***0	  if plain then
***0	    ok = (actual:find(pattern, init, plain) ~= nil)
***0	    retargs = ok and { pattern } or {}
    	  else
***0	    retargs = { actual:match(pattern, init) }
***0	    ok = (retargs[1] ~= nil)
    	  end
***0	  return ok, retargs
    	end
    	
    	local function equals(state, arguments, level)
  10	  local level = (level or 1) + 1
  10	  local argcnt = arguments.n
  10	  assert(argcnt > 1, s("assertion.internal.argtolittle", { "equals", 2, tostring(argcnt) }), level)
  10	  local result =  arguments[1] == arguments[2]
    	  -- switch arguments for proper output message
  10	  util.tinsert(arguments, 1, util.tremove(arguments, 2))
  10	  set_failure_message(state, arguments[3])
  10	  return result
    	end
    	
    	local function same(state, arguments, level)
***0	  local level = (level or 1) + 1
***0	  local argcnt = arguments.n
***0	  assert(argcnt > 1, s("assertion.internal.argtolittle", { "same", 2, tostring(argcnt) }), level)
***0	  if type(arguments[1]) == 'table' and type(arguments[2]) == 'table' then
***0	    local result, crumbs = util.deepcompare(arguments[1], arguments[2], true)
    	    -- switch arguments for proper output message
***0	    util.tinsert(arguments, 1, util.tremove(arguments, 2))
***0	    arguments.fmtargs = arguments.fmtargs or {}
***0	    arguments.fmtargs[1] = { crumbs = crumbs }
***0	    arguments.fmtargs[2] = { crumbs = crumbs }
***0	    set_failure_message(state, arguments[3])
***0	    return result
    	  end
***0	  local result = arguments[1] == arguments[2]
    	  -- switch arguments for proper output message
***0	  util.tinsert(arguments, 1, util.tremove(arguments, 2))
***0	  set_failure_message(state, arguments[3])
***0	  return result
    	end
    	
    	local function truthy(state, arguments, level)
   3	  set_failure_message(state, arguments[2])
   3	  return arguments[1] ~= false and arguments[1] ~= nil
    	end
    	
    	local function falsy(state, arguments, level)
   1	  return not truthy(state, arguments, level)
    	end
    	
    	local function has_error(state, arguments, level)
***0	  local level = (level or 1) + 1
***0	  local retargs = util.shallowcopy(arguments)
***0	  local func = arguments[1]
***0	  local err_expected = arguments[2]
***0	  local failure_message = arguments[3]
***0	  assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error", "function or callable object", type(func) }), level)
***0	  local ok, err_actual = pcall(func)
***0	  if type(err_actual) == 'string' then
    	    -- remove 'path/to/file:line: ' from string
***0	    err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
    	  end
***0	  retargs[1] = err_actual
***0	  arguments.nofmt = {}
***0	  arguments.n = 2
***0	  arguments[1] = (ok and '(no error)' or err_actual)
***0	  arguments[2] = (err_expected == nil and '(error)' or err_expected)
***0	  arguments.nofmt[1] = ok
***0	  arguments.nofmt[2] = (err_expected == nil)
***0	  set_failure_message(state, failure_message)
    	
***0	  if ok or err_expected == nil then
***0	    return not ok, retargs
    	  end
***0	  if type(err_expected) == 'string' then
    	    -- err_actual must be (convertible to) a string
***0	    if util.hastostring(err_actual) then
***0	      err_actual = tostring(err_actual)
***0	      retargs[1] = err_actual
    	    end
***0	    if type(err_actual) == 'string' then
***0	      return err_expected == err_actual, retargs
    	    end
***0	  elseif type(err_expected) == 'number' then
***0	    if type(err_actual) == 'string' then
***0	      return tostring(err_expected) == tostring(tonumber(err_actual)), retargs
    	    end
    	  end
***0	  return same(state, {err_expected, err_actual, ["n"] = 2}), retargs
    	end
    	
    	local function error_matches(state, arguments, level)
***0	  local level = (level or 1) + 1
***0	  local retargs = util.shallowcopy(arguments)
***0	  local argcnt = arguments.n
***0	  local func = arguments[1]
***0	  local pattern = arguments[2]
***0	  assert(argcnt > 1, s("assertion.internal.argtolittle", { "error_matches", 2, tostring(argcnt) }), level)
***0	  assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error_matches", "function or callable object", type(func) }), level)
***0	  assert(pattern == nil or type(pattern) == "string", s("assertion.internal.badargtype", { 2, "error", "string", type(pattern) }), level)
    	
    	  local failure_message
***0	  local init_arg_num = 3
***0	  for i=3,argcnt,1 do
***0	    if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
***0	      if i == 3 then init_arg_num = init_arg_num + 1 end
***0	      failure_message = util.tremove(arguments, i)
    	      break
    	    end
    	  end
***0	  local init = arguments[3]
***0	  local plain = arguments[4]
***0	  assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)
    	
***0	  local ok, err_actual = pcall(func)
***0	  if type(err_actual) == 'string' then
    	    -- remove 'path/to/file:line: ' from string
***0	    err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
    	  end
***0	  retargs[1] = err_actual
***0	  arguments.nofmt = {}
***0	  arguments.n = 2
***0	  arguments[1] = (ok and '(no error)' or err_actual)
***0	  arguments[2] = pattern
***0	  arguments.nofmt[1] = ok
***0	  arguments.nofmt[2] = false
***0	  set_failure_message(state, failure_message)
    	
***0	  if ok then return not ok, retargs end
***0	  if err_actual == nil and pattern == nil then
***0	    return true, {}
    	  end
    	
    	  -- err_actual must be (convertible to) a string
***0	  if util.hastostring(err_actual) then
***0	    err_actual = tostring(err_actual)
***0	    retargs[1] = err_actual
    	  end
***0	  if type(err_actual) == 'string' then
    	    local ok
    	    local retargs_ok
***0	    if plain then
***0	      retargs_ok = { pattern }
***0	      ok = (err_actual:find(pattern, init, plain) ~= nil)
    	    else
***0	      retargs_ok = { err_actual:match(pattern, init) }
***0	      ok = (retargs_ok[1] ~= nil)
    	    end
***0	    if ok then retargs = retargs_ok end
***0	    return ok, retargs
    	  end
    	
***0	  return false, retargs
    	end
    	
    	local function is_true(state, arguments, level)
***0	  util.tinsert(arguments, 2, true)
***0	  set_failure_message(state, arguments[3])
***0	  return arguments[1] == arguments[2]
    	end
    	
    	local function is_false(state, arguments, level)
***0	  util.tinsert(arguments, 2, false)
***0	  set_failure_message(state, arguments[3])
***0	  return arguments[1] == arguments[2]
    	end
    	
    	local function is_type(state, arguments, level, etype)
***0	  util.tinsert(arguments, 2, "type " .. etype)
***0	  arguments.nofmt = arguments.nofmt or {}
***0	  arguments.nofmt[2] = true
***0	  set_failure_message(state, arguments[3])
***0	  return arguments.n > 1 and type(arguments[1]) == etype
    	end
    	
    	local function returned_arguments(state, arguments, level)
***0	  arguments[1] = tostring(arguments[1])
***0	  arguments[2] = tostring(arguments.n - 1)
***0	  arguments.nofmt = arguments.nofmt or {}
***0	  arguments.nofmt[1] = true
***0	  arguments.nofmt[2] = true
***0	  if arguments.n < 2 then arguments.n = 2 end
***0	  return arguments[1] == arguments[2]
    	end
    	
    	local function set_message(state, arguments, level)
***0	  state.failure_message = arguments[1]
    	end
    	
***0	local function is_boolean(state, arguments, level)  return is_type(state, arguments, level, "boolean")  end
***0	local function is_number(state, arguments, level)   return is_type(state, arguments, level, "number")   end
***0	local function is_string(state, arguments, level)   return is_type(state, arguments, level, "string")   end
***0	local function is_table(state, arguments, level)    return is_type(state, arguments, level, "table")    end
***0	local function is_nil(state, arguments, level)      return is_type(state, arguments, level, "nil")      end
***0	local function is_userdata(state, arguments, level) return is_type(state, arguments, level, "userdata") end
***0	local function is_function(state, arguments, level) return is_type(state, arguments, level, "function") end
***0	local function is_thread(state, arguments, level)   return is_type(state, arguments, level, "thread")   end
    	
***0	assert:register("modifier", "message", set_message)
***0	assert:register("assertion", "true", is_true, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "false", is_false, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "boolean", is_boolean, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "number", is_number, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "string", is_string, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "table", is_table, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "nil", is_nil, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "userdata", is_userdata, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "function", is_function, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "thread", is_thread, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "returned_arguments", returned_arguments, "assertion.returned_arguments.positive", "assertion.returned_arguments.negative")
    	
***0	assert:register("assertion", "same", same, "assertion.same.positive", "assertion.same.negative")
***0	assert:register("assertion", "matches", matches, "assertion.matches.positive", "assertion.matches.negative")
***0	assert:register("assertion", "match", matches, "assertion.matches.positive", "assertion.matches.negative")
***0	assert:register("assertion", "near", near, "assertion.near.positive", "assertion.near.negative")
***0	assert:register("assertion", "equals", equals, "assertion.equals.positive", "assertion.equals.negative")
***0	assert:register("assertion", "equal", equals, "assertion.equals.positive", "assertion.equals.negative")
***0	assert:register("assertion", "unique", unique, "assertion.unique.positive", "assertion.unique.negative")
***0	assert:register("assertion", "error", has_error, "assertion.error.positive", "assertion.error.negative")
***0	assert:register("assertion", "errors", has_error, "assertion.error.positive", "assertion.error.negative")
***0	assert:register("assertion", "error_matches", error_matches, "assertion.error.positive", "assertion.error.negative")
***0	assert:register("assertion", "error_match", error_matches, "assertion.error.positive", "assertion.error.negative")
***0	assert:register("assertion", "matches_error", error_matches, "assertion.error.positive", "assertion.error.negative")
***0	assert:register("assertion", "match_error", error_matches, "assertion.error.positive", "assertion.error.negative")
***0	assert:register("assertion", "truthy", truthy, "assertion.truthy.positive", "assertion.truthy.negative")
***0	assert:register("assertion", "falsy", falsy, "assertion.falsy.positive", "assertion.falsy.negative")

==============================================================================
/usr/local/share/lua/5.2/luassert/modifiers.lua
==============================================================================
    	-- module will not return anything, only register assertions/modifiers with the main assert engine
***0	local assert = require('luassert.assert')
    	
    	local function is(state)
  11	  return state
    	end
    	
    	local function is_not(state)
***0	  state.mod = not state.mod
***0	  return state
    	end
    	
***0	assert:register("modifier", "is", is)
***0	assert:register("modifier", "are", is)
***0	assert:register("modifier", "was", is)
***0	assert:register("modifier", "has", is)
***0	assert:register("modifier", "does", is)
***0	assert:register("modifier", "not", is_not)
***0	assert:register("modifier", "no", is_not)

==============================================================================
/usr/local/share/lua/5.2/luassert/util.lua
==============================================================================
***0	local util = {}
***0	function util.deepcompare(t1,t2,ignore_mt,cycles,thresh1,thresh2)
***0	  local ty1 = type(t1)
***0	  local ty2 = type(t2)
    	  -- non-table types can be directly compared
***0	  if ty1 ~= 'table' or ty2 ~= 'table' then return t1 == t2 end
***0	  local mt1 = debug.getmetatable(t1)
***0	  local mt2 = debug.getmetatable(t2)
    	  -- would equality be determined by metatable __eq?
***0	  if mt1 and mt1 == mt2 and mt1.__eq then
    	    -- then use that unless asked not to
***0	    if not ignore_mt then return t1 == t2 end
    	  else -- we can skip the deep comparison below if t1 and t2 share identity
***0	    if rawequal(t1, t2) then return true end
    	  end
    	
    	  -- handle recursive tables
***0	  cycles = cycles or {{},{}}
***0	  thresh1, thresh2 = (thresh1 or 1), (thresh2 or 1)
***0	  cycles[1][t1] = (cycles[1][t1] or 0)
***0	  cycles[2][t2] = (cycles[2][t2] or 0)
***0	  if cycles[1][t1] == 1 or cycles[2][t2] == 1 then
***0	    thresh1 = cycles[1][t1] + 1
***0	    thresh2 = cycles[2][t2] + 1
    	  end
***0	  if cycles[1][t1] > thresh1 and cycles[2][t2] > thresh2 then
***0	    return true
    	  end
    	
***0	  cycles[1][t1] = cycles[1][t1] + 1
***0	  cycles[2][t2] = cycles[2][t2] + 1
    	
***0	  for k1,v1 in next, t1 do
***0	    local v2 = t2[k1]
***0	    if v2 == nil then
***0	      return false, {k1}
    	    end
    	
***0	    local same, crumbs = util.deepcompare(v1,v2,nil,cycles,thresh1,thresh2)
***0	    if not same then
***0	      crumbs = crumbs or {}
***0	      table.insert(crumbs, k1)
***0	      return false, crumbs
    	    end
    	  end
***0	  for k2,_ in next, t2 do
    	    -- only check wether each element has a t1 counterpart, actual comparison
    	    -- has been done in first loop above
***0	    if t1[k2] == nil then return false, {k2} end
    	  end
    	
***0	  cycles[1][t1] = cycles[1][t1] - 1
***0	  cycles[2][t2] = cycles[2][t2] - 1
    	
***0	  return true
    	end
    	
***0	function util.shallowcopy(t)
***0	  if type(t) ~= "table" then return t end
***0	  local copy = {}
***0	  for k,v in next, t do
***0	    copy[k] = v
    	  end
***0	  return copy
    	end
    	
***0	function util.deepcopy(t, deepmt, cache)
***0	  local spy = require 'luassert.spy'
***0	  if type(t) ~= "table" then return t end
***0	  local copy = {}
    	
    	  -- handle recursive tables
***0	  local cache = cache or {}
***0	  if cache[t] then return cache[t] end
***0	  cache[t] = copy
    	
***0	  for k,v in next, t do
***0	    copy[k] = (spy.is_spy(v) and v or util.deepcopy(v, deepmt, cache))
    	  end
***0	  if deepmt then
***0	    debug.setmetatable(copy, util.deepcopy(debug.getmetatable(t, nil, cache)))
    	  else
***0	    debug.setmetatable(copy, debug.getmetatable(t))
    	  end
***0	  return copy
    	end
    	
    	-----------------------------------------------
    	-- Copies arguments as a list of arguments
    	-- @param args the arguments of which to copy
    	-- @return the copy of the arguments
***0	function util.copyargs(args)
***0	  local copy = {}
***0	  local match = require 'luassert.match'
***0	  local spy = require 'luassert.spy'
***0	  for k,v in pairs(args) do
***0	    copy[k] = ((match.is_matcher(v) or spy.is_spy(v)) and v or util.deepcopy(v))
    	  end
***0	  return { vals = copy, refs = util.shallowcopy(args) }
    	end
    	
    	-----------------------------------------------
    	-- Finds matching arguments in a saved list of arguments
    	-- @param argslist list of arguments from which to search
    	-- @param args the arguments of which to find a match
    	-- @return the matching arguments if a match is found, otherwise nil
***0	function util.matchargs(argslist, args)
    	  local function matches(t1, t2, t1refs)
***0	    local match = require 'luassert.match'
***0	    for k1,v1 in pairs(t1) do
***0	      local v2 = t2[k1]
***0	      if match.is_matcher(v1) then
***0	        if not v1(v2) then return false end
***0	      elseif match.is_matcher(v2) then
***0	        if match.is_ref_matcher(v2) then v1 = t1refs[k1] end
***0	        if not v2(v1) then return false end
***0	      elseif (v2 == nil or not util.deepcompare(v1,v2)) then
***0	        return false
    	      end
    	    end
***0	    for k2,v2 in pairs(t2) do
    	      -- only check wether each element has a t1 counterpart, actual comparison
    	      -- has been done in first loop above
***0	      local v1 = t1[k2]
***0	      if v1 == nil then
    	        -- no t1 counterpart, so try to compare using matcher
***0	        if match.is_matcher(v2) then
***0	          if not v2(v1) then return false end
    	        else
***0	          return false
    	        end
    	      end
    	    end
***0	    return true
    	  end
***0	  for k,v in ipairs(argslist) do
***0	    if matches(v.vals, args, v.refs) then
***0	      return v
    	    end
    	  end
***0	  return nil
    	end
    	
    	-----------------------------------------------
    	-- table.insert() replacement that respects nil values.
    	-- The function will use table field 'n' as indicator of the
    	-- table length, if not set, it will be added.
    	-- @param t table into which to insert
    	-- @param pos (optional) position in table where to insert. NOTE: not optional if you want to insert a nil-value!
    	-- @param val value to insert
    	-- @return No return values
***0	function util.tinsert(...)
    	  -- check optional POS value
  10	  local args = {...}
  10	  local c = select('#',...)
  10	  local t = args[1]
  10	  local pos = args[2]
  10	  local val = args[3]
  10	  if c < 3 then
***0	    val = pos
***0	    pos = nil
    	  end
    	  -- set length indicator n if not present (+1)
  10	  t.n = (t.n or #t) + 1
  10	  if not pos then
***0	    pos = t.n
  10	  elseif pos > t.n then
    	    -- out of our range
***0	    t[pos] = val
***0	    t.n = pos
    	  end
    	  -- shift everything up 1 pos
  20	  for i = t.n, pos + 1, -1 do
  10	    t[i]=t[i-1]
    	  end
    	  -- add element to be inserted
  10	  t[pos] = val
    	end
    	-----------------------------------------------
    	-- table.remove() replacement that respects nil values.
    	-- The function will use table field 'n' as indicator of the
    	-- table length, if not set, it will be added.
    	-- @param t table from which to remove
    	-- @param pos (optional) position in table to remove
    	-- @return No return values
***0	function util.tremove(t, pos)
    	  -- set length indicator n if not present (+1)
  10	  t.n = t.n or #t
  10	  if not pos then
***0	    pos = t.n
  10	  elseif pos > t.n then
***0	    local removed = t[pos]
    	    -- out of our range
***0	    t[pos] = nil
***0	    return removed
    	  end
  10	  local removed = t[pos]
    	  -- shift everything up 1 pos
  20	  for i = pos, t.n do
  10	    t[i]=t[i+1]
    	  end
    	  -- set size, clean last
  10	  t[t.n] = nil
  10	  t.n = t.n - 1
  10	  return removed
    	end
    	
    	-----------------------------------------------
    	-- Checks an element to be callable.
    	-- The type must either be a function or have a metatable
    	-- containing an '__call' function.
    	-- @param object element to inspect on being callable or not
    	-- @return boolean, true if the object is callable
***0	function util.callable(object)
***0	  return type(object) == "function" or type((debug.getmetatable(object) or {}).__call) == "function"
    	end
    	-----------------------------------------------
    	-- Checks an element has tostring.
    	-- The type must either be a string or have a metatable
    	-- containing an '__tostring' function.
    	-- @param object element to inspect on having tostring or not
    	-- @return boolean, true if the object has tostring
***0	function util.hastostring(object)
***0	  return type(object) == "string" or type((debug.getmetatable(object) or {}).__tostring) == "function"
    	end
    	
    	-----------------------------------------------
    	-- Find the first level, not defined in the same file as the caller's
    	-- code file to properly report an error.
    	-- @param level the level to use as the caller's source file
    	-- @return number, the level of which to report an error
***0	function util.errorlevel(level)
  13	  local level = (level or 1) + 1 -- add one to get level of the caller
  13	  local info = debug.getinfo(level)
  13	  local source = (info or {}).source
  13	  local file = source
  26	  while file and (file == source or source == "=(tail call)") do
  13	    level = level + 1
  13	    info = debug.getinfo(level)
  13	    source = (info or {}).source
    	  end
  13	  if level > 1 then level = level - 1 end -- deduct call to errorlevel() itself
  13	  return level
    	end
    	
    	-----------------------------------------------
    	-- Extract modifier and namespace keys from list of tokens.
    	-- @param nspace the namespace from which to match tokens
    	-- @param tokens list of tokens to search for keys
    	-- @return table, list of keys that were extracted
***0	function util.extract_keys(nspace, tokens)
  13	  local namespace = require 'luassert.namespaces'
    	
    	  -- find valid keys by coalescing tokens as needed, starting from the end
  13	  local keys = {}
  13	  local key = nil
  13	  local i = #tokens
  37	  while i > 0 do
  24	    local token = tokens[i]
  24	    key = key and (token .. '_' .. key) or token
    	
    	    -- find longest matching key in the given namespace
  24	    local longkey = i > 1 and (tokens[i-1] .. '_' .. key) or nil
  24	    while i > 1 and longkey and namespace[nspace][longkey] do
***0	      key = longkey
***0	      i = i - 1
***0	      token = tokens[i]
***0	      longkey = (token .. '_' .. key)
    	    end
    	
  24	    if namespace.modifier[key] or namespace[nspace][key] then
  24	      table.insert(keys, 1, key)
  24	      key = nil
    	    end
  24	    i = i - 1
    	  end
    	
    	  -- if there's anything left we didn't recognize it
  13	  if key then
***0	    error("luassert: unknown modifier/" .. nspace .. ": '" .. key .."'", util.errorlevel(2))
    	  end
    	
  13	  return keys
    	end
    	
***0	return util

==============================================================================
/usr/local/share/lua/5.2/lub/Autoload.lua
==============================================================================
    	--[[------------------------------------------------------
    	
    	  # Autoload
    	
    	  This class creates a module table that will automatically call require to
    	  find new keys. This enables "load as needed" code. If the required code
    	  cannot be found, generates an error.
    	  
    	--]]------------------------------------------------------
   1	local lub  = require 'lub'
   1	local lib  = lub.class 'lub.Autoload'
   1	local lib2 = {}
   1	local private = {}
    	
    	-- Declare a new table with autoloading feature. The `prefix` should reflect
    	-- the path used to call require for missing elements. If the optional `tbl`
    	-- is provided, this table will be used as starting content.
   1	function lib.new(prefix, tbl)
   2	  assert(prefix, 'Missing prefix in Autoload call.')
   2	  local self = tbl or {}
   2	  self.type = prefix
   2	  return setmetatable(self, lib)
    	end
    	
    	-- nodoc
   1	function lib.__index(table, name)
    	  -- Trying to load new lib like foo.Bar
   2	  local ok, new_lib_or_error = pcall(function() return require(table.type..'.'..name); end)
   1	  if ok then
    	    -- insert new class with name in table
   1	    table[name] = new_lib_or_error
   1	    return new_lib_or_error
    	  else
***0	    print(new_lib_or_error)
***0	    return nil
    	  end
    	end
    	
    	-- # Global
    	-- You can enable autoload on the global namespace `_G` to require modules.
    	--   
    	-- WARN: You should not disable #strict or `nil` values in global namespace will
    	-- have a *huge* overhead (try to require code on every access).
    	
    	
    	-- Activate autoloading for global environment `_G` (this method is slightly
    	-- different then #new and adapted for the global environment). By default,
    	-- this uses #strict (forbids using global nil values).
   1	function lib.global()
***0	  setmetatable(_G, lib2)
    	end
    	
    	-- This can be used to disable strict mode when autoload is enabled for global
    	-- environment.
   1	function lib.strict(x)
***0	  if x == false then
    	    -- not strict
***0	    lib2.__index = private.__index
    	  else
    	    -- disable autoload and raise on nil
***0	    lib2.__index = private.__index_strict
    	  end
    	end
    	
    	--- Autoload for _G
   1	function private.__index(table, name)
***0	  if name == '_PROMPT' or name == '_PROMPT2' then
    	    -- special case for lua interactive
***0	    return nil
    	  end
***0	  local ok, new_lib_or_error = pcall(function() return require(name); end)
***0	  if ok then
***0	    return new_lib_or_error or rawget(table, name)
    	  else
    	    -- nil value
***0	    return nil
    	  end
    	end
    	
    	--- Autoload for _G (strict mode = no nil allowed)
   1	function private.__index_strict(table, name)
***0	  if name == '_PROMPT' or name == '_PROMPT2' then
    	    -- special case for lua interactive
***0	    return nil
    	  end
***0	  local ok, new_lib_or_error = pcall(function() return require(name); end)
***0	  if ok then
***0	    return new_lib_or_error or rawget(table, name)
    	  else
    	    -- nil value
***0	    error(string.format("Trying to access undefined global variable '%s'.\n%s", name, debug.traceback()))
    	  end
    	end
    	
    	-- Default is strict.
   1	lib2.__index = private.__index_strict
    	
   1	return lib

==============================================================================
/usr/local/share/lua/5.2/lub/init.lua
==============================================================================
    	--[[--------------------
    	  # Lubyk base module <a href="https://travis-ci.org/lubyk/lub"><img src="https://travis-ci.org/lubyk/lub.png" alt="Build Status"></a> 
    	
    	  This module contains core functions (code loading, templates, helpers).
    	
    	  <html><a href="https://github.com/lubyk/lub"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a></html>
    	  
    	  *MIT license* &copy Gaspard Bucher 2014.
    	
    	  ## Installation
    	  
    	  With [luarocks](http://luarocks.org):
    	
    	    $ luarocks install lub
    	
    	--]]--------------------
   1	local lfs  = require 'lfs'
    	
   1	local private = {}
    	local format,        gsub,        sub,        match,        len,        pairs, ipairs =
   1	      string.format, string.gsub, string.sub, string.match, string.len, pairs, ipairs
    	local yield,           insert,       sort,       remove,       type =
   1	      coroutine.yield, table.insert, table.sort, table.remove, type
    	
   1	local TAIL_CALL = rawget(_G, 'setfenv') and '%(tail call%)' or '%(%.%.%.tail calls%.%.%.%)'
    	
   3	local CALL_TO_NEW = {__call = function(lib, ...) return lib.new(...) end}
    	
   1	local lib = {}
    	
    	--[[------------------------------------------------------
    	
    	  The module also contains utility functions related to path
    	  management, script introspection and some string/array methods.
    	
    	--]]------------------------------------------------------
    	
    	-- ## Dependencies
    	--
    	
    	-- Current version respecting [semantic versioning](http://semver.org).
   1	lib.VERSION = '1.1.0'
    	
   1	lib.DEPENDS = { -- doc
    	  -- Compatible with Lua 5.1 to 5.3 and LuaJIT
   1	  "lua >= 5.1, < 5.4",
    	  -- Uses [Lua Filesystem](http://keplerproject.github.io/luafilesystem/)
    	  "luafilesystem >= 1.4.0",
   1	}
    	
    	-- Basic description for luarocks.
   1	lib.DESCRIPTION = {
   1	  summary = "Lubyk base module.",
    	  detailed = [[
    	    lub: helper code, class declaration.
    	
    	    lub.Autoload: autoloading classes in modules.
    	
    	    lub.Dir: a simple directory traversal class.
    	
    	    lub.Template: a simple templating class that uses {{moustache}} like syntax.
    	
    	    lub.Param: script parameter save/restore.
   1	  ]],
   1	  homepage = "http://doc.lubyk.org/lub.html",
   1	  author   = "Gaspard Bucher",
   1	  license  = "MIT",
   1	}
    	
    	-- Build settings for lut.Builder
   1	lib.BUILD = {
   1	  github   = "lubyk",
   1	  pure_lua = true,
   1	}
    	
    	local SYSTINFO
    	
    	-- # Environment information
    	--
    	-- Get name of currently running platform. Values are 'linux',
    	-- 'macosx', 'unix' and 'win32'. Returns "platform", "platform detail", "system"
    	--
    	-- Platform detail is MinGW or Cygwin for example.
    	--
   1	function lib.plat()
***0	  if not SYSTINFO then
***0	    local cfg = require 'luarocks.cfg'
***0	    local ok, system = pcall(function()
***0	      return io.popen("uname -s"):read("*l")
    	    end)
***0	    if not ok then
***0	      error('Cannot get platform information without "io.popen"')
    	    end
    	    
***0	    SYSTINFO = {SYSTEM = system}
    	
***0	    if system == 'Darwin' then
***0	      SYSTINFO.PLAT = 'macosx'
***0	    elseif system:match('^CYGWIN') then
***0	      SYSTINFO.PLAT = 'win32'
***0	      SYSTINFO.PLAT_DETAIL = 'Cygwin'
***0	    elseif system and system:match("^Windows") then
***0	      SYSTINFO.PLAT = 'win32'
***0	      SYSTINFO.PLAT_DETAIL = 'Windows'
***0	    elseif system and system:match("^MINGW") then
***0	      SYSTINFO.PLAT = 'win32'
***0	      SYSTINFO.PLAT_DETAIL = 'MinGW'
    	    else
***0	      SYSTINFO.PLAT = 'unix'
    	    end
    	  end
***0	  return SYSTINFO.PLAT, SYSTINFO.PLAT_DETAIL, SYSTINFO.SYSTEM
    	end
    	
    	-- # Class management
    	--
    	-- Declare a new class with the following conventions:
    	--
    	-- * The `.type` field contains the full class name.
    	-- * The returned table is the metatable for all instances of this class and
    	--   contains the functions.
    	-- * Calling the table with `foo.Bar()` is an alias for a call to
    	--   `foo.Bar.new`.
    	--
    	-- Usage:
    	--
    	--   local lub = require 'lub'
    	--   local lut = require 'lut'
    	--   local lib = lub.class 'lut.Doc'
    	--
    	--   -- ...
    	--   return lib
    	--
    	-- WARN When using an initial lua table, make sure to use parenthesis around the
    	-- function call:
    	--
    	--   local lib = lub.class('lut.Doc', {
    	--     is_cool = true,
    	--   })
    	--   
   1	function lib.class(class_name, tbl)
   1	  local lib = tbl or {}
   1	  lib.type = class_name
   1	  lib.__index = lib
    	
   1	  return setmetatable(lib, CALL_TO_NEW)
    	end
    	
    	-- # Algorithm
    	
    	-- Search a tree using lua function for node testing or collecting. This method
    	-- is an alias for #BFS.
    	--
    	-- Optional argument `max_depth` is to avoid hanging in case the data contains
    	-- loops. The default value for `max_depth` is 3000.
    	--
    	-- If the function `func` used for testing returns any value different from
    	-- false or nil, the search is terminated and this value is returned.
    	--
    	-- Example to find an element in an xml tree:
    	--
    	--   local poor_guy = lub.search(data, function(node)
    	--     if node.xml == 'Person' and node.status == 'poor' then
    	--       return node
    	--     end
    	--   end)
    	--
    	-- Example to collect elements:
    	--
    	--   local list = {}
    	--   lub.search(data, function(node)
    	--     if node.xml == 'Person' then
    	--       table.insert(list, node)
    	--     end
    	--   end 
    	--
    	-- ## Speed
    	--
    	-- The traversal speed depends on whether we are using Lua or LuaJIT. The tests
    	-- below were done on a relatively large medical XML file without very deep
    	-- nesting.
    	--
    	--   #txt ascii
    	--   ===== Lua
    	--   IDDFS     5.10
    	--   BFS       2.58
    	--   ===== LuaJIT
    	--   IDDFS     0.30
    	--   BFS       0.36
    	-- function lib.search(data, func, max_depth)
    	
    	-- Iterative deepening depth-first search
    	local function itdeepSearch(data, func, depth, max_depth)
***0	  local end_reached = true
    	  local result
***0	  for _, child in ipairs(data) do
***0	    if type(child) == 'table' then
***0	      if depth == max_depth then
***0	        local r = func(child)
***0	        if r then
***0	          return r
***0	        elseif child[1] then
    	          -- Could search deeper
***0	          end_reached = false
    	        end
***0	      elseif child[1] then
    	        -- Go deeper
***0	        local r, e = itdeepSearch(child, func, depth + 1, max_depth)
***0	        if r then
***0	          return r
    	        else
***0	          end_reached = end_reached and e
    	        end
    	      end
    	    end
    	  end
    	
***0	  return nil, end_reached
    	end
    	
    	-- [Iterative deepening depth-first search](https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search) with max depth testing. See #search for usage.
   1	function lib.IDDFS(data, func, max_depth)
***0	  local depth = 1
***0	  max_depth = max_depth or 3000
***0	  key = key or 'xml'
***0	  local r = func(data)
***0	  if r then return r end
    	  while true do
***0	    local result, end_reached = itdeepSearch(data, func, 1, depth)
***0	    if result then
***0	      return result
***0	    elseif end_reached then
***0	      return nil
***0	    elseif depth < max_depth then
***0	      depth = depth + 1
    	    else
***0	      error(format('Could not finish search: maximal depth of %i reached.', max_depth))
    	    end
    	  end
    	end
    	
    	-- [Breath-first search](https://en.wikipedia.org/wiki/Breadth-first_search) with max depth testing. See #search for usage.
   1	function lib.BFS(data, func, max_depth)
***0	  local max_depth = max_depth or 3000
***0	  local queue = {}
***0	  local depth = {} -- depth queue
***0	  local head  = 1
***0	  local tail  = 1
    	  local function push(e, d)
***0	    queue[tail] = e
***0	    depth[tail] = d
***0	    tail = tail + 1
    	  end
    	
    	  local function pop()
***0	    if head == tail then return nil end
***0	    local e, d = queue[head], depth[head]
***0	    head = head + 1
***0	    return e, d
    	  end
    	
***0	  local elem = data
***0	  local d = 1
***0	  while elem and d <= max_depth do
***0	    local r = func(elem)
***0	    if r then return elem end
***0	    for _, child in ipairs(elem) do
***0	      if type(child) == 'table' then
***0	        push(child, d + 1)
    	      end
    	    end
***0	    elem, d = pop()
    	  end
    	
***0	  if d and d > max_depth then
***0	    error(format('Could not finish search: maximal depth of %i reached.', max_depth))
    	  else
***0	    return nil
    	  end
    	end
    	  
    	-- nodoc
   1	lib.search = lib.BFS
    	
    	-- # Filesystem
    	
    	-- Find the source of the current file or the file up x levels in the call
    	-- chain (-1 = up one level).
    	local function scriptSource(level)
***0	  local level = level or 0
***0	  return debug.getinfo(2 - level).source
    	end
    	
    	-- Find the path of the current script or the script up x levels in the call
    	-- chain (-1 = up one level). The path is relative to the current directory.
    	--
    	--   -- get path of running script
    	--   local my_path = lub.scriptPath()
    	--   --> 'test/lk_test.lua'
    	-- 
    	-- If you need an absolute path, use #absolutizePath.
    	local function scriptPath(level)
***0	  local level = level or 0
***0	  return match(scriptSource(level - 1), '^@(.*)$')
    	end
    	
    	-- Find the directory of the current script or the directory of the script up x
    	-- levels in the call chain (-1 = up one level). This is the same as #scriptPath
    	-- but it returns the parent directory.
    	local function scriptDir(level)
***0	  local level = level or 0
***0	  local file = scriptPath(level - 1)
***0	  assert(file, "Cannot use scriptDir here because of a tail call optimization.\n"..debug.traceback())
***0	  if match(file, '/') then
***0	    local p = gsub(file, '/[^/]+$', '')
***0	    return p
    	  else
***0	    return '.'
    	  end
    	end
    	
    	-- Return a path by resolving special initial characters. The `level` argument
    	-- can move further up the call hierarchy before resolving paths (use `1` to
    	-- move up one call). Special
    	-- initial characters are:
    	--
    	-- + `/`   : absolute path, resolves '..' in path.
    	-- + `|`   : path relative to script directory, resolves '..' in path.
    	-- + `&`   : returns current script path.
    	--
    	-- For example:
    	--
    	--   print(lub.path '|')
    	--   --> current script directory
    	--
    	--   print(lub.path '|..')
    	--   --> parent of script directory
    	--
   1	function lib.path(path, level)
***0	  level = level or 2
***0	  local chr = sub(path, 1, 1)
***0	  if chr == '|' or chr == '&' then
***0	    local src = debug.getinfo(level).source
***0	    if src:match(TAIL_CALL) then
***0	      src = debug.getinfo(level + 1).source
    	    end
***0	    local s = match(src, '^@(.*)$')
***0	    if chr == '&' then
***0	      return s
    	    end
***0	    local b = lib.dir(s)
***0	    if len(path) == 1 then return b end
***0	    local r = sub(path, 2, -1)
***0	    return lib.absolutizePath(b..'/'..r)
    	  else
***0	    return lib.absolutizePath(path)
    	  end
    	end
    	
    	-- Test for file/directory existence at `path`. If the element exists, returns
    	-- the file type such as *'directory'* or *'file'*. Returns nil if there is
    	-- nothing at the given path.
   1	function lib.fileType(path)
***0	  if not path then return nil end
***0	  local attrs = lfs.attributes(path)
***0	  return attrs and attrs.mode
    	end
    	
    	-- Return true if the file or folder pointed by `path` exists.
    	-- function lib.exist(path)
    	
    	-- nodoc
   1	lib.exist = lib.fileType
    	
    	-- Return the content of a file as a lua string (not suitable for very long
    	-- content where parsing the file chunks by chunks is better). The method
    	-- accepts either a single `path` argument or a `basepath` and relative `path`.
   1	function lib.content(basepath, path)
***0	  if path then
***0	    path = format('%s/%s', basepath, path)
    	  else
***0	    path = basepath
    	  end
***0	  local f = assert(io.open(path, 'rb'))
***0	  local s = f:read('*all')
***0	  f:close()
***0	  return s
    	end
    	
    	-- Write `data` to `filepath`, creating path folders if necessary. If
    	-- `check_diff` is true, only write if the content has changed to avoid
    	-- changing stat information on the file.
   1	function lib.writeall(filepath, data, check_diff)
    	  -- get base directory and build components if necessary
***0	  lib.makePath(lib.dir(filepath))
***0	  if check_diff and lib.exist(filepath) then
***0	    if data == lib.content(filepath) then
***0	      return true
    	    end
    	  end
***0	  local f = assert(io.open(filepath, 'wb'))
***0	  local s = f:write(data)
***0	  f:close()
***0	  return s
    	end
    	
    	-- Build necessary folders to create a given `path`.
   1	function lib.makePath(path)
***0	  local fullpath = lib.absolutizePath(path)
***0	  private.makePathPart(fullpath, fullpath)
    	end
    	
    	-- Move a file or directory from `path` to `new_path`. This is like "os.rename"
    	-- but it also builds necessary path components in new_path.
   1	function lib.move(path, new_path)
***0	  lib.makePath(lib.dir(new_path))
***0	  return os.rename(path, new_path)
    	end
    	
    	-- Copy a file from `path` to `new_path`. Builds necessary path components
    	-- in new_path.
   1	function lib.copy(path, new_path)
***0	  lib.makePath(lib.dir(new_path))
***0	  return os.execute(format('cp %s %s', lib.shellQuote(path), lib.shellQuote(new_path)))
    	end
    	
    	-- Delete the file located at `path`. Does nothing if the element at `path` does
    	-- not exist (already removed).
   1	function lib.rmFile(path)
***0	  local typ = lib.fileType(path)
***0	  if not typ then return end
***0	  assert(typ == 'file', format("Cannot remove '%s': it is a %s.", path, typ))
***0	  os.remove(path)
    	end
    	
    	-- Remove the directory at `path`. If `recursive` is true, remove recursively.
    	-- *This is a dangerous method* if the source path is not ensured to be exempt
    	-- of mistakes.
   1	function lib.rmTree(path, recursive)
***0	  local fullpath = lib.absolutizePath(path)
***0	  if not lib.exist(fullpath) then
***0	    return true
    	  end
***0	  if fullpath ~= '/' and fullpath ~= '' then
    	    -- bug paranoia
***0	    if not recursive then
***0	      return lfs.rmdir(fullpath)
    	    else
***0	      local code = format('rm -r %s', lib.shellQuote(fullpath))
***0	      if os.execute(code) == 0 then
***0	        return true
    	      else
***0	        return false
    	      end
    	    end
    	  end
    	end
    	
    	-- Return the parent folder and filename from a `filepath`. Usage:
    	--
    	--   local base, file = lub.dir(filepath)
    	-- 
    	-- This can also be used on urls.
   1	function lib.dir(filepath)
***0	  local base, file = match(filepath, '(.*)/(.*)$')
***0	  if not base then
***0	    return '.', filepath
***0	  elseif base == '' then
    	    -- '/' == root ?
***0	    return '/', file
    	  else
***0	    return base, file
    	  end
    	end
    	
    	-- nodoc
   1	function lib.pathDir(...)
***0	  return lib.deprecation('lub', 'pathDir', 'dir', ...)
    	end
    	
    	-- Return an absolute path from a `path` and optional `basepath`. If basepath is
    	-- not provided, the method uses the current directory. This method
    	-- resolves `/../` and `/./` in paths and returns a clean path. Can also be
    	-- used with urls.
    	--
    	-- For example:
    	--
    	--   local abs_path = lub.absolutizePath('foo/bar/../baz', '/home')
    	--   --> '/home/foo/baz'
   1	function lib.absolutizePath(path, basepath)
***0	  if not match(path, '^/') then
***0	    path = format('%s/%s', basepath or lfs.currentdir(), path)
    	  end
    	  -- resolve '/./' and '/../'
***0	  local parts = lib.split(path, '/')
***0	  local path = {}
***0	  for i, part in ipairs(parts) do
***0	    if part == '.' then
    	      -- ignore
***0	    elseif part == '..' then
    	      -- move back
    	      -- 1 = '', 2 = 'xxx', 3 = '..' ==> 1 = ''
***0	      if i > 2 then
***0	        remove(path, #path)
    	      end
    	    else
***0	      insert(path, part)
    	    end
    	  end
***0	  return lib.join(path, '/')
    	end
    	
    	-- Transform an absolute path or url to a relative path with given base. For 
    	-- example:
    	--
    	--   local rel = lub.absToRel('/home/foo/bar', '/home/foo/baz')
    	--   --> '/home/foo/bar'
    	--   local rel = lub.absToRel('/home/foo/bar', '/home/foo')
    	--   --> 'bar'
   1	function lib.absToRel(abs_string, base)
***0	  local l = string.len(base)
***0	  local s = string.sub(abs_string, 1, l)
***0	  if s == base then
***0	    if base == abs_string then
***0	      return abs_string
    	    else
***0	      return string.sub(abs_string, l+2, -1)
    	    end
    	  else
***0	    return abs_string
    	  end
    	end
    	
    	-- # Strings, Arrays
    	
    	-- Removes white spaces at the beginning and end of the string `str`.
   1	function lib.strip(str)
***0	  return match(str, '^[ \t\n\r]*(.-)[ \t\n\r]*$')
    	end
    	
    	-- Split a string `str` into elements separated by the pattern `pat`. The
    	-- function returns a table.
    	--
    	--   local t = lub.split('foo/bar/baz', '/')
    	--   --> {'foo', 'bar', 'baz'}
   1	function lib.split(str, pat)
***0	  local t = {}  -- NOTE: use {n = 0} in Lua-5.0
***0	  if not pat then
***0	    local i = 1
    	    while true do
***0	      local s = string.sub(str, i, i)
***0	      if s == '' then
    	        break
    	      else
***0	        insert(t, s)
    	      end
***0	      i = i + 1
    	    end
    	  else
***0	    local fpat = '(.-)' .. pat
***0	    local last_end = 1
***0	    local s, e, cap = string.find(str,fpat, 1)
***0	    while s do
***0	      insert(t,cap)
***0	      last_end = e+1
***0	      s, e, cap = str:find(fpat, last_end)
    	    end
***0	    if last_end <= #str then
***0	      cap = str:sub(last_end)
***0	      insert(t, cap)
    	    end
    	  end
***0	  return t
    	end
    	
    	-- Join elements of a table `list` with separator `sep`. Returns a string.
    	--
    	--   local x = lub.join({'foo', 'bar', 'baz'}, '.')
    	--   --> 'foo.bar.baz'
   1	function lib.join(list, sep)
    	  local res = nil
***0	  for _, part in ipairs(list) do
***0	    if not res then
***0	      res = part
    	    else
***0	      res = res .. sep .. part
    	    end
    	  end
***0	  return res or ''
    	end
    	
    	-- Get the ordered list of *string* keys from a table. If `no_order` is true, keys are
    	-- not sorted.
   1	function lib.keys(dict, no_order)
***0	  local res, n = {}, 0
***0	  for k, v in pairs(dict) do
***0	    if type(k) == 'string' then
***0	      n = n + 1
***0	      res[n] = k
    	    end
    	  end
***0	  if not no_order then
***0	    sort(res)
    	  end
***0	  return res
    	end
    	
    	-- Insert `elem` into a `list`, keeping entries in "list" sorted. If elem is not
    	-- a string, the `elem[key]` is used to get a string for sorting.
   1	function lib.insertSorted(list, elem, key)
***0	  local pos = -1
***0	  for i, n in ipairs(list) do
***0	    local a, b = n, elem
***0	    if key then
***0	      a = a[key]
***0	      b = b[key]
    	    end
***0	    if a > b then
***0	      pos = i
    	      break
    	    end
    	  end
***0	  if pos == -1 then
***0	    insert(list, elem)
    	  else
***0	    insert(list, pos, elem)
    	  end
    	end
    	
    	-- Merge values in `table` inside `source`. All keys are considered (array and
    	-- hash).
   1	function lib.merge(source, table)
***0	  for k, v in pairs(table) do
***0	    source[k] = v
    	  end
    	end
    	
    	local function deepMerge(base, key, value)
***0	  local base_v = base[key]
***0	  if type(value) == 'table' then
***0	    if not base_v then
***0	      base[key] = value
***0	      return true
    	    else
    	      -- merge
***0	      local changed = false
***0	      for k, v in pairs(value) do
***0	        changed = deepMerge(base_v, k, v) or changed
    	      end
***0	      return changed
    	    end
***0	  elseif base_v == value then
    	    -- nothing changed
***0	    return false
    	  else
***0	    base[key] = value
***0	    return true
    	  end
    	end
    	-- nodoc
   1	lib.deepMerge = deepMerge
    	
    	-- Deep merge `value` into `base` at `key`. Returns true if *base* has been
    	-- changed. For example:
    	--
    	--   local base = {a = { b = 4, c = 5 }}
    	--   lub.deepMerge(base, 'a', { c = 5 })
    	--   --> false (nothing changed)
    	--
    	--   lub.deepMerge(base, 'a', { c = 6 })
    	--   --> true, base = {a = { b = 4, c = 6 }}
    	-- function lib.deepMerge(base, key, value)
    	-- # Debugging
    	
   1	local orig_req = require
    	-- Print calls to `require`. This can be used to list all code dependencies.
    	-- Usage:
    	--
    	--   lub.traceRequire(true)
    	--   -- From now on, all require statements are printed.
    	-- 
    	-- If you simply want to make sure no `require` is called to autoload code
    	-- after some point, you should use [Autoload.strict](Autoload.html#strict).
   1	function lib.traceRequire(enable)
***0	  if enable then
    	    require = function(path)
***0	      print("require '"..path.."'")
***0	      return orig_req(path)
    	    end
    	  else
***0	    require = orig_req
    	  end
    	end
    	
    	-- Print a log message with the current file name and line. This is better then
    	-- using "print" because it gives us some information on the context of the 
    	-- print statement.
    	--
    	--   lub.log('foo')
    	--   --> lub/util.lua:426:  foo
   1	function lib.log(...)
***0	  local trace = lib.split(debug.traceback(), '\n\t')
***0	  local part = trace[3]
***0	  if part:match(TAIL_CALL) then
***0	    part = trace[4]
    	  end
***0	  local file, line = match(part, '^([^:]+):([^:]+):')
***0	  if file and line then
***0	    print(format('%s:%i:', file, line), ...)
    	  else
***0	    print(part, ...)
    	  end
    	end
    	
    	
    	-- # Miscellanous
    	
    	-- Declare a method as being deprecated. This should be used when method names
    	-- are changed to avoid breaking code without warnings. The syntax is:
    	--
    	--   function lib.badName(...)
    	--     return lib.deprecation('lub', 'badName', 'betterName', ...)
    	--   end
    	-- 
    	-- When someone uses the "badName" method, a deprecation warning is printed:
    	--
    	--   [DEPRECATION] {traceback}
    	--       'lub.badName' is deprecated. Please use 'lub.betterName' instead.
   1	function lib.deprecation(lib_name, old, new, ...)
***0	  local trace = lib.split(debug.traceback(), '\n\t')[4]
***0	  local arg = ...
***0	  if arg then
***0	    print(format("[DEPRECATION] %s\n\t'%s.%s' is deprecated. Please use '%s.%s' instead.", trace, lib_name, old, lib_name, new))
***0	    return package.loaded[lib_name][new](...)
    	  else
***0	    print(format("[DEPRECATION] %s\n\t'%s.%s' is deprecated and will be removed. Please use '%s' instead.", trace, lib_name, old, new))
    	  end
    	end
    	
    	-- Quote string `str` so that it can be inserted in a shell command. Example:
    	--
    	--   os.execute(string.format('latex %s', lub.shellQuote(filepath)))
   1	function lib.shellQuote(str)
***0	  return '"' .. gsub(str, '[\\%$"]', function(x)
***0	    return '\\' .. x
***0	  end) .. '"'
    	end
    	
   1	function private.makePathPart(path, fullpath)
***0	  local file_type = lib.fileType(path)
***0	  if file_type == 'file' then
***0	    error(format("Could not build path '%s' ('%s' is a file).", fullpath, path))
***0	  elseif file_type == 'directory' then
***0	    return -- done
    	  else
***0	    local base = lib.dir(path)
***0	    private.makePathPart(base, fullpath)
    	    -- base should exist or an error has been raised
***0	    lfs.mkdir(path)
    	    -- done
    	  end
    	end
    	
    	-- We only enable autoload once all is loaded so that the 'Autoload' class finds
    	-- 'lub' library.
   1	package.loaded.lub = lib
    	
    	-- nodoc
   1	lib.Autoload = require 'lub.Autoload'
    	
   1	lib.Autoload('lub', lib)
    	
    	
    	-- # Classes
    	
   1	return lib

==============================================================================
/usr/local/share/lua/5.2/md5.lua
==============================================================================
    	----------------------------------------------------------------------------
    	-- $Id: md5.lua,v 1.4 2006/08/21 19:24:21 carregal Exp $
    	----------------------------------------------------------------------------
    	
    	local core
   1	local string = string or require"string"
   1	if string.find(_VERSION, "Lua 5.0") then
***0		local cpath = os.getenv"LUA_CPATH" or "/usr/local/lib/lua/5.0/"
***0		core = loadlib(cpath.."md5/core.so", "luaopen_md5_core")()
    	else
   1		core = require"md5.core"
    	end
    	
    	
    	----------------------------------------------------------------------------
    	-- @param k String with original message.
    	-- @return String with the md5 hash value converted to hexadecimal digits
    	
   1	function core.sumhexa (k)
***0	  k = core.sum(k)
***0	  return (string.gsub(k, ".", function (c)
***0	           return string.format("%02x", string.byte(c))
    	         end))
    	end
    	
   1	return core

==============================================================================
/usr/local/share/lua/5.2/mediator.lua
==============================================================================
    	local function getUniqueId(obj)
  32	  return tonumber(tostring(obj):match(':%s*[0xX]*(%x+)'), 16)
    	end
    	
    	local function Subscriber(fn, options)
  32	  local sub = {
  32	    options = options or {},
  32	    fn = fn,
  32	    channel = nil,
    	    update = function(self, options)
***0	      if options then
***0	        self.fn = options.fn or self.fn
***0	        self.options = options.options or self.options
    	      end
    	    end
    	  }
  32	  sub.id = getUniqueId(sub)
  32	  return sub
    	end
    	
    	-- Channel class and functions --
    	
    	local function Channel(namespace, parent)
  25	  return {
  25	    stopped = false,
  25	    namespace = namespace,
  25	    callbacks = {},
  25	    channels = {},
  25	    parent = parent,
    	
    	    addSubscriber = function(self, fn, options)
  32	      local callback = Subscriber(fn, options)
  32	      local priority = (#self.callbacks + 1)
    	
  32	      options = options or {}
    	
  32	      if options.priority and
  20	        options.priority >= 0 and
  20	        options.priority < priority
    	      then
  15	          priority = options.priority
    	      end
    	
  32	      table.insert(self.callbacks, priority, callback)
    	
  32	      return callback
    	    end,
    	
    	    getSubscriber = function(self, id)
***0	      for i=1, #self.callbacks do
***0	        local callback = self.callbacks[i]
***0	        if callback.id == id then return { index = i, value = callback } end
    	      end
    	      local sub
***0	      for _, channel in pairs(self.channels) do
***0	        sub = channel:getSubscriber(id)
***0	        if sub then break end
    	      end
***0	      return sub
    	    end,
    	
    	    setPriority = function(self, id, priority)
***0	      local callback = self:getSubscriber(id)
    	
***0	      if callback.value then
***0	        table.remove(self.callbacks, callback.index)
***0	        table.insert(self.callbacks, priority, callback.value)
    	      end
    	    end,
    	
    	    addChannel = function(self, namespace)
  25	      self.channels[namespace] = Channel(namespace, self)
  25	      return self.channels[namespace]
    	    end,
    	
    	    hasChannel = function(self, namespace)
***0	      return namespace and self.channels[namespace] and true
    	    end,
    	
    	    getChannel = function(self, namespace)
 134	      return self.channels[namespace] or self:addChannel(namespace)
    	    end,
    	
    	    removeSubscriber = function(self, id)
***0	      local callback = self:getSubscriber(id)
    	
***0	      if callback and callback.value then
***0	        for _, channel in pairs(self.channels) do
***0	          channel:removeSubscriber(id)
    	        end
    	
***0	        return table.remove(self.callbacks, callback.index)
    	      end
    	    end,
    	
    	    publish = function(self, result, ...)
 146	      for i = 1, #self.callbacks do
  72	        local callback = self.callbacks[i]
    	
    	        -- if it doesn't have a predicate, or it does and it's true then run it
  72	        if not callback.options.predicate or callback.options.predicate(...) then
    	           -- just take the first result and insert it into the result table
  72	          local value, continue = callback.fn(...)
    	
  72	          if value then table.insert(result, value) end
  72	          if not continue then return result end
    	        end
    	      end
    	
  74	      if parent then
  49	        return parent:publish(result, ...)
    	      else
  25	        return result
    	      end
    	    end
  25	  }
    	end
    	
    	-- Mediator class and functions --
    	
***0	local Mediator = setmetatable(
    	{
    	  Channel = Channel,
***0	  Subscriber = Subscriber
    	},
    	{
    	  __call = function (fn, options)
***0	    return {
    	      channel = Channel('root'),
    	
    	      getChannel = function(self, channelNamespace)
  70	        local channel = self.channel
    	
 204	        for i=1, #channelNamespace do
 134	          channel = channel:getChannel(channelNamespace[i])
    	        end
    	
  70	        return channel
    	      end,
    	
    	      subscribe = function(self, channelNamespace, fn, options)
  32	        return self:getChannel(channelNamespace):addSubscriber(fn, options)
    	      end,
    	
    	      getSubscriber = function(self, id, channelNamespace)
***0	        return self:getChannel(channelNamespace):getSubscriber(id)
    	      end,
    	
    	      removeSubscriber = function(self, id, channelNamespace)
***0	        return self:getChannel(channelNamespace):removeSubscriber(id)
    	      end,
    	
    	      publish = function(self, channelNamespace, ...)
  38	        return self:getChannel(channelNamespace):publish({}, ...)
    	      end
    	    }
    	  end
    	})
***0	return Mediator

==============================================================================
/usr/local/share/lua/5.2/moonscript/base.lua
==============================================================================
***0	local compile = require("moonscript.compile")
***0	local parse = require("moonscript.parse")
    	local concat, insert, remove
    	do
***0	  local _obj_0 = table
***0	  concat, insert, remove = _obj_0.concat, _obj_0.insert, _obj_0.remove
    	end
    	local split, dump, get_options, unpack
    	do
***0	  local _obj_0 = require("moonscript.util")
***0	  split, dump, get_options, unpack = _obj_0.split, _obj_0.dump, _obj_0.get_options, _obj_0.unpack
    	end
***0	local lua = {
    	  loadstring = loadstring,
***0	  load = load
    	}
    	local dirsep, line_tables, create_moonpath, to_lua, moon_loader, loadstring, loadfile, dofile, insert_loader, remove_loader
***0	dirsep = "/"
***0	line_tables = require("moonscript.line_tables")
    	create_moonpath = function(package_path)
    	  local moonpaths
    	  do
***0	    local _accum_0 = { }
***0	    local _len_0 = 1
***0	    local _list_0 = split(package_path, ";")
***0	    for _index_0 = 1, #_list_0 do
***0	      local _continue_0 = false
    	      repeat
***0	        local path = _list_0[_index_0]
***0	        local prefix = path:match("^(.-)%.lua$")
***0	        if not (prefix) then
***0	          _continue_0 = true
    	          break
    	        end
***0	        local _value_0 = prefix .. ".moon"
***0	        _accum_0[_len_0] = _value_0
***0	        _len_0 = _len_0 + 1
***0	        _continue_0 = true
***0	      until true
***0	      if not _continue_0 then
    	        break
    	      end
    	    end
***0	    moonpaths = _accum_0
    	  end
***0	  return concat(moonpaths, ";")
    	end
    	to_lua = function(text, options)
***0	  if options == nil then
***0	    options = { }
    	  end
***0	  if "string" ~= type(text) then
***0	    local t = type(text)
***0	    return nil, "expecting string (got " .. t .. ")"
    	  end
***0	  local tree, err = parse.string(text)
***0	  if not tree then
***0	    return nil, err
    	  end
***0	  local code, ltable, pos = compile.tree(tree, options)
***0	  if not code then
***0	    return nil, compile.format_error(ltable, pos, text)
    	  end
***0	  return code, ltable
    	end
    	moon_loader = function(name)
  34	  local name_path = name:gsub("%.", dirsep)
    	  local file, file_path
 272	  for path in package.moonpath:gmatch("[^;]+") do
 238	    file_path = path:gsub("?", name_path)
 238	    file = io.open(file_path)
 238	    if file then
    	      break
    	    end
    	  end
  34	  if file then
***0	    local text = file:read("*a")
***0	    file:close()
***0	    local res, err = loadstring(text, "@" .. tostring(file_path))
***0	    if not res then
***0	      error(file_path .. ": " .. err)
    	    end
***0	    return res
    	  end
  34	  return nil, "Could not find moon file"
    	end
    	loadstring = function(...)
***0	  local options, str, chunk_name, mode, env = get_options(...)
***0	  chunk_name = chunk_name or "=(moonscript.loadstring)"
***0	  local code, ltable_or_err = to_lua(str, options)
***0	  if not (code) then
***0	    return nil, ltable_or_err
    	  end
***0	  if chunk_name then
***0	    line_tables[chunk_name] = ltable_or_err
    	  end
***0	  return (lua.loadstring or lua.load)(code, chunk_name, unpack({
    	    mode,
***0	    env
    	  }))
    	end
    	loadfile = function(fname, ...)
***0	  local file, err = io.open(fname)
***0	  if not (file) then
***0	    return nil, err
    	  end
***0	  local text = assert(file:read("*a"))
***0	  file:close()
***0	  return loadstring(text, "@" .. tostring(fname), ...)
    	end
    	dofile = function(...)
***0	  local f = assert(loadfile(...))
***0	  return f()
    	end
    	insert_loader = function(pos)
***0	  if pos == nil then
***0	    pos = 2
    	  end
***0	  if not package.moonpath then
***0	    package.moonpath = create_moonpath(package.path)
    	  end
***0	  local loaders = package.loaders or package.searchers
***0	  for _index_0 = 1, #loaders do
***0	    local loader = loaders[_index_0]
***0	    if loader == moon_loader then
***0	      return false
    	    end
    	  end
***0	  insert(loaders, pos, moon_loader)
***0	  return true
    	end
    	remove_loader = function()
***0	  local loaders = package.loaders or package.searchers
***0	  for i, loader in ipairs(loaders) do
***0	    if loader == moon_loader then
***0	      remove(loaders, i)
***0	      return true
    	    end
    	  end
***0	  return false
    	end
***0	return {
    	  _NAME = "moonscript",
    	  insert_loader = insert_loader,
    	  remove_loader = remove_loader,
    	  to_lua = to_lua,
    	  moon_loader = moon_loader,
    	  dirsep = dirsep,
    	  dofile = dofile,
    	  loadfile = loadfile,
    	  loadstring = loadstring,
***0	  create_moonpath = create_moonpath
    	}

==============================================================================
/usr/local/share/lua/5.2/pl/dir.lua
==============================================================================
    	--
    	-- Dependencies: `pl.utils`, `pl.path`, `pl.tablex`
    	--
    	-- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
    	-- @module pl.dir
    	
   1	local utils = require 'pl.utils'
   1	local path = require 'pl.path'
   1	local is_windows = path.is_windows
   1	local tablex = require 'pl.tablex'
   1	local ldir = path.dir
   1	local chdir = path.chdir
   1	local mkdir = path.mkdir
   1	local rmdir = path.rmdir
   1	local sub = string.sub
   1	local os,pcall,ipairs,pairs,require,setmetatable,_G = os,pcall,ipairs,pairs,require,setmetatable,_G
   1	local remove = os.remove
   1	local append = table.insert
   1	local wrap = coroutine.wrap
   1	local yield = coroutine.yield
   1	local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise
   1	local List = utils.stdmt.List
    	
   1	local dir = {}
    	
    	local function assert_dir (n,val)
   1	    assert_arg(n,val,'string',path.isdir,'not a directory',4)
    	end
    	
    	local function assert_file (n,val)
***0	    assert_arg(n,val,'string',path.isfile,'not a file',4)
    	end
    	
    	local function filemask(mask)
   1	    mask = utils.escape(mask)
   1	    return mask:gsub('%%%*','.+'):gsub('%%%?','.')..'$'
    	end
    	
    	--- does the filename match the shell pattern?.
    	-- (cf. fnmatch.fnmatch in Python, 11.8)
    	-- @string file A file name
    	-- @string pattern A shell pattern
    	-- @treturn bool
    	-- @raise file and pattern must be strings
   1	function dir.fnmatch(file,pattern)
***0	    assert_string(1,file)
***0	    assert_string(2,pattern)
***0	    return path.normcase(file):find(filemask(pattern)) ~= nil
    	end
    	
    	--- return a list of all files which match the pattern.
    	-- (cf. fnmatch.filter in Python, 11.8)
    	-- @string files A table containing file names
    	-- @string pattern A shell pattern.
    	-- @treturn List(string) list of files
    	-- @raise file and pattern must be strings
   1	function dir.filter(files,pattern)
***0	    assert_arg(1,files,'table')
***0	    assert_string(2,pattern)
***0	    local res = {}
***0	    local mask = filemask(pattern)
***0	    for i,f in ipairs(files) do
***0	        if f:find(mask) then append(res,f) end
    	    end
***0	    return setmetatable(res,List)
    	end
    	
    	local function _listfiles(dir,filemode,match)
***0	    local res = {}
***0	    local check = utils.choose(filemode,path.isfile,path.isdir)
***0	    if not dir then dir = '.' end
***0	    for f in ldir(dir) do
***0	        if f ~= '.' and f ~= '..' then
***0	            local p = path.join(dir,f)
***0	            if check(p) and (not match or match(p)) then
***0	                append(res,p)
    	            end
    	        end
    	    end
***0	    return setmetatable(res,List)
    	end
    	
    	--- return a list of all files in a directory which match the a shell pattern.
    	-- @string dir A directory. If not given, all files in current directory are returned.
    	-- @string mask  A shell pattern. If not given, all files are returned.
    	-- @treturn {string} list of files
    	-- @raise dir and mask must be strings
   1	function dir.getfiles(dir,mask)
***0	    assert_dir(1,dir)
***0	    if mask then assert_string(2,mask) end
    	    local match
***0	    if mask then
***0	        mask = filemask(mask)
    	        match = function(f)
***0	            return f:find(mask)
    	        end
    	    end
***0	    return _listfiles(dir,true,match)
    	end
    	
    	--- return a list of all subdirectories of the directory.
    	-- @string dir A directory
    	-- @treturn {string} a list of directories
    	-- @raise dir must be a a valid directory
   1	function dir.getdirectories(dir)
***0	    assert_dir(1,dir)
***0	    return _listfiles(dir,false)
    	end
    	
    	local function quote_argument (f)
***0	    f = path.normcase(f)
***0	    if f:find '%s' then
***0	        return '"'..f..'"'
    	    else
***0	        return f
    	    end
    	end
    	
    	
    	local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile
    	
    	local function execute_command(cmd,parms)
***0	   if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
***0	   local err = path.is_windows and ' > ' or ' 2> '
***0	    cmd = cmd..' '..parms..err..cmd_tmpfile
***0	    local ret = utils.execute(cmd)
***0	    if not ret then
***0	        return false,(utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
    	    else
***0	        return true
    	    end
    	end
    	
    	local function find_ffi_copyfile ()
***0	    if not ffi_checked then
***0	        ffi_checked = true
    	        local res
***0	        res,alien = pcall(require,'alien')
***0	        if not res then
***0	            alien = nil
***0	            res, ffi = pcall(require,'ffi')
    	        end
***0	        if not res then
***0	            ffi = nil
***0	            return
    	        end
    	    else
***0	        return
    	    end
***0	    if alien then
    	        -- register the Win32 CopyFile and MoveFile functions
***0	        local kernel = alien.load('kernel32.dll')
***0	        CopyFile = kernel.CopyFileA
***0	        CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
***0	        MoveFile = kernel.MoveFileA
***0	        MoveFile:types{'string','string',ret='int',abi='stdcall'}
***0	        GetLastError = kernel.GetLastError
***0	        GetLastError:types{ret ='int', abi='stdcall'}
***0	    elseif ffi then
***0	        ffi.cdef [[
    	            int CopyFileA(const char *src, const char *dest, int iovr);
    	            int MoveFileA(const char *src, const char *dest);
    	            int GetLastError();
***0	        ]]
***0	        CopyFile = ffi.C.CopyFileA
***0	        MoveFile = ffi.C.MoveFileA
***0	        GetLastError = ffi.C.GetLastError
    	    end
***0	    win32_errors = {
    	        ERROR_FILE_NOT_FOUND    =         2,
    	        ERROR_PATH_NOT_FOUND    =         3,
    	        ERROR_ACCESS_DENIED    =          5,
    	        ERROR_WRITE_PROTECT    =          19,
    	        ERROR_BAD_UNIT         =          20,
    	        ERROR_NOT_READY        =          21,
    	        ERROR_WRITE_FAULT      =          29,
    	        ERROR_READ_FAULT       =          30,
    	        ERROR_SHARING_VIOLATION =         32,
    	        ERROR_LOCK_VIOLATION    =         33,
    	        ERROR_HANDLE_DISK_FULL  =         39,
    	        ERROR_BAD_NETPATH       =         53,
    	        ERROR_NETWORK_BUSY      =         54,
    	        ERROR_DEV_NOT_EXIST     =         55,
    	        ERROR_FILE_EXISTS       =         80,
    	        ERROR_OPEN_FAILED       =         110,
    	        ERROR_INVALID_NAME      =         123,
    	        ERROR_BAD_PATHNAME      =         161,
    	        ERROR_ALREADY_EXISTS    =         183,
    	    }
    	end
    	
    	local function two_arguments (f1,f2)
***0	    return quote_argument(f1)..' '..quote_argument(f2)
    	end
    	
    	local function file_op (is_copy,src,dest,flag)
***0	    if flag == 1 and path.exists(dest) then
***0	        return false,"cannot overwrite destination"
    	    end
***0	    if is_windows then
    	        -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
***0	        find_ffi_copyfile()
    	        -- fallback if there's no Alien, just use DOS commands *shudder*
    	        -- 'rename' involves a copy and then deleting the source.
***0	        if not CopyFile then
***0	            src = path.normcase(src)
***0	            dest = path.normcase(dest)
***0	            local cmd = is_copy and 'copy' or 'rename'
***0	            local res, err = execute_command('copy',two_arguments(src,dest))
***0	            if not res then return false,err end
***0	            if not is_copy then
***0	                return execute_command('del',quote_argument(src))
    	            end
***0	            return true
    	        else
***0	            if path.isdir(dest) then
***0	                dest = path.join(dest,path.basename(src))
    	            end
    				local ret
***0	            if is_copy then ret = CopyFile(src,dest,flag)
***0	            else ret = MoveFile(src,dest) end
***0	            if ret == 0 then
***0	                local err = GetLastError()
***0	                for name,value in pairs(win32_errors) do
***0	                    if value == err then return false,name end
    	                end
***0	                return false,"Error #"..err
***0	            else return true
    	            end
    	        end
    	    else -- for Unix, just use cp for now
***0	        return execute_command(is_copy and 'cp' or 'mv',
***0	            two_arguments(src,dest))
    	    end
    	end
    	
    	--- copy a file.
    	-- @string src source file
    	-- @string dest destination file or directory
    	-- @bool flag true if you want to force the copy (default)
    	-- @treturn bool operation succeeded
    	-- @raise src and dest must be strings
   1	function dir.copyfile (src,dest,flag)
***0	    assert_string(1,src)
***0	    assert_string(2,dest)
***0	    flag = flag==nil or flag
***0	    return file_op(true,src,dest,flag and 0 or 1)
    	end
    	
    	--- move a file.
    	-- @string src source file
    	-- @string dest destination file or directory
    	-- @treturn bool operation succeeded
    	-- @raise src and dest must be strings
   1	function dir.movefile (src,dest)
***0	    assert_string(1,src)
***0	    assert_string(2,dest)
***0	    return file_op(false,src,dest,0)
    	end
    	
    	local function _dirfiles(dir,attrib)
***0	    local dirs = {}
***0	    local files = {}
***0	    for f in ldir(dir) do
***0	        if f ~= '.' and f ~= '..' then
***0	            local p = path.join(dir,f)
***0	            local mode = attrib(p,'mode')
***0	            if mode=='directory' then
***0	                append(dirs,f)
    	            else
***0	                append(files,f)
    	            end
    	        end
    	    end
***0	    return setmetatable(dirs,List),setmetatable(files,List)
    	end
    	
    	
    	local function _walker(root,bottom_up,attrib)
***0	    local dirs,files = _dirfiles(root,attrib)
***0	    if not bottom_up then yield(root,dirs,files) end
***0	    for i,d in ipairs(dirs) do
***0	        _walker(root..path.sep..d,bottom_up,attrib)
    	    end
***0	    if bottom_up then yield(root,dirs,files) end
    	end
    	
    	--- return an iterator which walks through a directory tree starting at root.
    	-- The iterator returns (root,dirs,files)
    	-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
    	-- to get the actual full path)
    	-- If bottom_up is false (or not present), then the entries at the current level are returned
    	-- before we go deeper. This means that you can modify the returned list of directories before
    	-- continuing.
    	-- This is a clone of os.walk from the Python libraries.
    	-- @string root A starting directory
    	-- @bool bottom_up False if we start listing entries immediately.
    	-- @bool follow_links follow symbolic links
    	-- @return an iterator returning root,dirs,files
    	-- @raise root must be a directory
   1	function dir.walk(root,bottom_up,follow_links)
***0	    assert_dir(1,root)
    	    local attrib
***0	    if path.is_windows or not follow_links then
***0	        attrib = path.attrib
    	    else
***0	        attrib = path.link_attrib
    	    end
***0	    return wrap(function () _walker(root,bottom_up,attrib) end)
    	end
    	
    	--- remove a whole directory tree.
    	-- @string fullpath A directory path
    	-- @return true or nil
    	-- @return error if failed
    	-- @raise fullpath must be a string
   1	function dir.rmtree(fullpath)
***0	    assert_dir(1,fullpath)
***0	    if path.islink(fullpath) then return false,'will not follow symlink' end
***0	    for root,dirs,files in dir.walk(fullpath,true) do
***0	        for i,f in ipairs(files) do
***0	            remove(path.join(root,f))
    	        end
***0	        rmdir(root)
    	    end
***0	    return true
    	end
    	
    	local dirpat
   1	if path.is_windows then
***0	    dirpat = '(.+)\\[^\\]+$'
    	else
   1	    dirpat = '(.+)/[^/]+$'
    	end
    	
    	local _makepath
   1	function _makepath(p)
    	    -- windows root drive case
***0	    if p:find '^%a:[\\]*$' then
***0	        return true
    	    end
***0	   if not path.isdir(p) then
***0	    local subp = p:match(dirpat)
***0	    local ok, err = _makepath(subp)
***0	    if not ok then return nil, err end
***0	    return mkdir(p)
    	   else
***0	    return true
    	   end
    	end
    	
    	--- create a directory path.
    	-- This will create subdirectories as necessary!
    	-- @string p A directory path
    	-- @return true on success, nil + errormsg on failure
    	-- @raise failure to create
   1	function dir.makepath (p)
***0	    assert_string(1,p)
***0	    return _makepath(path.normcase(path.abspath(p)))
    	end
    	
    	
    	--- clone a directory tree. Will always try to create a new directory structure
    	-- if necessary.
    	-- @string path1 the base path of the source tree
    	-- @string path2 the new base path for the destination
    	-- @func file_fun an optional function to apply on all files
    	-- @bool verbose an optional boolean to control the verbosity of the output.
    	--  It can also be a logging function that behaves like print()
    	-- @return true, or nil
    	-- @return error message, or list of failed directory creations
    	-- @return list of failed file operations
    	-- @raise path1 and path2 must be strings
    	-- @usage clonetree('.','../backup',copyfile)
   1	function dir.clonetree (path1,path2,file_fun,verbose)
***0	    assert_string(1,path1)
***0	    assert_string(2,path2)
***0	    if verbose == true then verbose = print end
***0	    local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
***0	    local faildirs,failfiles = {},{}
***0	    if not isdir(path1) then return raise 'source is not a valid directory' end
***0	    path1 = abspath(normcase(path1))
***0	    path2 = abspath(normcase(path2))
***0	    if verbose then verbose('normalized:',path1,path2) end
    	    -- particularly NB that the new path isn't fully contained in the old path
***0	    if path1 == path2 then return raise "paths are the same" end
***0	    local i1,i2 = path2:find(path1,1,true)
***0	    if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
***0	        return raise 'destination is a subdirectory of the source'
    	    end
***0	    local cp = path.common_prefix (path1,path2)
***0	    local idx = #cp
***0	    if idx == 0 then -- no common path, but watch out for Windows paths!
***0	        if path1:sub(2,2) == ':' then idx = 3 end
    	    end
***0	    for root,dirs,files in dir.walk(path1) do
***0	        local opath = path2..root:sub(idx)
***0	        if verbose then verbose('paths:',opath,root) end
***0	        if not isdir(opath) then
***0	            local ret = dir.makepath(opath)
***0	            if not ret then append(faildirs,opath) end
***0	            if verbose then verbose('creating:',opath,ret) end
    	        end
***0	        if file_fun then
***0	            for i,f in ipairs(files) do
***0	                local p1 = join(root,f)
***0	                local p2 = join(opath,f)
***0	                local ret = file_fun(p1,p2)
***0	                if not ret then append(failfiles,p2) end
***0	                if verbose then
***0	                    verbose('files:',p1,p2,ret)
    	                end
    	            end
    	        end
    	    end
***0	    return true,faildirs,failfiles
    	end
    	
    	--- return an iterator over all entries in a directory tree
    	-- @string d a directory
    	-- @return an iterator giving pathname and mode (true for dir, false otherwise)
    	-- @raise d must be a non-empty string
   1	function dir.dirtree( d )
   1	    assert( d and d ~= "", "directory parameter is missing or empty" )
   1	    local exists, isdir = path.exists, path.isdir
   1	    local sep = path.sep
    	
   1	    local last = sub ( d, -1 )
   1	    if last == sep or last == '/' then
***0	        d = sub( d, 1, -2 )
    	    end
    	
    	    local function yieldtree( dir )
   4	        for entry in ldir( dir ) do
   3	            if entry ~= "." and entry ~= ".." then
   1	                entry = dir .. sep .. entry
   1	                if exists(entry) then  -- Just in case a symlink is broken.
   1	                    local is_dir = isdir(entry)
   1	                    yield( entry, is_dir )
   1	                    if is_dir then
***0	                        yieldtree( entry )
    	                    end
    	                end
    	            end
    	        end
    	    end
    	
   2	    return wrap( function() yieldtree( d ) end )
    	end
    	
    	
    	---	Recursively returns all the file starting at _path_. It can optionally take a shell pattern and
    	--	only returns files that match _pattern_. If a pattern is given it will do a case insensitive search.
    	--	@string start_path  A directory. If not given, all files in current directory are returned.
    	--	@string pattern A shell pattern. If not given, all files are returned.
    	--	@treturn List(string) containing all the files found recursively starting at _path_ and filtered by _pattern_.
    	-- @raise start_path must be a directory
   1	function dir.getallfiles( start_path, pattern )
   1	    assert_dir(1,start_path)
   1	    pattern = pattern or ""
    	
   1	    local files = {}
   1	    local normcase = path.normcase
   2	    for filename, mode in dir.dirtree( start_path ) do
   1	        if not mode then
   1	            local mask = filemask( pattern )
   1	            if normcase(filename):find( mask ) then
   1	                files[#files + 1] = filename
    	            end
    	        end
    	    end
    	
   1	    return setmetatable(files,List)
    	end
    	
   1	return dir

==============================================================================
/usr/local/share/lua/5.2/pl/path.lua
==============================================================================
    	--- Path manipulation and file queries.
    	--
    	-- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
    	--
    	-- Dependencies: `pl.utils`, `lfs`
    	-- @module pl.path
    	
    	-- imports and locals
***0	local _G = _G
***0	local sub = string.sub
***0	local getenv = os.getenv
***0	local tmpnam = os.tmpname
    	local attributes, currentdir, link_attrib
***0	local package = package
***0	local io = io
***0	local append = table.insert
***0	local ipairs = ipairs
***0	local utils = require 'pl.utils'
***0	local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise
    	
    	local attrib
***0	local path = {}
    	
***0	local res,lfs = _G.pcall(_G.require,'lfs')
***0	if res then
***0	    attributes = lfs.attributes
***0	    currentdir = lfs.currentdir
***0	    link_attrib = lfs.symlinkattributes
    	else
***0	    error("pl.path requires LuaFileSystem")
    	end
    	
***0	attrib = attributes
***0	path.attrib = attrib
***0	path.link_attrib = link_attrib
    	
    	--- Lua iterator over the entries of a given directory.
    	-- Behaves like `lfs.dir`
***0	path.dir = lfs.dir
    	
    	--- Creates a directory.
***0	path.mkdir = lfs.mkdir
    	
    	--- Removes a directory.
***0	path.rmdir = lfs.rmdir
    	
    	---- Get the working directory.
***0	path.currentdir = currentdir
    	
    	--- Changes the working directory.
***0	path.chdir = lfs.chdir
    	
    	
    	--- is this a directory?
    	-- @string P A file path
***0	function path.isdir(P)
   3		assert_string(1,P)
   3	    if P:match("\\$") then
***0	        P = P:sub(1,-2)
    	    end
   3	    return attrib(P,'mode') == 'directory'
    	end
    	
    	--- is this a file?.
    	-- @string P A file path
***0	function path.isfile(P)
   1		assert_string(1,P)
   1	    return attrib(P,'mode') == 'file'
    	end
    	
    	-- is this a symbolic link?
    	-- @string P A file path
***0	function path.islink(P)
***0		assert_string(1,P)
***0	    if link_attrib then
***0	        return link_attrib(P,'mode')=='link'
    	    else
***0	        return false
    	    end
    	end
    	
    	--- return size of a file.
    	-- @string P A file path
***0	function path.getsize(P)
***0		assert_string(1,P)
***0	    return attrib(P,'size')
    	end
    	
    	--- does a path exist?.
    	-- @string P A file path
    	-- @return the file path if it exists, nil otherwise
***0	function path.exists(P)
   1		assert_string(1,P)
   1	    return attrib(P,'mode') ~= nil and P
    	end
    	
    	--- Return the time of last access as the number of seconds since the epoch.
    	-- @string P A file path
***0	function path.getatime(P)
***0		assert_string(1,P)
***0	    return attrib(P,'access')
    	end
    	
    	--- Return the time of last modification
    	-- @string P A file path
***0	function path.getmtime(P)
***0	    return attrib(P,'modification')
    	end
    	
    	---Return the system's ctime.
    	-- @string P A file path
***0	function path.getctime(P)
***0		assert_string(1,P)
***0	    return path.attrib(P,'change')
    	end
    	
    	
    	local function at(s,i)
 307	    return sub(s,i,i)
    	end
    	
***0	path.is_windows = utils.dir_separator == '\\'
    	
    	local other_sep
    	-- !constant sep is the directory separator for this platform.
***0	if path.is_windows then
***0	    path.sep = '\\'; other_sep = '/'
***0	    path.dirsep = ';'
    	else
***0	    path.sep = '/'
***0	    path.dirsep = ':'
    	end
***0	local sep,dirsep = path.sep,path.dirsep
    	
    	--- are we running Windows?
    	-- @class field
    	-- @name path.is_windows
    	
    	--- path separator for this platform.
    	-- @class field
    	-- @name path.sep
    	
    	--- separator for PATH for this platform
    	-- @class field
    	-- @name path.dirsep
    	
    	--- given a path, return the directory part and a file part.
    	-- if there's no directory part, the first value will be empty
    	-- @string P A file path
***0	function path.splitpath(P)
  25	    assert_string(1,P)
  25	    local i = #P
  25	    local ch = at(P,i)
 303	    while i > 0 and ch ~= sep and ch ~= other_sep do
 278	        i = i - 1
 278	        ch = at(P,i)
    	    end
  25	    if i == 0 then
***0	        return '',P
    	    else
  25	        return sub(P,1,i-1), sub(P,i+1)
    	    end
    	end
    	
    	--- return an absolute path.
    	-- @string P A file path
    	-- @string[opt] pwd optional start path to use (default is current dir)
***0	function path.abspath(P,pwd)
***0	    assert_string(1,P)
***0		if pwd then assert_string(2,pwd) end
***0	    local use_pwd = pwd ~= nil
***0	    if not use_pwd and not currentdir then return P end
***0	    P = P:gsub('[\\/]$','')
***0	    pwd = pwd or currentdir()
***0	    if not path.isabs(P) then
***0	        P = path.join(pwd,P)
***0	    elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
***0	        P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
    	    end
***0	    return path.normpath(P)
    	end
    	
    	--- given a path, return the root part and the extension part.
    	-- if there's no extension part, the second value will be empty
    	-- @string P A file path
    	-- @treturn string root part
    	-- @treturn string extension part (maybe empty)
***0	function path.splitext(P)
   1	    assert_string(1,P)
   1	    local i = #P
   1	    local ch = at(P,i)
   4	    while i > 0 and ch ~= '.' do
   3	        if ch == sep or ch == other_sep then
***0	            return P,''
    	        end
   3	        i = i - 1
   3	        ch = at(P,i)
    	    end
   1	    if i == 0 then
***0	        return P,''
    	    else
   1	        return sub(P,1,i-1),sub(P,i)
    	    end
    	end
    	
    	--- return the directory part of a path
    	-- @string P A file path
***0	function path.dirname(P)
  24	    assert_string(1,P)
  24	    local p1,p2 = path.splitpath(P)
  24	    return p1
    	end
    	
    	--- return the file part of a path
    	-- @string P A file path
***0	function path.basename(P)
   1	    assert_string(1,P)
   1	    local p1,p2 = path.splitpath(P)
   1	    return p2
    	end
    	
    	--- get the extension part of a path.
    	-- @string P A file path
***0	function path.extension(P)
   1	    assert_string(1,P)
   1	    local p1,p2 = path.splitext(P)
   1	    return p2
    	end
    	
    	--- is this an absolute path?.
    	-- @string P A file path
***0	function path.isabs(P)
***0	    assert_string(1,P)
***0	    if path.is_windows then
***0	        return at(P,1) == '/' or at(P,1)=='\\' or at(P,2)==':'
    	    else
***0	        return at(P,1) == '/'
    	    end
    	end
    	
    	--- return the path resulting from combining the individual paths.
    	-- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
    	-- empty elements (except the last) will be ignored.
    	-- @string p1 A file path
    	-- @string p2 A file path
    	-- @string ... more file paths
***0	function path.join(p1,p2,...)
***0	    assert_string(1,p1)
***0	    assert_string(2,p2)
***0	    if select('#',...) > 0 then
***0	        local p = path.join(p1,p2)
***0	        local args = {...}
***0	        for i = 1,#args do
***0	            assert_string(i,args[i])
***0	            p = path.join(p,args[i])
    	        end
***0	        return p
    	    end
***0	    if path.isabs(p2) then return p2 end
***0	    local endc = at(p1,#p1)
***0	    if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
***0	        p1 = p1..path.sep
    	    end
***0	    return p1..p2
    	end
    	
    	--- normalize the case of a pathname. On Unix, this returns the path unchanged;
    	--  for Windows, it converts the path to lowercase, and it also converts forward slashes
    	-- to backward slashes.
    	-- @string P A file path
***0	function path.normcase(P)
   1	    assert_string(1,P)
   1	    if path.is_windows then
***0	        return (P:lower():gsub('/','\\'))
    	    else
   1	        return P
    	    end
    	end
    	
***0	local np_gen1,np_gen2 = '([^SEP]+)SEP(%.%.SEP?)','SEP+%.?SEP'
    	local np_pat1, np_pat2
    	
    	--- normalize a path name.
    	--  A//B, A/./B and A/foo/../B all become A/B.
    	-- @string P a file path
***0	function path.normpath(P)
***0	    assert_string(1,P)
***0	    if path.is_windows then
***0	        if P:match '^\\\\' then -- UNC
***0	            return '\\\\'..path.normpath(P:sub(3))
    	        end
***0	        P = P:gsub('/','\\')
    	    end
***0	    if not np_pat1 then
***0	        np_pat1 = np_gen1:gsub('SEP',sep)
***0	        np_pat2 = np_gen2:gsub('SEP',sep)
    	    end
    	    local k
    	    repeat -- /./ -> /
***0	        P,k = P:gsub(np_pat2,sep)
***0	    until k == 0
    	    repeat -- A/../ -> (empty)
***0	        local oldP = P
***0	        P,k = P:gsub(np_pat1,function(D, up)
***0	            if D == '..' then return nil end
***0	            if D == '.' then return up end
***0	            return ''
    	        end)
***0	    until k == 0 or oldP == P
***0	    if P == '' then P = '.' end
***0	    return P
    	end
    	
    	local function ATS (P)
***0	    if at(P,#P) ~= path.sep then
***0	        P = P..path.sep
    	    end
***0	    return path.normcase(P)
    	end
    	
    	--- relative path from current directory or optional start point
    	-- @string P a path
    	-- @string[opt] start optional start point (default current directory)
***0	function path.relpath (P,start)
***0	    assert_string(1,P)
***0		if start then assert_string(2,start) end
***0	    local split,normcase,min,append = utils.split, path.normcase, math.min, table.insert
***0	    P = normcase(path.abspath(P,start))
***0	    start = start or currentdir()
***0	    start = normcase(start)
***0	    local startl, Pl = split(start,sep), split(P,sep)
***0	    local n = min(#startl,#Pl)
***0	    local k = n+1 -- default value if this loop doesn't bail out!
***0	    for i = 1,n do
***0	        if startl[i] ~= Pl[i] then
***0	            k = i
    	            break
    	        end
    	    end
***0	    local rell = {}
***0	    for i = 1, #startl-k+1 do rell[i] = '..' end
***0	    if k <= #Pl then
***0	        for i = k,#Pl do append(rell,Pl[i]) end
    	    end
***0	    return table.concat(rell,sep)
    	end
    	
    	
    	--- Replace a starting '~' with the user's home directory.
    	-- In windows, if HOME isn't set, then USERPROFILE is used in preference to
    	-- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
    	-- @string P A file path
***0	function path.expanduser(P)
***0	    assert_string(1,P)
***0	    if at(P,1) == '~' then
***0	        local home = getenv('HOME')
***0	        if not home then -- has to be Windows
***0	            home = getenv 'USERPROFILE' or (getenv 'HOMEDRIVE' .. getenv 'HOMEPATH')
    	        end
***0	        return home..sub(P,2)
    	    else
***0	        return P
    	    end
    	end
    	
    	
    	---Return a suitable full path to a new temporary file name.
    	-- unlike os.tmpnam(), it always gives you a writeable path (uses TEMP environment variable on Windows)
***0	function path.tmpname ()
***0	    local res = tmpnam()
***0	    if path.is_windows then res = getenv('TEMP')..res end
***0	    return res
    	end
    	
    	--- return the largest common prefix path of two paths.
    	-- @string path1 a file path
    	-- @string path2 a file path
***0	function path.common_prefix (path1,path2)
***0	    assert_string(1,path1)
***0	    assert_string(2,path2)
***0	    path1, path2 = path.normcase(path1), path.normcase(path2)
    	    -- get them in order!
***0	    if #path1 > #path2 then path2,path1 = path1,path2 end
***0	    for i = 1,#path1 do
***0	        local c1 = at(path1,i)
***0	        if c1 ~= at(path2,i) then
***0	            local cp = path1:sub(1,i-1)
***0	            if at(path1,i-1) ~= sep then
***0	                cp = path.dirname(cp)
    	            end
***0	            return cp
    	        end
    	    end
***0	    if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
***0	    return path1
    	    --return ''
    	end
    	
    	--- return the full path where a particular Lua module would be found.
    	-- Both package.path and package.cpath is searched, so the result may
    	-- either be a Lua file or a shared library.
    	-- @string mod name of the module
    	-- @return on success: path of module, lua or binary
    	-- @return on error: nil,error string
***0	function path.package_path(mod)
***0	    assert_string(1,mod)
    	    local res
***0	    mod = mod:gsub('%.',sep)
***0	    res = package.searchpath(mod,package.path)
***0	    if res then return res,true end
***0	    res = package.searchpath(mod,package.cpath)
***0	    if res then return res,false end
***0	    return raise 'cannot find module on path'
    	end
    	
    	
    	---- finis -----
***0	return path

==============================================================================
/usr/local/share/lua/5.2/pl/tablex.lua
==============================================================================
    	--- Extended operations on Lua tables.
    	--
    	-- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
    	--
    	-- Dependencies: `pl.utils`, `pl.types`
    	-- @module pl.tablex
***0	local utils = require ('pl.utils')
***0	local types = require ('pl.types')
***0	local getmetatable,setmetatable,require = getmetatable,setmetatable,require
***0	local tsort,append,remove = table.sort,table.insert,table.remove
***0	local min,max = math.min,math.max
***0	local pairs,type,unpack,next,select,tostring = pairs,type,utils.unpack,next,select,tostring
***0	local function_arg = utils.function_arg
***0	local Set = utils.stdmt.Set
***0	local List = utils.stdmt.List
***0	local Map = utils.stdmt.Map
***0	local assert_arg = utils.assert_arg
    	
***0	local tablex = {}
    	
    	-- generally, functions that make copies of tables try to preserve the metatable.
    	-- However, when the source has no obvious type, then we attach appropriate metatables
    	-- like List, Map, etc to the result.
    	local function setmeta (res,tbl,def)
   2	    local mt = getmetatable(tbl) or def
   2	    return setmetatable(res, mt)
    	end
    	
    	local function makelist (res)
***0	    return setmetatable(res,List)
    	end
    	
    	local function complain (idx,msg)
***0	    error(('argument %d is not %s'):format(idx,msg),3)
    	end
    	
    	local function assert_arg_indexable (idx,val)
   2	    if not types.is_indexable(val) then
***0	        complain(idx,"indexable")
    	    end
    	end
    	
    	local function assert_arg_iterable (idx,val)
   1	    if not types.is_iterable(val) then
***0	        complain(idx,"iterable")
    	    end
    	end
    	
    	local function assert_arg_writeable (idx,val)
***0	    if not types.is_writeable(val) then
***0	        complain(idx,"writeable")
    	    end
    	end
    	
    	--- copy a table into another, in-place.
    	-- @within Copying
    	-- @tab t1 destination table
    	-- @tab t2 source (actually any iterable object)
    	-- @return first table
***0	function tablex.update (t1,t2)
***0	    assert_arg_writeable(1,t1)
***0	    assert_arg_iterable(2,t2)
***0	    for k,v in pairs(t2) do
***0	        t1[k] = v
    	    end
***0	    return t1
    	end
    	
    	--- total number of elements in this table.
    	-- Note that this is distinct from `#t`, which is the number
    	-- of values in the array part; this value will always
    	-- be greater or equal. The difference gives the size of
    	-- the hash part, for practical purposes. Works for any
    	-- object with a __pairs metamethod.
    	-- @tab t a table
    	-- @return the size
***0	function tablex.size (t)
***0	    assert_arg_iterable(1,t)
***0	    local i = 0
***0	    for k in pairs(t) do i = i + 1 end
***0	    return i
    	end
    	
    	--- make a shallow copy of a table
    	-- @within Copying
    	-- @tab t an iterable source
    	-- @return new table
***0	function tablex.copy (t)
   1	    assert_arg_iterable(1,t)
   1	    local res = {}
 108	    for k,v in pairs(t) do
 107	        res[k] = v
    	    end
   1	    return res
    	end
    	
    	--- make a deep copy of a table, recursively copying all the keys and fields.
    	-- This will also set the copied table's metatable to that of the original.
    	-- @within Copying
    	-- @tab t A table
    	-- @return new table
***0	function tablex.deepcopy(t)
***0	    if type(t) ~= 'table' then return t end
***0	    assert_arg_iterable(1,t)
***0	    local mt = getmetatable(t)
***0	    local res = {}
***0	    for k,v in pairs(t) do
***0	        if type(v) == 'table' then
***0	            v = tablex.deepcopy(v)
    	        end
***0	        res[k] = v
    	    end
***0	    setmetatable(res,mt)
***0	    return res
    	end
    	
***0	local abs, deepcompare = math.abs
    	
    	--- compare two values.
    	-- if they are tables, then compare their keys and fields recursively.
    	-- @within Comparing
    	-- @param t1 A value
    	-- @param t2 A value
    	-- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)
    	-- @number[opt] eps if defined, then used for any number comparisons
    	-- @return true or false
***0	function tablex.deepcompare(t1,t2,ignore_mt,eps)
***0	    local ty1 = type(t1)
***0	    local ty2 = type(t2)
***0	    if ty1 ~= ty2 then return false end
    	    -- non-table types can be directly compared
***0	    if ty1 ~= 'table' then
***0	        if ty1 == 'number' and eps then return abs(t1-t2) < eps end
***0	        return t1 == t2
    	    end
    	    -- as well as tables which have the metamethod __eq
***0	    local mt = getmetatable(t1)
***0	    if not ignore_mt and mt and mt.__eq then return t1 == t2 end
***0	    for k1 in pairs(t1) do
***0	        if t2[k1]==nil then return false end
    	    end
***0	    for k2 in pairs(t2) do
***0	        if t1[k2]==nil then return false end
    	    end
***0	    for k1,v1 in pairs(t1) do
***0	        local v2 = t2[k1]
***0	        if not deepcompare(v1,v2,ignore_mt,eps) then return false end
    	    end
    	
***0	    return true
    	end
    	
***0	deepcompare = tablex.deepcompare
    	
    	--- compare two arrays using a predicate.
    	-- @within Comparing
    	-- @array t1 an array
    	-- @array t2 an array
    	-- @func cmp A comparison function
***0	function tablex.compare (t1,t2,cmp)
***0	    assert_arg_indexable(1,t1)
***0	    assert_arg_indexable(2,t2)
***0	    if #t1 ~= #t2 then return false end
***0	    cmp = function_arg(3,cmp)
***0	    for k = 1,#t1 do
***0	        if not cmp(t1[k],t2[k]) then return false end
    	    end
***0	    return true
    	end
    	
    	--- compare two list-like tables using an optional predicate, without regard for element order.
    	-- @within Comparing
    	-- @array t1 a list-like table
    	-- @array t2 a list-like table
    	-- @param cmp A comparison function (may be nil)
***0	function tablex.compare_no_order (t1,t2,cmp)
***0	    assert_arg_indexable(1,t1)
***0	    assert_arg_indexable(2,t2)
***0	    if cmp then cmp = function_arg(3,cmp) end
***0	    if #t1 ~= #t2 then return false end
***0	    local visited = {}
***0	    for i = 1,#t1 do
***0	        local val = t1[i]
    	        local gotcha
***0	        for j = 1,#t2 do if not visited[j] then
    	            local match
***0	            if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
***0	            if match then
***0	                gotcha = j
    	                break
    	            end
***0	        end end
***0	        if not gotcha then return false end
***0	        visited[gotcha] = true
    	    end
***0	    return true
    	end
    	
    	
    	--- return the index of a value in a list.
    	-- Like string.find, there is an optional index to start searching,
    	-- which can be negative.
    	-- @within Finding
    	-- @array t A list-like table
    	-- @param val A value
    	-- @int idx index to start; -1 means last element,etc (default 1)
    	-- @return index of value or nil if not found
    	-- @usage find({10,20,30},20) == 2
    	-- @usage find({'a','b','a','c'},'a',2) == 3
***0	function tablex.find(t,val,idx)
***0	    assert_arg_indexable(1,t)
***0	    idx = idx or 1
***0	    if idx < 0 then idx = #t + idx + 1 end
***0	    for i = idx,#t do
***0	        if t[i] == val then return i end
    	    end
***0	    return nil
    	end
    	
    	--- return the index of a value in a list, searching from the end.
    	-- Like string.find, there is an optional index to start searching,
    	-- which can be negative.
    	-- @within Finding
    	-- @array t A list-like table
    	-- @param val A value
    	-- @param idx index to start; -1 means last element,etc (default 1)
    	-- @return index of value or nil if not found
    	-- @usage rfind({10,10,10},10) == 3
***0	function tablex.rfind(t,val,idx)
***0	    assert_arg_indexable(1,t)
***0	    idx = idx or #t
***0	    if idx < 0 then idx = #t + idx + 1 end
***0	    for i = idx,1,-1 do
***0	        if t[i] == val then return i end
    	    end
***0	    return nil
    	end
    	
    	
    	--- return the index (or key) of a value in a table using a comparison function.
    	-- @within Finding
    	-- @tab t A table
    	-- @func cmp A comparison function
    	-- @param arg an optional second argument to the function
    	-- @return index of value, or nil if not found
    	-- @return value returned by comparison function
***0	function tablex.find_if(t,cmp,arg)
***0	    assert_arg_iterable(1,t)
***0	    cmp = function_arg(2,cmp)
***0	    for k,v in pairs(t) do
***0	        local c = cmp(v,arg)
***0	        if c then return k,c end
    	    end
***0	    return nil
    	end
    	
    	--- return a list of all values in a table indexed by another list.
    	-- @tab tbl a table
    	-- @array idx an index table (a list of keys)
    	-- @return a list-like table
    	-- @usage index_by({10,20,30,40},{2,4}) == {20,40}
    	-- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
***0	function tablex.index_by(tbl,idx)
***0	    assert_arg_indexable(1,tbl)
***0	    assert_arg_indexable(2,idx)
***0	    local res = {}
***0	    for i = 1,#idx do
***0	        res[i] = tbl[idx[i]]
    	    end
***0	    return setmeta(res,tbl,List)
    	end
    	
    	--- apply a function to all values of a table.
    	-- This returns a table of the results.
    	-- Any extra arguments are passed to the function.
    	-- @within MappingAndFiltering
    	-- @func fun A function that takes at least one argument
    	-- @tab t A table
    	-- @param ... optional arguments
    	-- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
***0	function tablex.map(fun,t,...)
***0	    assert_arg_iterable(1,t)
***0	    fun = function_arg(1,fun)
***0	    local res = {}
***0	    for k,v in pairs(t) do
***0	        res[k] = fun(v,...)
    	    end
***0	    return setmeta(res,t)
    	end
    	
    	--- apply a function to all values of a list.
    	-- This returns a table of the results.
    	-- Any extra arguments are passed to the function.
    	-- @within MappingAndFiltering
    	-- @func fun A function that takes at least one argument
    	-- @array t a table (applies to array part)
    	-- @param ... optional arguments
    	-- @return a list-like table
    	-- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
***0	function tablex.imap(fun,t,...)
***0	    assert_arg_indexable(1,t)
***0	    fun = function_arg(1,fun)
***0	    local res = {}
***0	    for i = 1,#t do
***0	        res[i] = fun(t[i],...) or false
    	    end
***0	    return setmeta(res,t,List)
    	end
    	
    	--- apply a named method to values from a table.
    	-- @within MappingAndFiltering
    	-- @string name the method name
    	-- @array t a list-like table
    	-- @param ... any extra arguments to the method
***0	function tablex.map_named_method (name,t,...)
***0	    utils.assert_string(1,name)
***0	    assert_arg_indexable(2,t)
***0	    local res = {}
***0	    for i = 1,#t do
***0	        local val = t[i]
***0	        local fun = val[name]
***0	        res[i] = fun(val,...)
    	    end
***0	    return setmeta(res,t,List)
    	end
    	
    	--- apply a function to all values of a table, in-place.
    	-- Any extra arguments are passed to the function.
    	-- @func fun A function that takes at least one argument
    	-- @tab t a table
    	-- @param ... extra arguments
***0	function tablex.transform (fun,t,...)
***0	    assert_arg_iterable(1,t)
***0	    fun = function_arg(1,fun)
***0	    for k,v in pairs(t) do
***0	        t[k] = fun(v,...)
    	    end
    	end
    	
    	--- generate a table of all numbers in a range.
    	-- This is consistent with a numerical for loop.
    	-- @int start  number
    	-- @int finish number
    	-- @int[opt=1] step  make this negative for start < finish
***0	function tablex.range (start,finish,step)
    	    local res
***0	    step = step or 1
***0	    if start == finish then
***0	        res = {start}
***0	    elseif (start > finish and step > 0) or (finish > start and step < 0) then
***0	        res = {}
    	    else
***0	        local k = 1
***0	        res = {}
***0	        for i=start,finish,step do res[k]=i; k=k+1 end
    	    end
***0	    return makelist(res)
    	end
    	
    	--- apply a function to values from two tables.
    	-- @within MappingAndFiltering
    	-- @func fun a function of at least two arguments
    	-- @tab t1 a table
    	-- @tab t2 a table
    	-- @param ... extra arguments
    	-- @return a table
    	-- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
***0	function tablex.map2 (fun,t1,t2,...)
***0	    assert_arg_iterable(1,t1)
***0	    assert_arg_iterable(2,t2)
***0	    fun = function_arg(1,fun)
***0	    local res = {}
***0	    for k,v in pairs(t1) do
***0	        res[k] = fun(v,t2[k],...)
    	    end
***0	    return setmeta(res,t1,List)
    	end
    	
    	--- apply a function to values from two arrays.
    	-- The result will be the length of the shortest array.
    	-- @within MappingAndFiltering
    	-- @func fun a function of at least two arguments
    	-- @array t1 a list-like table
    	-- @array t2 a list-like table
    	-- @param ... extra arguments
    	-- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
***0	function tablex.imap2 (fun,t1,t2,...)
***0	    assert_arg_indexable(2,t1)
***0	    assert_arg_indexable(3,t2)
***0	    fun = function_arg(1,fun)
***0	    local res,n = {},math.min(#t1,#t2)
***0	    for i = 1,n do
***0	        res[i] = fun(t1[i],t2[i],...)
    	    end
***0	    return res
    	end
    	
    	--- 'reduce' a list using a binary function.
    	-- @func fun a function of two arguments
    	-- @array t a list-like table
    	-- @return the result of the function
    	-- @usage reduce('+',{1,2,3,4}) == 10
***0	function tablex.reduce (fun,t)
***0	    assert_arg_indexable(2,t)
***0	    fun = function_arg(1,fun)
***0	    local n = #t
***0	    local res = t[1]
***0	    for i = 2,n do
***0	        res = fun(res,t[i])
    	    end
***0	    return res
    	end
    	
    	--- apply a function to all elements of a table.
    	-- The arguments to the function will be the value,
    	-- the key and _finally_ any extra arguments passed to this function.
    	-- Note that the Lua 5.0 function table.foreach passed the _key_ first.
    	-- @within Iterating
    	-- @tab t a table
    	-- @func fun a function with at least one argument
    	-- @param ... extra arguments
***0	function tablex.foreach(t,fun,...)
***0	    assert_arg_iterable(1,t)
***0	    fun = function_arg(2,fun)
***0	    for k,v in pairs(t) do
***0	        fun(v,k,...)
    	    end
    	end
    	
    	--- apply a function to all elements of a list-like table in order.
    	-- The arguments to the function will be the value,
    	-- the index and _finally_ any extra arguments passed to this function
    	-- @within Iterating
    	-- @array t a table
    	-- @func fun a function with at least one argument
    	-- @param ... optional arguments
***0	function tablex.foreachi(t,fun,...)
***0	    assert_arg_indexable(1,t)
***0	    fun = function_arg(2,fun)
***0	    for i = 1,#t do
***0	        fun(t[i],i,...)
    	    end
    	end
    	
    	--- Apply a function to a number of tables.
    	-- A more general version of map
    	-- The result is a table containing the result of applying that function to the
    	-- ith value of each table. Length of output list is the minimum length of all the lists
    	-- @within MappingAndFiltering
    	-- @func fun a function of n arguments
    	-- @tab ... n tables
    	-- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
    	-- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is	{100,200,300}
    	-- @param fun A function that takes as many arguments as there are tables
***0	function tablex.mapn(fun,...)
***0	    fun = function_arg(1,fun)
***0	    local res = {}
***0	    local lists = {...}
***0	    local minn = 1e40
***0	    for i = 1,#lists do
***0	        minn = min(minn,#(lists[i]))
    	    end
***0	    for i = 1,minn do
***0	        local args,k = {},1
***0	        for j = 1,#lists do
***0	            args[k] = lists[j][i]
***0	            k = k + 1
    	        end
***0	        res[#res+1] = fun(unpack(args))
    	    end
***0	    return res
    	end
    	
    	--- call the function with the key and value pairs from a table.
    	-- The function can return a value and a key (note the order!). If both
    	-- are not nil, then this pair is inserted into the result. If only value is not nil, then
    	-- it is appended to the result.
    	-- @within MappingAndFiltering
    	-- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
    	-- @tab t A table
    	-- @param ... optional arguments
    	-- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
    	-- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
***0	function tablex.pairmap(fun,t,...)
***0	    assert_arg_iterable(1,t)
***0	    fun = function_arg(1,fun)
***0	    local res = {}
***0	    for k,v in pairs(t) do
***0	        local rv,rk = fun(k,v,...)
***0	        if rk then
***0	            res[rk] = rv
    	        else
***0	            res[#res+1] = rv
    	        end
    	    end
***0	    return res
    	end
    	
***0	local function keys_op(i,v) return i end
    	
    	--- return all the keys of a table in arbitrary order.
    	-- @within Extraction
    	--  @tab t A table
***0	function tablex.keys(t)
***0	    assert_arg_iterable(1,t)
***0	    return makelist(tablex.pairmap(keys_op,t))
    	end
    	
***0	local function values_op(i,v) return v end
    	
    	--- return all the values of the table in arbitrary order
    	-- @within Extraction
    	--  @tab t A table
***0	function tablex.values(t)
***0	    assert_arg_iterable(1,t)
***0	    return makelist(tablex.pairmap(values_op,t))
    	end
    	
    	local function index_map_op (i,v) return i,v end
    	
    	--- create an index map from a list-like table. The original values become keys,
    	-- and the associated values are the indices into the original list.
    	-- @array t a list-like table
    	-- @return a map-like table
***0	function tablex.index_map (t)
***0	    assert_arg_indexable(1,t)
***0	    return setmetatable(tablex.pairmap(index_map_op,t),Map)
    	end
    	
    	local function set_op(i,v) return true,v end
    	
    	--- create a set from a list-like table. A set is a table where the original values
    	-- become keys, and the associated values are all true.
    	-- @array t a list-like table
    	-- @return a set (a map-like table)
***0	function tablex.makeset (t)
***0	    assert_arg_indexable(1,t)
***0	    return setmetatable(tablex.pairmap(set_op,t),Set)
    	end
    	
    	--- combine two tables, either as union or intersection. Corresponds to
    	-- set operations for sets () but more general. Not particularly
    	-- useful for list-like tables.
    	-- @within Merging
    	-- @tab t1 a table
    	-- @tab t2 a table
    	-- @bool dup true for a union, false for an intersection.
    	-- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
    	-- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
    	-- @see tablex.index_map
***0	function tablex.merge (t1,t2,dup)
***0	    assert_arg_iterable(1,t1)
***0	    assert_arg_iterable(2,t2)
***0	    local res = {}
***0	    for k,v in pairs(t1) do
***0	        if dup or t2[k] then res[k] = v end
    	    end
***0	    if dup then
***0	      for k,v in pairs(t2) do
***0	        res[k] = v
    	      end
    	    end
***0	    return setmeta(res,t1,Map)
    	end
    	
    	--- a new table which is the difference of two tables.
    	-- With sets (where the values are all true) this is set difference and
    	-- symmetric difference depending on the third parameter.
    	-- @within Merging
    	-- @tab s1 a map-like table or set
    	-- @tab s2 a map-like table or set
    	-- @bool symm symmetric difference (default false)
    	-- @return a map-like table or set
***0	function tablex.difference (s1,s2,symm)
***0	    assert_arg_iterable(1,s1)
***0	    assert_arg_iterable(2,s2)
***0	    local res = {}
***0	    for k,v in pairs(s1) do
***0	        if s2[k] == nil then res[k] = v end
    	    end
***0	    if symm then
***0	        for k,v in pairs(s2) do
***0	            if s1[k] == nil then res[k] = v end
    	        end
    	    end
***0	    return setmeta(res,s1,Map)
    	end
    	
    	--- A table where the key/values are the values and value counts of the table.
    	-- @array t a list-like table
    	-- @func cmp a function that defines equality (otherwise uses ==)
    	-- @return a map-like table
    	-- @see seq.count_map
***0	function tablex.count_map (t,cmp)
***0	    assert_arg_indexable(1,t)
***0	    local res,mask = {},{}
***0	    cmp = function_arg(2,cmp)
***0	    local n = #t
***0	    for i = 1,#t do
***0	        local v = t[i]
***0	        if not mask[v] then
***0	            mask[v] = true
    	            -- check this value against all other values
***0	            res[v] = 1  -- there's at least one instance
***0	            for j = i+1,n do
***0	                local w = t[j]
    	                local ok
***0	                if cmp then
***0	                    ok = cmp(v,w)
    	                else
***0	                    ok = v == w
    	                end
***0	                if ok then
***0	                    res[v] = res[v] + 1
***0	                    mask[w] = true
    	                end
    	            end
    	        end
    	    end
***0	    return setmetatable(res,Map)
    	end
    	
    	--- filter an array's values using a predicate function
    	-- @within MappingAndFiltering
    	-- @array t a list-like table
    	-- @func pred a boolean function
    	-- @param arg optional argument to be passed as second argument of the predicate
***0	function tablex.filter (t,pred,arg)
   2	    assert_arg_indexable(1,t)
   2	    pred = function_arg(2,pred)
   2	    local res,k = {},1
   4	    for i = 1,#t do
   2	        local v = t[i]
   2	        if pred(v,arg) then
   2	            res[k] = v
   2	            k = k + 1
    	        end
    	    end
   2	    return setmeta(res,t,List)
    	end
    	
    	--- return a table where each element is a table of the ith values of an arbitrary
    	-- number of tables. It is equivalent to a matrix transpose.
    	-- @within Merging
    	-- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
    	-- @array ... arrays to be zipped
***0	function tablex.zip(...)
***0	    return tablex.mapn(function(...) return {...} end,...)
    	end
    	
    	local _copy
***0	function _copy (dest,src,idest,isrc,nsrc,clean_tail)
***0	    idest = idest or 1
***0	    isrc = isrc or 1
    	    local iend
***0	    if not nsrc then
***0	        nsrc = #src
***0	        iend = #src
    	    else
***0	        iend = isrc + min(nsrc-1,#src-isrc)
    	    end
***0	    if dest == src then -- special case
***0	        if idest > isrc and iend >= idest then -- overlapping ranges
***0	            src = tablex.sub(src,isrc,nsrc)
***0	            isrc = 1; iend = #src
    	        end
    	    end
***0	    for i = isrc,iend do
***0	        dest[idest] = src[i]
***0	        idest = idest + 1
    	    end
***0	    if clean_tail then
***0	        tablex.clear(dest,idest)
    	    end
***0	    return dest
    	end
    	
    	--- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.
    	-- @within Copying
    	-- @array dest a list-like table
    	-- @array src a list-like table
    	-- @int[opt=1] idest where to start copying values into destination
    	-- @int[opt=1] isrc where to start copying values from source
    	-- @int[opt=#src] nsrc number of elements to copy from source
***0	function tablex.icopy (dest,src,idest,isrc,nsrc)
***0	    assert_arg_indexable(1,dest)
***0	    assert_arg_indexable(2,src)
***0	    return _copy(dest,src,idest,isrc,nsrc,true)
    	end
    	
    	--- copy an array into another one.
    	-- @within Copying
    	-- @array dest a list-like table
    	-- @array src a list-like table
    	-- @int[opt=1] idest where to start copying values into destination
    	-- @int[opt=1] isrc where to start copying values from source
    	-- @int[opt=#src] nsrc number of elements to copy from source
***0	function tablex.move (dest,src,idest,isrc,nsrc)
***0	    assert_arg_indexable(1,dest)
***0	    assert_arg_indexable(2,src)
***0	    return _copy(dest,src,idest,isrc,nsrc,false)
    	end
    	
***0	function tablex._normalize_slice(self,first,last)
***0	  local sz = #self
***0	  if not first then first=1 end
***0	  if first<0 then first=sz+first+1 end
    	  -- make the range _inclusive_!
***0	  if not last then last=sz end
***0	  if last < 0 then last=sz+1+last end
***0	  return first,last
    	end
    	
    	--- Extract a range from a table, like  'string.sub'.
    	-- If first or last are negative then they are relative to the end of the list
    	-- eg. sub(t,-2) gives last 2 entries in a list, and
    	-- sub(t,-4,-2) gives from -4th to -2nd
    	-- @within Extraction
    	-- @array t a list-like table
    	-- @int first An index
    	-- @int last An index
    	-- @return a new List
***0	function tablex.sub(t,first,last)
***0	    assert_arg_indexable(1,t)
***0	    first,last = tablex._normalize_slice(t,first,last)
***0	    local res={}
***0	    for i=first,last do append(res,t[i]) end
***0	    return setmeta(res,t,List)
    	end
    	
    	--- set an array range to a value. If it's a function we use the result
    	-- of applying it to the indices.
    	-- @array t a list-like table
    	-- @param val a value
    	-- @int[opt=1] i1 start range
    	-- @int[opt=#t] i2 end range
***0	function tablex.set (t,val,i1,i2)
***0	    assert_arg_indexable(1,t)
***0	    i1,i2 = i1 or 1,i2 or #t
***0	    if types.is_callable(val) then
***0	        for i = i1,i2 do
***0	            t[i] = val(i)
    	        end
    	    else
***0	        for i = i1,i2 do
***0	            t[i] = val
    	        end
    	    end
    	end
    	
    	--- create a new array of specified size with initial value.
    	-- @int n size
    	-- @param val initial value (can be `nil`, but don't expect `#` to work!)
    	-- @return the table
***0	function tablex.new (n,val)
***0	    local res = {}
***0	    tablex.set(res,val,1,n)
***0	    return res
    	end
    	
    	--- clear out the contents of a table.
    	-- @array t a list
    	-- @param istart optional start position
***0	function tablex.clear(t,istart)
***0	    istart = istart or 1
***0	    for i = istart,#t do remove(t) end
    	end
    	
    	--- insert values into a table.
    	-- similar to `table.insert` but inserts values from given table `values`,
    	-- not the object itself, into table `t` at position `pos`.
    	-- @within Copying
    	-- @array t the list
    	-- @int[opt] position (default is at end)
    	-- @array values
***0	function tablex.insertvalues(t, ...)
   1	    assert_arg(1,t,'table')
    	    local pos, values
   1	    if select('#', ...) == 1 then
   1	        pos,values = #t+1, ...
    	    else
***0	        pos,values = ...
    	    end
   1	    if #values > 0 then
   1	        for i=#t,pos,-1 do
***0	            t[i+#values] = t[i]
    	        end
   1	        local offset = 1 - pos
   2	        for i=pos,pos+#values-1 do
   1	            t[i] = values[i + offset]
    	        end
    	    end
   1	    return t
    	end
    	
    	--- remove a range of values from a table.
    	-- End of range may be negative.
    	-- @array t a list-like table
    	-- @int i1 start index
    	-- @int i2 end index
    	-- @return the table
***0	function tablex.removevalues (t,i1,i2)
***0	    assert_arg(1,t,'table')
***0	    i1,i2 = tablex._normalize_slice(t,i1,i2)
***0	    for i = i1,i2 do
***0	        remove(t,i1)
    	    end
***0	    return t
    	end
    	
    	local _find
    	_find = function (t,value,tables)
***0	    for k,v in pairs(t) do
***0	        if v == value then return k end
    	    end
***0	    for k,v in pairs(t) do
***0	        if not tables[v] and type(v) == 'table' then
***0	            tables[v] = true
***0	            local res = _find(v,value,tables)
***0	            if res then
***0	                res = tostring(res)
***0	                if type(k) ~= 'string' then
***0	                    return '['..k..']'..res
    	                else
***0	                    return k..'.'..res
    	                end
    	            end
    	        end
    	    end
    	end
    	
    	--- find a value in a table by recursive search.
    	-- @within Finding
    	-- @tab t the table
    	-- @param value the value
    	-- @array[opt] exclude any tables to avoid searching
    	-- @usage search(_G,math.sin,{package.path}) == 'math.sin'
    	-- @return a fieldspec, e.g. 'a.b' or 'math.sin'
***0	function tablex.search (t,value,exclude)
***0	    assert_arg_iterable(1,t)
***0	    local tables = {[t]=true}
***0	    if exclude then
***0	        for _,v in pairs(exclude) do tables[v] = true end
    	    end
***0	    return _find(t,value,tables)
    	end
    	
    	--- return an iterator to a table sorted by its keys
    	-- @within Iterating
    	-- @tab t the table
    	-- @func f an optional comparison function (f(x,y) is true if x < y)
    	-- @usage for k,v in tablex.sort(t) do print(k,v) end
    	-- @return an iterator to traverse elements sorted by the keys
***0	function tablex.sort(t,f)
***0	    local keys = {}
***0	    for k in pairs(t) do keys[#keys + 1] = k end
***0	    tsort(keys,f)
***0	    local i = 0
    	    return function()
***0	        i = i + 1
***0	        return keys[i], t[keys[i]]
    	    end
    	end
    	
    	--- return an iterator to a table sorted by its values
    	-- @within Iterating
    	-- @tab t the table
    	-- @func f an optional comparison function (f(x,y) is true if x < y)
    	-- @usage for k,v in tablex.sortv(t) do print(k,v) end
    	-- @return an iterator to traverse elements sorted by the values
***0	function tablex.sortv(t,f)
***0	    local rev = {}
***0	    for k,v in pairs(t) do rev[v] = k end
***0	    local next = tablex.sort(rev,f)
    	    return function()
***0	        local value,key = next()
***0	        return key,value
    	    end
    	end
    	
    	--- modifies a table to be read only.
    	-- This only offers weak protection. Tables can still be modified with
    	-- `table.insert` and `rawset`.
    	-- @tab t the table
    	-- @return the table read only.
***0	function tablex.readonly(t)
***0	    local mt = {
    	        __index=t,
    	        __newindex=function(t, k, v) error("Attempt to modify read-only table", 2) end,
    	        __pairs=function() return pairs(t) end,
    	        __ipairs=function() return ipairs(t) end,
    	        __len=function() return #t end,
***0	        __metatable=false
    	    }
***0	    return setmetatable({}, mt)
    	end
    	
***0	return tablex

==============================================================================
/usr/local/share/lua/5.2/pl/types.lua
==============================================================================
    	---- Dealing with Detailed Type Information
    	
    	-- Dependencies `pl.utils`
    	-- @module pl.types
    	
***0	local utils = require 'pl.utils'
***0	local types = {}
    	
    	--- is the object either a function or a callable object?.
    	-- @param obj Object to check.
***0	function types.is_callable (obj)
***0	    return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call
    	end
    	
    	--- is the object of the specified type?.
    	-- If the type is a string, then use type, otherwise compare with metatable
    	-- @param obj An object to check
    	-- @param tp String of what type it should be
    	-- @function is_type
***0	types.is_type = utils.is_type
    	
***0	local fileMT = getmetatable(io.stdout)
    	
    	--- a string representation of a type.
    	-- For tables with metatables, we assume that the metatable has a `_name`
    	-- field. Knows about Lua file objects.
    	-- @param obj an object
    	-- @return a string like 'number', 'table' or 'List'
***0	function types.type (obj)
***0	    local t = type(obj)
***0	    if t == 'table' or t == 'userdata' then
***0	        local mt = getmetatable(obj)
***0	        if mt == fileMT then
***0	            return 'file'
    	        else
***0	            return mt._name or "unknown "..t
    	        end
    	    else
***0	        return t
    	    end
    	end
    	
    	--- is this number an integer?
    	-- @param x a number
    	-- @raise error if x is not a number
***0	function types.is_integer (x)
***0	    return math.ceil(x)==x
    	end
    	
    	--- Check if the object is "empty".
    	-- An object is considered empty if it is nil, a table with out any items (key,
    	-- value pairs or indexes), or a string with no content ("").
    	-- @param o The object to check if it is empty.
    	-- @param ignore_spaces If the object is a string and this is true the string is
    	-- considered empty is it only contains spaces.
    	-- @return true if the object is empty, otherwise false.
***0	function types.is_empty(o, ignore_spaces)
***0	    if o == nil or (type(o) == "table" and not next(o)) or (type(o) == "string" and (o == "" or (ignore_spaces and o:match("^%s+$")))) then
***0	        return true
    	    end
***0	    return false
    	end
    	
    	local function check_meta (val)
   3	    if type(val) == 'table' then return true end
***0	    return getmetatable(val)
    	end
    	
    	--- is an object 'array-like'?
    	-- @param val any value.
***0	function types.is_indexable (val)
   2	    local mt = check_meta(val)
   2	    if mt == true then return true end
***0	    return not(mt and mt.__len and mt.__index)
    	end
    	
    	--- can an object be iterated over with `ipairs`?
    	-- @param val any value.
***0	function types.is_iterable (val)
   1	    local mt = check_meta(val)
   1	    if mt == true then return true end
***0	    return not(mt and mt.__pairs)
    	end
    	
    	--- can an object accept new key/pair values?
    	-- @param val any value.
***0	function types.is_writeable (val)
***0	    local mt = check_meta(val)
***0	    if mt == true then return true end
***0	    return not(mt and mt.__newindex)
    	end
    	
    	-- Strings that should evaluate to true.
***0	local trues = { yes=true, y=true, ["true"]=true, t=true, ["1"]=true }
    	-- Conditions types should evaluate to true.
***0	local true_types = {
    	    boolean=function(o, true_strs, check_objs) return o end,
    	    string=function(o, true_strs, check_objs)
***0	        if trues[o:lower()] then
***0	            return true
    	        end
    	        -- Check alternative user provided strings.
***0	        for _,v in ipairs(true_strs or {}) do
***0	            if type(v) == "string" and o == v:lower() then
***0	                return true
    	            end
    	        end
***0	        return false
    	    end,
    	    number=function(o, true_strs, check_objs) return o ~= 0 end,
***0	    table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end
    	}
    	--- Convert to a boolean value.
    	-- True values are:
    	--
    	-- * boolean: true.
    	-- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.
    	-- * number: Any non-zero value.
    	-- * table: Is not empty and `check_objs` is true.
    	-- * object: Is not `nil` and `check_objs` is true.
    	--
    	-- @param o The object to evaluate.
    	-- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.
    	-- This should be a List of strings. E.g. "ja" to support German.
    	-- @param[opt] check_objs True if objects should be evaluated. Default is to evaluate objects as true if not nil
    	-- or if it is a table and it is not empty.
    	-- @return true if the input evaluates to true, otherwise false.
***0	function types.to_bool(o, true_strs, check_objs)
    	    local true_func
***0	    if true_strs then
***0	        utils.assert_arg(2, true_strs, "table")
    	    end
***0	    true_func = true_types[type(o)]
***0	    if true_func then
***0	        return true_func(o, true_strs, check_objs)
***0	    elseif check_objs and o ~= nil then
***0	        return true
    	    end
***0	    return false
    	end
    	
    	
***0	return types

==============================================================================
/usr/local/share/lua/5.2/pl/utils.lua
==============================================================================
    	--- Generally useful routines.
    	-- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
    	-- @module pl.utils
***0	local format,gsub,byte = string.format,string.gsub,string.byte
***0	local compat = require 'pl.compat'
***0	local clock = os.clock
***0	local stdout = io.stdout
***0	local append = table.insert
***0	local unpack = rawget(_G,'unpack') or rawget(table,'unpack')
    	
***0	local collisions = {}
    	
***0	local utils = {
    	    _VERSION = "1.2.1",
    	    lua51 = compat.lua51,
    	    setfenv = compat.setfenv,
    	    getfenv = compat.getfenv,
    	    load = compat.load,
    	    execute = compat.execute,
    	    dir_separator = _G.package.config:sub(1,1),
***0	    unpack = unpack
    	}
    	
    	--- end this program gracefully.
    	-- @param code The exit code or a message to be printed
    	-- @param ... extra arguments for message's format'
    	-- @see utils.fprintf
***0	function utils.quit(code,...)
***0	    if type(code) == 'string' then
***0	        utils.fprintf(io.stderr,code,...)
***0	        code = -1
    	    else
***0	        utils.fprintf(io.stderr,...)
    	    end
***0	    io.stderr:write('\n')
***0	    os.exit(code)
    	end
    	
    	--- print an arbitrary number of arguments using a format.
    	-- @param fmt The format (see string.format)
    	-- @param ... Extra arguments for format
***0	function utils.printf(fmt,...)
***0	    utils.assert_string(1,fmt)
***0	    utils.fprintf(stdout,fmt,...)
    	end
    	
    	--- write an arbitrary number of arguments to a file using a format.
    	-- @param f File handle to write to.
    	-- @param fmt The format (see string.format).
    	-- @param ... Extra arguments for format
***0	function utils.fprintf(f,fmt,...)
***0	    utils.assert_string(2,fmt)
***0	    f:write(format(fmt,...))
    	end
    	
    	local function import_symbol(T,k,v,libname)
***0	    local key = rawget(T,k)
    	    -- warn about collisions!
***0	    if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
***0	        utils.printf("warning: '%s.%s' will not override existing symbol\n",libname,k)
***0	        return
    	    end
***0	    rawset(T,k,v)
    	end
    	
    	local function lookup_lib(T,t)
***0	    for k,v in pairs(T) do
***0	        if v == t then return k end
    	    end
***0	    return '?'
    	end
    	
***0	local already_imported = {}
    	
    	--- take a table and 'inject' it into the local namespace.
    	-- @param t The Table
    	-- @param T An optional destination table (defaults to callers environment)
***0	function utils.import(t,T)
***0	    T = T or _G
***0	    t = t or utils
***0	    if type(t) == 'string' then
***0	        t = require (t)
    	    end
***0	    local libname = lookup_lib(T,t)
***0	    if already_imported[t] then return end
***0	    already_imported[t] = libname
***0	    for k,v in pairs(t) do
***0	        import_symbol(T,k,v,libname)
    	    end
    	end
    	
***0	utils.patterns = {
    	    FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*',
    	    INTEGER = '[+%-%d]%d*',
    	    IDEN = '[%a_][%w_]*',
***0	    FILE = '[%a%.\\][:%][%w%._%-\\]*'
    	}
    	
    	--- escape any 'magic' characters in a string
    	-- @param s The input string
***0	function utils.escape(s)
   1	    utils.assert_string(1,s)
   1	    return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
    	end
    	
    	--- return either of two values, depending on a condition.
    	-- @param cond A condition
    	-- @param value1 Value returned if cond is true
    	-- @param value2 Value returned if cond is false (can be optional)
***0	function utils.choose(cond,value1,value2)
***0	    if cond then return value1
***0	    else return value2
    	    end
    	end
    	
    	local raise
    	
    	--- return the contents of a file as a string
    	-- @param filename The file path
    	-- @param is_bin open in binary mode
    	-- @return file contents
***0	function utils.readfile(filename,is_bin)
***0	    local mode = is_bin and 'b' or ''
***0	    utils.assert_string(1,filename)
***0	    local f,err = io.open(filename,'r'..mode)
***0	    if not f then return utils.raise (err) end
***0	    local res,err = f:read('*a')
***0	    f:close()
***0	    if not res then return raise (err) end
***0	    return res
    	end
    	
    	--- write a string to a file
    	-- @param filename The file path
    	-- @param str The string
    	-- @return true or nil
    	-- @return error message
    	-- @raise error if filename or str aren't strings
***0	function utils.writefile(filename,str)
***0	    utils.assert_string(1,filename)
***0	    utils.assert_string(2,str)
***0	    local f,err = io.open(filename,'w')
***0	    if not f then return raise(err) end
***0	    f:write(str)
***0	    f:close()
***0	    return true
    	end
    	
    	--- return the contents of a file as a list of lines
    	-- @param filename The file path
    	-- @return file contents as a table
    	-- @raise errror if filename is not a string
***0	function utils.readlines(filename)
***0	    utils.assert_string(1,filename)
***0	    local f,err = io.open(filename,'r')
***0	    if not f then return raise(err) end
***0	    local res = {}
***0	    for line in f:lines() do
***0	        append(res,line)
    	    end
***0	    f:close()
***0	    return res
    	end
    	
    	--- split a string into a list of strings separated by a delimiter.
    	-- @param s The input string
    	-- @param re A Lua string pattern; defaults to '%s+'
    	-- @param plain don't use Lua patterns
    	-- @param n optional maximum number of splits
    	-- @return a list-like table
    	-- @raise error if s is not a string
***0	function utils.split(s,re,plain,n)
***0	    utils.assert_string(1,s)
***0	    local find,sub,append = string.find, string.sub, table.insert
***0	    local i1,ls = 1,{}
***0	    if not re then re = '%s+' end
***0	    if re == '' then return {s} end
    	    while true do
***0	        local i2,i3 = find(s,re,i1,plain)
***0	        if not i2 then
***0	            local last = sub(s,i1)
***0	            if last ~= '' then append(ls,last) end
***0	            if #ls == 1 and ls[1] == '' then
***0	                return {}
    	            else
***0	                return ls
    	            end
    	        end
***0	        append(ls,sub(s,i1,i2-1))
***0	        if n and #ls == n then
***0	            ls[#ls] = sub(s,i1)
***0	            return ls
    	        end
***0	        i1 = i3+1
    	    end
    	end
    	
    	--- split a string into a number of values.
    	-- @param s the string
    	-- @param re the delimiter, default space
    	-- @return n values
    	-- @usage first,next = splitv('jane:doe',':')
    	-- @see split
***0	function utils.splitv (s,re)
***0	    return unpack(utils.split(s,re))
    	end
    	
    	--- convert an array of values to strings.
    	-- @param t a list-like table
    	-- @param temp buffer to use, otherwise allocate
    	-- @param tostr custom tostring function, called with (value,index).
    	-- Otherwise use `tostring`
    	-- @return the converted buffer
***0	function utils.array_tostring (t,temp,tostr)
***0	    temp, tostr = temp or {}, tostr or tostring
***0	    for i = 1,#t do
***0	        temp[i] = tostr(t[i],i)
    	    end
***0	    return temp
    	end
    	
    	--- execute a shell command and return the output.
    	-- This function redirects the output to tempfiles and returns the content of those files.
    	-- @param cmd a shell command
    	-- @param bin boolean, if true, read output as binary file
    	-- @return true if successful
    	-- @return actual return code
    	-- @return stdout output (string)
    	-- @return errout output (string)
***0	function utils.executeex(cmd, bin)
    	    local mode
***0	    local outfile = os.tmpname()
***0	    local errfile = os.tmpname()
    	
***0	    if utils.dir_separator == '\\' then
***0	        outfile = os.getenv('TEMP')..outfile
***0	        errfile = os.getenv('TEMP')..errfile
    	    end
***0	    cmd = cmd .. [[ >"]]..outfile..[[" 2>"]]..errfile..[["]]
    	
***0	    local success, retcode = utils.execute(cmd)
***0	    local outcontent = utils.readfile(outfile, bin)
***0	    local errcontent = utils.readfile(errfile, bin)
***0	    os.remove(outfile)
***0	    os.remove(errfile)
***0	    return success, retcode, (outcontent or ""), (errcontent or "")
    	end
    	
    	--- 'memoize' a function (cache returned value for next call).
    	-- This is useful if you have a function which is relatively expensive,
    	-- but you don't know in advance what values will be required, so
    	-- building a table upfront is wasteful/impossible.
    	-- @param func a function of at least one argument
    	-- @return a function with at least one argument, which is used as the key.
***0	function utils.memoize(func)
***0	    return setmetatable({}, {
    	        __index = function(self, k, ...)
***0	            local v = func(k,...)
***0	            self[k] = v
***0	            return v
    	        end,
***0	        __call = function(self, k) return self[k] end
    	    })
    	end
    	
    	
***0	utils.stdmt = {
    	    List = {_name='List'}, Map = {_name='Map'},
***0	    Set = {_name='Set'}, MultiMap = {_name='MultiMap'}
    	}
    	
***0	local _function_factories = {}
    	
    	--- associate a function factory with a type.
    	-- A function factory takes an object of the given type and
    	-- returns a function for evaluating it
    	-- @tab mt metatable
    	-- @func fun a callable that returns a function
***0	function utils.add_function_factory (mt,fun)
***0	    _function_factories[mt] = fun
    	end
    	
    	local function _string_lambda(f)
***0	    local raise = utils.raise
***0	    if f:find '^|' or f:find '_' then
***0	        local args,body = f:match '|([^|]*)|(.+)'
***0	        if f:find '_' then
***0	            args = '_'
***0	            body = f
    	        else
***0	            if not args then return raise 'bad string lambda' end
    	        end
***0	        local fstr = 'return function('..args..') return '..body..' end'
***0	        local fn,err = utils.load(fstr)
***0	        if not fn then return raise(err) end
***0	        fn = fn()
***0	        return fn
***0	    else return raise 'not a string lambda'
    	    end
    	end
    	
    	--- an anonymous function as a string. This string is either of the form
    	-- '|args| expression' or is a function of one argument, '_'
    	-- @param lf function as a string
    	-- @return a function
    	-- @usage string_lambda '|x|x+1' (2) == 3
    	-- @usage string_lambda '_+1 (2) == 3
    	-- @function utils.string_lambda
***0	utils.string_lambda = utils.memoize(_string_lambda)
    	
    	local ops
    	
    	--- process a function argument.
    	-- This is used throughout Penlight and defines what is meant by a function:
    	-- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
    	-- such as '>' or '#'. If a function factory has been registered for the type, it will
    	-- be called to get the function.
    	-- @param idx argument index
    	-- @param f a function, operator string, or callable object
    	-- @param msg optional error message
    	-- @return a callable
    	-- @raise if idx is not a number or if f is not callable
***0	function utils.function_arg (idx,f,msg)
   2	    utils.assert_arg(1,idx,'number')
   2	    local tp = type(f)
   2	    if tp == 'function' then return f end  -- no worries!
    	    -- ok, a string can correspond to an operator (like '==')
***0	    if tp == 'string' then
***0	        if not ops then ops = require 'pl.operator'.optable end
***0	        local fn = ops[f]
***0	        if fn then return fn end
***0	        local fn, err = utils.string_lambda(f)
***0	        if not fn then error(err..': '..f) end
***0	        return fn
***0	    elseif tp == 'table' or tp == 'userdata' then
***0	        local mt = getmetatable(f)
***0	        if not mt then error('not a callable object',2) end
***0	        local ff = _function_factories[mt]
***0	        if not ff then
***0	            if not mt.__call then error('not a callable object',2) end
***0	            return f
    	        else
***0	            return ff(f) -- we have a function factory for this type!
    	        end
    	    end
***0	    if not msg then msg = " must be callable" end
***0	    if idx > 0 then
***0	        error("argument "..idx..": "..msg,2)
    	    else
***0	        error(msg,2)
    	    end
    	end
    	
    	--- bind the first argument of the function to a value.
    	-- @param fn a function of at least two values (may be an operator string)
    	-- @param p a value
    	-- @return a function such that f(x) is fn(p,x)
    	-- @raise same as @{function_arg}
    	-- @see func.bind1
***0	function utils.bind1 (fn,p)
***0	    fn = utils.function_arg(1,fn)
***0	    return function(...) return fn(p,...) end
    	end
    	
    	--- bind the second argument of the function to a value.
    	-- @param fn a function of at least two values (may be an operator string)
    	-- @param p a value
    	-- @return a function such that f(x) is fn(x,p)
    	-- @raise same as @{function_arg}
***0	function utils.bind2 (fn,p)
***0	    fn = utils.function_arg(1,fn)
***0	    return function(x,...) return fn(x,p,...) end
    	end
    	
    	
    	--- assert that the given argument is in fact of the correct type.
    	-- @param n argument index
    	-- @param val the value
    	-- @param tp the type
    	-- @param verify an optional verfication function
    	-- @param msg an optional custom message
    	-- @param lev optional stack position for trace, default 2
    	-- @raise if the argument n is not the correct type
    	-- @usage assert_arg(1,t,'table')
    	-- @usage assert_arg(n,val,'string',path.isdir,'not a directory')
***0	function utils.assert_arg (n,val,tp,verify,msg,lev)
  63	    if type(val) ~= tp then
***0	        error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
    	    end
  63	    if verify and not verify(val) then
***0	        error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
    	    end
    	end
    	
    	--- assert the common case that the argument is a string.
    	-- @param n argument index
    	-- @param val a value that must be a string
    	-- @raise val must be a string
***0	function utils.assert_string (n,val)
  59	    utils.assert_arg(n,val,'string',nil,nil,3)
    	end
    	
***0	local err_mode = 'default'
    	
    	--- control the error strategy used by Penlight.
    	-- Controls how <code>utils.raise</code> works; the default is for it
    	-- to return nil and the error string, but if the mode is 'error' then
    	-- it will throw an error. If mode is 'quit' it will immediately terminate
    	-- the program.
    	-- @param mode - either 'default', 'quit'  or 'error'
    	-- @see utils.raise
***0	function utils.on_error (mode)
***0	    if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
***0	      err_mode = mode
    	    else
    	      -- fail loudly
***0	      if err_mode == 'default' then err_mode = 'error' end
***0	      utils.raise("Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'")
    	    end
    	end
    	
    	--- used by Penlight functions to return errors.  Its global behaviour is controlled
    	-- by <code>utils.on_error</code>
    	-- @param err the error string.
    	-- @see utils.on_error
***0	function utils.raise (err)
***0	    if err_mode == 'default' then return nil,err
***0	    elseif err_mode == 'quit' then utils.quit(err)
***0	    else error(err,2)
    	    end
    	end
    	
    	--- is the object of the specified type?.
    	-- If the type is a string, then use type, otherwise compare with metatable
    	-- @param obj An object to check
    	-- @param tp String of what type it should be
***0	function utils.is_type (obj,tp)
***0	    if type(tp) == 'string' then return type(obj) == tp end
***0	    local mt = getmetatable(obj)
***0	    return tp == mt
    	end
    	
***0	raise = utils.raise
    	
    	--- load a code string or bytecode chunk.
    	-- @param code Lua code as a string or bytecode
    	-- @param name for source errors
    	-- @param mode kind of chunk, 't' for text, 'b' for bytecode, 'bt' for all (default)
    	-- @param env  the environment for the new chunk (default nil)
    	-- @return compiled chunk
    	-- @return error message (chunk is nil)
    	-- @function utils.load
    	
    	---------------
    	-- Get environment of a function.
    	-- With Lua 5.2, may return nil for a function with no global references!
    	-- Based on code by [Sergey Rozhenko](http://lua-users.org/lists/lua-l/2010-06/msg00313.html)
    	-- @param f a function or a call stack reference
    	-- @function utils.getfenv
    	
    	---------------
    	-- Set environment of a function
    	-- @param f a function or a call stack reference
    	-- @param env a table that becomes the new environment of `f`
    	-- @function utils.setfenv
    	
    	--- execute a shell command.
    	-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2
    	-- @param cmd a shell command
    	-- @return true if successful
    	-- @return actual return code
    	-- @function utils.execute
    	
***0	return utils
    	
    	

==============================================================================
/usr/local/share/lua/5.2/requests.lua
==============================================================================
    	-- Lua Requests library for http ease
    	
   1	local http_socket = require('socket.http')
   1	local https_socket = require('ssl.https')
   1	local url_parser = require('socket.url')
   1	local ltn12 = require('ltn12')
   1	local json = require('cjson.safe')
   1	local xml = require('xml')
   1	local md5sum = require('md5') -- TODO: Make modular?
   1	local base64 = require('base64')
    	
   1	local requests = {
   1	  _DESCRIPTION = 'Http requests made simpler',
   1	  http_socket = http_socket,
   1	  https_socket = https_socket
    	}
    	
   1	local _requests = {}
    	
    	--User facing function the make a request use Digest Authentication
    	--TODO: Determine what else should live in authentication
   1	function requests.HTTPDigestAuth(user, password)
***0	  return { _type = 'digest', user = user, password = password}
    	end
    	
    	--User facing function the make a request use Basic Authentication
    	--TODO: Determine what else should live in authentication
   1	function requests.HTTPBasicAuth(user, password)
***0	  return { _type = 'basic', user = user, password = password}
    	end
    	
   1	function requests.post(url, args)
   8	  return requests.request("POST", url, args)
    	end
    	
   1	function requests.get(url, args)
***0	  return requests.request("GET", url, args)
    	end
    	
   1	function requests.delete(url, args)
***0	  return requests.request("DELETE", url, args)
    	end
    	
   1	function requests.patch(url, args)
***0	  return requests.request("PATCH", url, args)
    	end
    	
   1	function requests.put(url, args)
***0	  return requests.request("PUT", url, args)
    	end
    	
   1	function requests.options(url, args)
***0	  return requests.request("OPTIONS", url, args)
    	end
    	
   1	function requests.head(url, args)
***0	  return requests.request("HEAD", url, args)
    	end
    	
   1	function requests.trace(url, args)
***0	  return requests.request("TRACE", url, args)
    	end
    	
    	--Sets up all the data for a request and makes the request
   1	function requests.request(method, url, args)
    	  local request
    	
   8	  if type(url) == "table" then
***0	    request = url
    	  else
   8	    request = args or {}
   8	    request.url = url
    	  end
    	
   8	  request.method = method
   8	  _requests.parse_args(request)
    	
    	  -- TODO: Find a better way to do this
   8	  if request.auth and request.auth._type == 'digest' then
***0	    local response = _requests.make_request(request)
***0	    return _requests.use_digest(response, request)
    	  else
   8	    return _requests.make_request(request)
    	  end
    	end
    	
    	--Makes a request
   1	function _requests.make_request(request)
   8	  local response_body = {}
   8	  local full_request = {
   8	    method = request.method,
   8	    url = request.url,
   8	    headers = request.headers,
   8	    source = ltn12.source.string(request.data),
   8	    sink = ltn12.sink.table(response_body),
   8	    redirect = request.allow_redirects,
   8	    proxy = request.proxy
    	  }
    	
   8	  local response = {}
    	  local ok
   8	  local socket = string.find(full_request.url, '^https:') and https_socket or http_socket
    	
   8	  ok, response.status_code, response.headers, response.status = socket.request(full_request)
    	
   8	  assert(ok, 'error in '..request.method..' request: '..response.status_code)
   8	  response.text = table.concat(response_body)
  16	  response.json = function () return json.decode(response.text) end
   8	  response.xml = function () return xml.load(response.text) end
    	
   8	  return response
    	end
    	
    	--Parses through all the possible arguments for a request
   1	function _requests.parse_args(request)
   8	  _requests.check_url(request)
   8	  _requests.check_data(request)
   8	  _requests.create_header(request)
   8	  _requests.check_timeout(request.timeout)
   8	  _requests.check_redirect(request.allow_redirects)
    	end
    	
    	--Format the the url based on the params argument
   1	function _requests.format_params(url, params) -- TODO: Clean
   8	  if not params or next(params) == nil then return url end
    	
***0	  url = url..'?'
***0	  for key, value in pairs(params) do
***0	    if tostring(value) then
***0	      url = url..tostring(key)..'='
    	
***0	      if type(value) == 'table' then
***0	        local val_string = ''
    	
***0	        for _, val in ipairs(value) do
***0	          val_string = val_string..tostring(val)..','
    	        end
    	
***0	        url = url..val_string:sub(0, -2)
    	      else
***0	        url = url..tostring(value)
    	      end
    	
***0	      url = url..'&'
    	    end
    	  end
    	
***0	  return url:sub(0, -2)
    	end
    	
    	--Check that there is a URL given and append to it if params are passed in.
   1	function _requests.check_url(request)
   8	  assert(request.url, 'No url specified for request')
   8	  request.url = _requests.format_params(request.url, request.params)
    	end
    	
    	-- Add to the HTTP header
   1	function _requests.create_header(request)
   8	  request.headers = request.headers or {}
   8	  request.headers['Content-Length'] = request.data:len()
    	
   8	  if request.cookies then
***0	    if request.headers.cookie then
***0	      request.headers.cookie = request.headers.cookie..'; '..request.cookies
    	    else
***0	      request.headers.cookie = request.cookies
    	    end
    	  end
    	
   8	  if request.auth then
***0	    _requests.add_auth_headers(request)
    	  end
    	end
    	
    	--Makes sure that the data is in a format that can be sent
   1	function _requests.check_data(request)
   8	  request.data = request.data or ''
    	
   8	  if type(request.data) == "table" then
   7	    request.data = json.encode(request.data)
    	  end
    	end
    	
    	--Set the timeout
   1	function _requests.check_timeout(timeout)
   8	  http_socket.TIMEOUT = timeout or 5
   8	  https_socket.TIMEOUT = timeout or 5
    	end
    	
    	--Checks is allow_redirects parameter is set correctly
   1	function _requests.check_redirect(allow_redirects)
   8	  if allow_redirects and type(allow_redirects) ~= "boolean" then
***0	    error("allow_redirects expects a boolean value. received type = "..type(allow_redirects))
    	  end
    	end
    	
    	--Create the Authorization header for Basic Auth
   1	function _requests.basic_auth_header(request)
***0	  local encoded = base64.encode(request.auth.user..':'..request.auth.password)
***0	  request.headers.Authorization = 'Basic '..encoded
    	end
    	
    	-- Create digest authorization string for request header TODO: Could be better, but it should work
   1	function _requests.digest_create_header_string(auth)
***0	  local authorization = ''
***0	  authorization = 'Digest username="'..auth.user..'", realm="'..auth.realm..'", nonce="'..auth.nonce
***0	  authorization = authorization..'", uri="'..auth.uri..'", qop='..auth.qop..', nc='..auth.nc
***0	  authorization = authorization..', cnonce="'..auth.cnonce..'", response="'..auth.response..'"'
    	
***0	  if auth.opaque then
***0	    authorization = authorization..', opaque="'..auth.opaque..'"'
    	  end
    	
***0	  return authorization
    	end
    	
    	--MD5 hash all parameters
    	local function md5_hash(...)
***0	  return md5sum.sumhexa(table.concat({...}, ":"))
    	end
    	
    	-- Creates response hash TODO: Add functionality
   1	function _requests.digest_hash_response(auth_table)
***0	  return md5_hash(
***0	    md5_hash(auth_table.user, auth_table.realm, auth_table.password),
***0	    auth_table.nonce,
***0	    auth_table.nc,
***0	    auth_table.cnonce,
***0	    auth_table.qop,
***0	    md5_hash(auth_table.method, auth_table.uri)
    	  )
    	end
    	
    	-- Add digest authentication to the request header
   1	function _requests.digest_auth_header(request)
***0	  if not request.auth.nonce then return end
    	
***0	  request.auth.cnonce = request.auth.cnonce or string.format("%08x", os.time())
    	
***0	  request.auth.nc_count = request.auth.nc_count or 0
***0	  request.auth.nc_count = request.auth.nc_count + 1
    	
***0	  request.auth.nc = string.format("%08x", request.auth.nc_count)
    	
***0	  local url = url_parser.parse(request.url)
***0	  request.auth.uri = url_parser.build{path = url.path, query = url.query}
***0	  request.auth.method = request.method
***0	  request.auth.qop = 'auth'
    	
***0	  request.auth.response = _requests.digest_hash_response(request.auth)
    	
***0	  request.headers.Authorization = _requests.digest_create_header_string(request.auth)
    	end
    	
    	--Checks the resonse code and adds additional headers for Digest Auth
    	-- TODO: Rename this
   1	function _requests.use_digest(response, request)
***0	  if response.status_code == 401 then
***0	    _requests.parse_digest_response_header(response,request)
***0	    _requests.create_header(request)
***0	    response = _requests.make_request(request)
***0	    response.auth = request.auth
***0	    response.cookies = request.headers.cookie
***0	    return response
    	  else
***0	    response.auth = request.auth
***0	    response.cookies = request.headers.cookie
***0	    return response
    	  end
    	end
    	
    	--Parse the first response from the host to make the Authorization header
   1	function _requests.parse_digest_response_header(response, request)
***0	  for key, value in response.headers['www-authenticate']:gmatch('(%w+)="(%S+)"') do
***0	    request.auth[key] = value
    	  end
    	
***0	  if request.headers.cookie then
***0	    request.headers.cookie = request.headers.cookie..'; '..response.headers['set-cookie']
    	  else
***0	    request.headers.cookie = response.headers['set-cookie']
    	  end
    	
***0	  request.auth.nc_count = 0
    	end
    	
    	-- Call the correct authentication header function
   1	function _requests.add_auth_headers(request)
***0	  local auth_func = {
    	    basic = _requests.basic_auth_header,
***0	    digest = _requests.digest_auth_header
    	  }
    	
***0	  auth_func[request.auth._type](request)
    	end
    	
    	--Return public functions
   1	requests._private = _requests
   1	return requests

==============================================================================
/usr/local/share/lua/5.2/say/init.lua
==============================================================================
***0	local unpack = table.unpack or unpack
    	
***0	local registry = { }
    	local current_namespace
    	local fallback_namespace
    	
***0	local s = {
    	
    	  _COPYRIGHT   = "Copyright (c) 2012 Olivine Labs, LLC.",
    	  _DESCRIPTION = "A simple string key/value store for i18n or any other case where you want namespaced strings.",
    	  _VERSION     = "Say 1.2",
    	
    	  set_namespace = function(self, namespace)
   1	    current_namespace = namespace
   1	    if not registry[current_namespace] then
***0	      registry[current_namespace] = {}
    	    end
    	  end,
    	
    	  set_fallback = function(self, namespace)
***0	    fallback_namespace = namespace
***0	    if not registry[fallback_namespace] then
***0	      registry[fallback_namespace] = {}
    	    end
    	  end,
    	
    	  set = function(self, key, value)
  18	    registry[current_namespace][key] = value
    	  end
    	}
    	
***0	local __meta = {
    	  __call = function(self, key, vars)
  18	    vars = vars or {}
    	
  18	    local str = registry[current_namespace][key] or registry[fallback_namespace][key]
    	
  18	    if str == nil then
***0	      return nil
    	    end
  18	    str = tostring(str)
  18	    local strings = {}
    	
  48	    for i,v in ipairs(vars) do
  30	      table.insert(strings, tostring(v))
    	    end
    	
  18	    return #strings > 0 and str:format(unpack(strings)) or str
    	  end,
    	
    	  __index = function(self, key)
***0	    return registry[key]
    	  end
    	}
    	
***0	s:set_fallback('en')
***0	s:set_namespace('en')
    	
***0	s._registry = registry
    	
***0	return setmetatable(s, __meta)

==============================================================================
/usr/local/share/lua/5.2/ssl.lua
==============================================================================
    	------------------------------------------------------------------------------
    	-- LuaSec 0.5.1
    	-- Copyright (C) 2006-2015 Bruno Silvestre
    	--
    	------------------------------------------------------------------------------
    	
   1	local core    = require("ssl.core")
   1	local context = require("ssl.context")
   1	local x509    = require("ssl.x509")
    	
   1	module("ssl", package.seeall)
    	
   1	_VERSION   = "0.5.1"
   1	_COPYRIGHT = core.copyright()
    	
    	-- Export
   1	loadcertificate = x509.load
    	
    	-- We must prevent the contexts to be collected before the connections,
    	-- otherwise the C registry will be cleared.
   1	local registry = setmetatable({}, {__mode="k"})
    	
    	--
    	--
    	--
    	local function optexec(func, param, ctx)
  16	  if param then
  16	    if type(param) == "table" then
***0	      return func(ctx, unpack(param))
    	    else
  16	      return func(ctx, param)
    	    end
    	  end
***0	  return true
    	end
    	
    	--
    	--
    	--
   1	function newcontext(cfg)
    	   local succ, msg, ctx
    	   -- Create the context
   8	   ctx, msg = context.create(cfg.protocol)
   8	   if not ctx then return nil, msg end
    	   -- Mode
   8	   succ, msg = context.setmode(ctx, cfg.mode)
   8	   if not succ then return nil, msg end
    	   -- Load the key
   8	   if cfg.key then
***0	      if cfg.password and
***0	         type(cfg.password) ~= "function" and
***0	         type(cfg.password) ~= "string"
    	      then
***0	         return nil, "invalid password type"
    	      end
***0	      succ, msg = context.loadkey(ctx, cfg.key, cfg.password)
***0	      if not succ then return nil, msg end
    	   end
    	   -- Load the certificate
   8	   if cfg.certificate then
***0	      succ, msg = context.loadcert(ctx, cfg.certificate)
***0	      if not succ then return nil, msg end
    	   end
    	   -- Load the CA certificates
   8	   if cfg.cafile or cfg.capath then
***0	      succ, msg = context.locations(ctx, cfg.cafile, cfg.capath)
***0	      if not succ then return nil, msg end
    	   end
    	   -- Set SSL ciphers
   8	   if cfg.ciphers then
***0	      succ, msg = context.setcipher(ctx, cfg.ciphers)
***0	      if not succ then return nil, msg end
    	   end
    	   -- Set the verification options
   8	   succ, msg = optexec(context.setverify, cfg.verify, ctx)
   8	   if not succ then return nil, msg end
    	   -- Set SSL options
   8	   succ, msg = optexec(context.setoptions, cfg.options, ctx)
   8	   if not succ then return nil, msg end
    	   -- Set the depth for certificate verification
   8	   if cfg.depth then
***0	      succ, msg = context.setdepth(ctx, cfg.depth)
***0	      if not succ then return nil, msg end
    	   end
    	
    	   -- NOTE: Setting DH parameters and elliptic curves needs to come after
    	   -- setoptions(), in case the user has specified the single_{dh,ecdh}_use
    	   -- options.
    	
    	   -- Set DH parameters
   8	   if cfg.dhparam then
***0	      if type(cfg.dhparam) ~= "function" then
***0	         return nil, "invalid DH parameter type"
    	      end
***0	      context.setdhparam(ctx, cfg.dhparam)
    	   end
    	   -- Set elliptic curve
   8	   if cfg.curve then
***0	      succ, msg = context.setcurve(ctx, cfg.curve)
***0	      if not succ then return nil, msg end
    	   end
    	   -- Set extra verification options
   8	   if cfg.verifyext and ctx.setverifyext then
***0	      succ, msg = optexec(ctx.setverifyext, cfg.verifyext, ctx)
***0	      if not succ then return nil, msg end
    	   end
    	
   8	   return ctx
    	end
    	
    	--
    	--
    	--
   1	function wrap(sock, cfg)
    	   local ctx, msg
   8	   if type(cfg) == "table" then
   8	      ctx, msg = newcontext(cfg)
   8	      if not ctx then return nil, msg end
    	   else
***0	      ctx = cfg
    	   end
   8	   local s, msg = core.create(ctx)
   8	   if s then
   8	      core.setfd(s, sock:getfd())
   8	      sock:setfd(core.invalidfd)
   8	      registry[s] = ctx
   8	      return s
    	   end
***0	   return nil, msg 
    	end
    	
    	--
    	-- Extract connection information.
    	--
    	local function info(ssl, field)
    	  local str, comp, err, protocol
***0	  comp, err = core.compression(ssl)
***0	  if err then
***0	    return comp, err
    	  end
    	  -- Avoid parser
***0	  if field == "compression" then
***0	    return comp
    	  end
***0	  local info = {compression = comp}
***0	  str, info.bits, info.algbits, protocol = core.info(ssl)
***0	  if str then
***0	    info.cipher, info.protocol, info.key,
***0	    info.authentication, info.encryption, info.mac =
***0	        string.match(str, 
***0	          "^(%S+)%s+(%S+)%s+Kx=(%S+)%s+Au=(%S+)%s+Enc=(%S+)%s+Mac=(%S+)")
***0	    info.export = (string.match(str, "%sexport%s*$") ~= nil)
    	  end
***0	  if protocol then
***0	    info.protocol = protocol
    	  end
***0	  if field then
***0	    return info[field]
    	  end
    	  -- Empty?
***0	  return ( (next(info)) and info )
    	end
    	
    	--
    	-- Set method for SSL connections.
    	--
   1	core.setmethod("info", info)
    	

==============================================================================
/usr/local/share/lua/5.2/ssl/https.lua
==============================================================================
    	----------------------------------------------------------------------------
    	-- LuaSec 0.5.1
    	-- Copyright (C) 2009-2015 PUC-Rio
    	--
    	-- Author: Pablo Musa
    	-- Author: Tomas Guisasola
    	---------------------------------------------------------------------------
    	
   1	local socket = require("socket")
   1	local ssl    = require("ssl")
   1	local ltn12  = require("ltn12")
   1	local http   = require("socket.http")
   1	local url    = require("socket.url")
    	
   1	local table  = require("table")
   1	local string = require("string")
    	
   1	local try          = socket.try
   1	local type         = type
   1	local pairs        = pairs
   1	local getmetatable = getmetatable
    	
   1	module("ssl.https")
    	
   1	_VERSION   = "0.5.1"
   1	_COPYRIGHT = "LuaSec 0.5.1 - Copyright (C) 2009-2015 PUC-Rio"
    	
    	-- Default settings
   1	PORT = 443
    	
   1	local cfg = {
   1	  protocol = "tlsv1",
   1	  options  = "all",
   1	  verify   = "none",
    	}
    	
    	--------------------------------------------------------------------
    	-- Auxiliar Functions
    	--------------------------------------------------------------------
    	
    	-- Insert default HTTPS port.
    	local function default_https_port(u)
   8	   return url.build(url.parse(u, {port = PORT}))
    	end
    	
    	-- Convert an URL to a table according to Luasocket needs.
    	local function urlstring_totable(url, body, result_table)
***0	   url = {
    	      url = default_https_port(url),
    	      method = body and "POST" or "GET",
***0	      sink = ltn12.sink.table(result_table)
    	   }
***0	   if body then
***0	      url.source = ltn12.source.string(body)
***0	      url.headers = {
    	         ["content-length"] = #body,
    	         ["content-type"] = "application/x-www-form-urlencoded",
    	      }
    	   end
***0	   return url
    	end
    	
    	-- Forward calls to the real connection object.
    	local function reg(conn)
   8	   local mt = getmetatable(conn.sock).__index
 136	   for name, method in pairs(mt) do
 128	      if type(method) == "function" then
    	         conn[name] = function (self, ...)
 190	                         return method(self.sock, ...)
    	                      end
    	      end
    	   end
    	end
    	
    	-- Return a function which performs the SSL/TLS connection.
    	local function tcp(params)
   8	   params = params or {}
    	   -- Default settings
  32	   for k, v in pairs(cfg) do 
  24	      params[k] = params[k] or v
    	   end
    	   -- Force client mode
   8	   params.mode = "client"
    	   -- 'create' function for LuaSocket
    	   return function ()
   8	      local conn = {}
   8	      conn.sock = try(socket.tcp())
   8	      local st = getmetatable(conn.sock).__index.settimeout
   8	      function conn:settimeout(...)
   8	         return st(self.sock, ...)
    	      end
    	      -- Replace TCP's connection function
   8	      function conn:connect(host, port)
   8	         try(self.sock:connect(host, port))
   8	         self.sock = try(ssl.wrap(self.sock, params))
   8	         try(self.sock:dohandshake())
   8	         reg(self, getmetatable(self.sock))
   8	         return 1
    	      end
   8	      return conn
    	  end
    	end
    	
    	--------------------------------------------------------------------
    	-- Main Function
    	--------------------------------------------------------------------
    	
    	-- Make a HTTP request over secure connection.  This function receives
    	--  the same parameters of LuaSocket's HTTP module (except 'proxy' and
    	--  'redirect') plus LuaSec parameters.
    	--
    	-- @param url mandatory (string or table)
    	-- @param body optional (string)
    	-- @return (string if url == string or 1), code, headers, status
    	--
   1	function request(url, body)
   8	  local result_table = {}
   8	  local stringrequest = type(url) == "string"
   8	  if stringrequest then
***0	    url = urlstring_totable(url, body, result_table)
    	  else
   8	    url.url = default_https_port(url.url)
    	  end
   8	  if http.PROXY or url.proxy then
***0	    return nil, "proxy not supported"
   8	  elseif url.redirect then
***0	    return nil, "redirect not supported"
   8	  elseif url.create then
***0	    return nil, "create function not permitted"
    	  end
    	  -- New 'create' function to establish a secure connection
   8	  url.create = tcp(url)
   8	  local res, code, headers, status = http.request(url)
   8	  if res and stringrequest then
***0	    return table.concat(result_table), code, headers, status
    	  end
   8	  return res, code, headers, status
    	end

==============================================================================
/usr/local/share/lua/5.2/term/colors.lua
==============================================================================
    	-- Copyright (c) 2009 Rob Hoelz <rob@hoelzro.net>
    	--
    	-- Permission is hereby granted, free of charge, to any person obtaining a copy
    	-- of this software and associated documentation files (the "Software"), to deal
    	-- in the Software without restriction, including without limitation the rights
    	-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    	-- copies of the Software, and to permit persons to whom the Software is
    	-- furnished to do so, subject to the following conditions:
    	--
    	-- The above copyright notice and this permission notice shall be included in
    	-- all copies or substantial portions of the Software.
    	--
    	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    	-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    	-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    	-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    	-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    	-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    	-- THE SOFTWARE.
    	
***0	local pairs = pairs
***0	local tostring = tostring
***0	local setmetatable = setmetatable
***0	local schar = string.char
    	
***0	local colors = {}
    	
***0	local colormt = {}
    	
***0	function colormt:__tostring()
  18	    return self.value
    	end
    	
***0	function colormt:__concat(other)
  18	    return tostring(self) .. tostring(other)
    	end
    	
***0	function colormt:__call(s)
   9	    return self .. s .. colors.reset
    	end
    	
    	local function makecolor(value)
***0	    return setmetatable({ value = schar(27) .. '[' .. tostring(value) .. 'm' }, colormt)
    	end
    	
***0	local colorvalues = {
    	    -- attributes
    	    reset      = 0,
    	    clear      = 0,
    	    default    = 0,
    	    bright     = 1,
    	    dim        = 2,
    	    underscore = 4,
    	    blink      = 5,
    	    reverse    = 7,
    	    hidden     = 8,
    	
    	    -- foreground
    	    black   = 30,
    	    red     = 31,
    	    green   = 32,
    	    yellow  = 33,
    	    blue    = 34,
    	    magenta = 35,
    	    cyan    = 36,
    	    white   = 37,
    	
    	    -- background
    	    onblack   = 40,
    	    onred     = 41,
    	    ongreen   = 42,
    	    onyellow  = 43,
    	    onblue    = 44,
    	    onmagenta = 45,
    	    oncyan    = 46,
    	    onwhite   = 47,
    	}
    	
***0	for c, v in pairs(colorvalues) do
***0	    colors[c] = makecolor(v)
    	end
    	
***0	return colors

==============================================================================
/usr/local/share/lua/5.2/xml/Parser.lua
==============================================================================
    	--[[------------------------------------------------------
    	  # Parser object
    	  
    	  The parser class is used to encapsulate parsing and settings in an object. When
    	  using default settings, it is not necessary to create parser objects and
    	  one can simply use [xml.load](xml.html#load).
    	
    	--]]------------------------------------------------------
   1	local core = require 'xml.core'
   1	local lub  = require 'lub'
   1	local lib  = core.Parser
    	
    	-- ## Parser types
    	-- The following constants can be used with #new when creating a parser.
    	-- Depending on the type, the parser behavior is different. The default type is
    	-- Default.
    	
    	-- Default parser type. Translates xml entities (needs to make an internal
    	-- copy of the lua string).
    	-- lib.Default
    	
    	-- Same as default but trims leading and trailing whitespace.
    	-- lib.TrimWhitespace
    	
    	-- Faster then default, does not translate xml entities. Parses data nodes.
    	-- lib.NonDestructive
    	
    	-- Like xml.NonDestructive but does not parse data nodes.
    	-- lib.Fastest
    	
    	-- Create a new parser. `type` flag is optional. If you are using the default
    	-- parser, you can simply use [xml.load](xml.html#load).
    	-- Usage example:
    	--
    	--   local xml = require 'xml'
    	--   local parser = xml.Parser(xml.Parser.Fastest)
    	-- function lib.new(type)
    	
    	-- Parse an xml string and return a Lua table. See [lua/xml](xml.html)
    	-- for the format of the returned table. Usage:
    	--
    	--   local data = parser:load(some_xml_string)
    	--   --> lua table
    	-- function lib:load(str)
    	
    	-- Parse xml from file `path` and return a Lua table. See [lua/xml](xml.html)
    	-- for the format of the returned table. Usage:
    	--
    	--   local data = parser:loadpath(path_to_file)
    	--   --> lua table
   1	function lib:loadpath(path)
***0	  return self:load(lub.content(path))
    	end
    	
   1	return lib

==============================================================================
/usr/local/share/lua/5.2/xml/init.lua
==============================================================================
    	--[[------------------------------------------------------
    	  # Very fast xml parser for Lua <a href="https://travis-ci.org/lubyk/xml"><img src="https://travis-ci.org/lubyk/xml.png" alt="Build Status"></a> 
    	
    	  This parser uses [RapidXML](http://rapidxml.sourceforge.net/) to parse XML
    	  content.
    	
    	  <html><a href="https://github.com/lubyk/xml"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a></html>
    	
    	  *MIT license* &copy Marcin Kalicinski 2006, 2009, Gaspard Bucher 2014.
    	
    	  ## Installation
    	  
    	  With [luarocks](http://luarocks.org):
    	
    	    $ luarocks install xml
    	  
    	  ## Usage example
    	
    	    local data = xml.load(some_xml)
    	
    	    local xml_string = xml.dump(some_table)
    	
    	--]]-----------------------------------------------------
   1	local lub     = require 'lub'
   1	local lib     = lub.Autoload 'xml'
    	local ipairs, pairs, insert, type,
***0	      match, tostring =
   1	      ipairs, pairs, table.insert, type,
   1	      string.match, tostring
    	
   1	local parser  = lib.Parser()
    	
    	
    	-- Current version respecting [semantic versioning](http://semver.org).
   1	lib.VERSION = '1.1.2'
    	
   1	lib.DEPENDS = { -- doc
    	  -- Compatible with Lua 5.1 to 5.3 and LuaJIT
   1	  'lua >= 5.1, < 5.4',
    	  -- Uses [Lubyk base library](http://doc.lubyk.org/lub.html)
    	  'lub >= 1.0.3, < 2',
   1	}
    	
    	-- nodoc
   1	lib.DESCRIPTION = {
   1	  summary = "Very fast xml parser based on RapidXML",
    	  detailed = [[
    	    This module is part of the Lubyk project.
    	
    	    Main features are:
    	     - Fast and easy to use
    	     - Complete documentation
    	     - Based on proven code (RapidXML)
    	     - Full test coverage
    	
    	    Read the documentation at http://doc.lubyk.org/xml.html.
   1	  ]],
   1	  homepage = "http://doc.lubyk.org/"..lib.type..".html",
   1	  author   = "Gaspard Bucher",
   1	  license  = "MIT",
   1	}
    	
    	-- nodoc
   1	lib.BUILD = {
   1	  github    = 'lubyk',
   1	  includes  = {'include', 'src/bind', 'src/vendor'},
   1	  platlibs = {
   1	    linux  = {'stdc++'},
   1	    macosx = {'stdc++'},
   1	  },
    	  -- FIXME: Implement platform flags for lut.Builder and see how it works with
    	  -- luarocks /EHsc is needed for exception handling.
   1	  platflags = {
   1	    win32 = {'EHsc'},
   1	  },
   1	}
    	
    	--[[
    	
    	  # Lua table format
    	
    	  This xml library uses string keys in Lua tables to store
    	  attributes and numerical keys for sub-nodes. Since the 'xml'
    	  attribute is not allowed in XML, we use this key to store the
    	  tag. Here is an example of Lua content:
    	
    	  ## Lua
    	
    	    {xml='document',
    	      {xml = 'article',
    	        {xml = 'p', 'This is the first paragraph.'},
    	        {xml = 'h2', class = 'opt', 'Title with opt style'},
    	      },
    	      {xml = 'article',
    	        {xml = 'p', 'Some ', {xml = 'b', 'important'}, ' text.'},
    	      },
    	    }
    	
    	  ## XML
    	
    	  And the equivalent xml:
    	
    	    #txt
    	    <document>
    	      <article>
    	        <p>This is the first paragraph.</p>
    	        <h2 class='opt'>Title with opt style</h2>
    	      </article>
    	      <article>
    	        <p>Some <b>important</b> text.</p>
    	      </article>
    	    </document>
    	
    	  # Notes on speed
    	
    	  RapidXML is a very fast parser that uses in-place modification of the input
    	  text. Since Lua strings are immutable, we have to make a copy except for the
    	  xml.Parser.NonDestructive and xml.Parser.Fastest settings. With these types
    	  some xml entities such as `&amp;lt;` are not translated.
    	
    	  See [RapidXML](http://rapidxml.sourceforge.net/) for details.
    	--]]------------------------------------------------------
    	
    	-- # Class methods
    	
    	-- Parse a `string` containing xml content and return a table. Uses
    	-- xml.Parser with the xml.Parser.Default type.
   1	function lib.load(string)
***0	  return parser:load(string)
    	end
    	
    	-- Parse the XML content of the file at `path` and return a lua table. Uses
    	-- xml.Parser with the xml.Parser.Default type.
   1	function lib.loadpath(path)
***0	  return parser:load(lub.content(path))
    	end
    	
    	local function escape(v)
***0	  if type(v) == 'boolean' then
***0	    return v and 'true' or 'false'
    	  else
***0	    return v:gsub('&','&amp;'):gsub('>','&gt;'):gsub('<','&lt;'):gsub("'",'&apos;')
    	  end
    	end
    	
    	local function tagWithAttributes(data)
***0	  local res = data.xml or 'table'
***0	  for k,v in pairs(data) do
***0	    if k ~= 'xml' and type(k) == 'string' then
***0	      res = res .. ' ' .. k .. "='" .. escape(v) .. "'"
    	    end
    	  end
***0	  return res
    	end
    	
    	local function doDump(data, indent, output, last, depth, max_depth)
***0	  if depth > max_depth then
***0	    error(string.format("Could not dump table to XML. Maximal depth of %i reached.", max_depth))
    	  end
    	
***0	  if data[1] then
***0	    insert(output, (last == 'n' and indent or '')..'<'..tagWithAttributes(data)..'>')
***0	    last = 'n'
***0	    local ind = indent..'  '
***0	    for _, child in ipairs(data) do
***0	      local typ = type(child)
***0	      if typ == 'table' then
***0	        doDump(child, ind, output, last, depth + 1, max_depth)
***0	        last = 'n'
***0	      elseif typ == 'number' then
***0	        insert(output, tostring(child))
    	      else
***0	        local s = escape(child)
***0	        insert(output, s)
***0	        last = 's'
    	      end
    	    end
***0	    insert(output, (last == 'n' and indent or '')..'</'..(data.xml or 'table')..'>')
***0	    last = 'n'
    	  else
    	    -- no children
***0	    insert(output, (last == 'n' and indent or '')..'<'..tagWithAttributes(data)..'/>')
***0	    last = 'n'
    	  end
    	end
    	
    	-- Dump a lua table in the format described above and return an XML string. The
    	-- `max_depth` parameter is used to avoid infinite recursion in case a table
    	-- references one of its ancestors.
    	--
    	-- Default maximal depth is 3000.
   1	function lib.dump(table, max_depth)
***0	  local max_depth = max_depth or 3000
***0	  local res = {}
***0	  doDump(table, '\n', res, 's', 1, max_depth)
***0	  return lub.join(res, '')
    	end
    	
    	
    	local function doRemoveNamespace(data, prefix)
***0	  data.xml = match(data.xml, prefix .. ':(.*)') or data.xml
***0	  for _, sub in ipairs(data) do
***0	    if type(sub) == 'table' then
***0	      doRemoveNamespace(sub, prefix)
    	    end
    	  end
    	end
    	
    	-- This function finds the `xmlns:NAME='KEY'` declaration and removes `NAME:` from
    	-- the tag names.
    	--
    	-- Example:
    	--
    	--   local data = xml.load [[
    	--    <foo:document xmlns:foo='bar'>
    	--      <foo:name>Blah</foo:name>
    	--    </foo:document>
    	--   ]]
    	--   
    	--   xml.removeNamespace(data, 'bar')
    	--
    	--   -- Result
    	--   {xml = 'document', ['xmlns:foo'] = 'bar',
    	--     {xml = 'name', 'Blah'},
    	--   }
   1	function lib.removeNamespace(data, key)
    	  local nm
***0	  for k, v in pairs(data) do
***0	    if v == key then
***0	      nm = match(k, 'xmlns:(.*)')
***0	      if nm == '' then
    	        -- error
***0	        return
    	      else
***0	        doRemoveNamespace(data, nm)
    	      end
    	    end
    	  end
    	end
    	
    	-- Recursively find the first table with a tag equal to `tag`. This
    	-- search uses [lub.search](lub.html#search) to do an [Iterative deepening depth-first search](https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search)
    	-- because we usually search for elements close to the surface.
    	--
    	-- For more options, use [lub.search](lub.html#search) directly with a custom
    	-- function.
    	--
    	-- You can also pass an attribute key and attribute value to further filter the
    	-- searched node. This gives this function the same arguments as LuaXML's find
    	-- function.
    	--
    	-- Usage examples:
    	--
    	--   local sect = xml.find(elem, 'simplesect', 'kind', 'section')
    	--
    	--   print(xml.find(sect, 'title'))
   1	function lib.find(data, tag, attr_key, attr_value)
***0	  if attr_key then
***0	    return lub.search(data, function(node)
***0	      if node.xml == tag and node[attr_key] == attr_value then
***0	        return node
    	      end
    	    end)
    	  else
***0	    return lub.search(data, function(node)
***0	      if node.xml == tag then
***0	        return node
    	      end
    	    end)
    	  end
    	end
    	
    	-- # Classes
    	
   1	return lib

==============================================================================
tests/tests_spec.lua
==============================================================================
   1	require 'busted.runner'()
   1	local pp = require('../src/pprint')
    	
   2	describe("Dropbox", function()
    	  local dropbox
    	
   2	  setup(function()
   1	    dropbox = require('../src/dropbox')
   1	    dropbox.set_token (os.getenv("DROPBOX_TOKEN") or "ya_AImewNWcAAAAAAAEM80Z9EQrHTetStxFD-KzkSvAu42YcxS5DD618otOS1Eoy")
    	  end)
    	
   2	  describe("#folders", function()
   1	    local fname = '/a_testfolder'
    	
   2	    it("can be created", function()
   1	      local result, err = dropbox.create_folder(fname)
   1	      assert.falsy(err)
   1	      assert.is.equal(string.lower(fname), result.path_lower)
    	    end)
    	
   2	    it("yields #error if created without a name", function()
   1	      local result, err = dropbox.create_folder("")
   1	      assert.truthy(err)
    	    end)
    	
   2	    it("can be listed", function()
   1	      local result = dropbox.list_folder(fname)
   1	      assert.is.truthy(result.entries)
   1	      assert.is.equal(0, #result.entries)
    	    end)
    	
   2	    it("can be deleted", function()
   1	      local result = dropbox.delete(fname)
   1	      assert.is.equal("folder", result[".tag"])
   1	      assert.is.equal(string.lower(fname), result.path_lower)
    	    end)
    	  end)
    	
   2	  describe("#files", function()
   1	    local fname = "/a_testfile.txt"
   1	    local fname_copy = "/a_testfile_copy.txt"
   1	    local content = "This is the content of the text file"
    	
   2	    teardown(function()
   1	      local result = dropbox.delete(fname_copy)
    	    end)
    	
   2	    it("can be created with a string", function()
   1	      local result = dropbox.upload(fname, content)
   1	      assert.is.equal(string.lower(fname), result.path_lower)
   1	      assert.is.equal(#content, result.size)
    	    end)
    	
   2	    it("can be copied", function()
   1	      local result = dropbox.copy(fname, fname_copy)
   1	      assert.is.equal("file", result[".tag"])
   1	      assert.is.equal(string.lower(fname_copy), result.path_lower)
    	    end)
    	
   2	    it("can be deleted", function()
   1	      local result = dropbox.delete(fname)
   1	      assert.is.equal("file", result[".tag"])
   1	      assert.is.equal(string.lower(fname), result.path_lower)
    	    end)
    	  end)
    	
    	--[[
    	  describe("#louis", function()
    	    it("iterate over test_10000 folder with 2805 items", function()
    	      local result = dropbox.list_folder('/test_10000', false, false, false)
    	      local i = 0
    	      for entry, pos in dropbox.cursor(result) do
    	        i = i + 1
    	      end
    	      assert(2805, i)
    	    end)
    	  end)
    	  ]]
    	end)

==============================================================================
Summary
==============================================================================

55	12	82.09%	.////src/dropbox.lua
34	210	13.93%	.////src/pprint.lua
34	210	13.93%	./src/pprint.lua
52	100	34.21%	/Users/louis77/.luarocks/share/lua/5.2/ltn12.lua
18	20	47.37%	/Users/louis77/.luarocks/share/lua/5.2/mime.lua
30	48	38.46%	/Users/louis77/.luarocks/share/lua/5.2/socket.lua
97	0	100.00%	/Users/louis77/.luarocks/share/lua/5.2/socket/headers.lua
149	42	78.01%	/Users/louis77/.luarocks/share/lua/5.2/socket/http.lua
82	57	58.99%	/Users/louis77/.luarocks/share/lua/5.2/socket/url.lua
68	23	74.73%	/usr/local/share/lua/5.2/busted/block.lua
15	19	44.12%	/usr/local/share/lua/5.2/busted/compatibility.lua
45	34	56.96%	/usr/local/share/lua/5.2/busted/context.lua
68	103	39.77%	/usr/local/share/lua/5.2/busted/core.lua
6	15	28.57%	/usr/local/share/lua/5.2/busted/environment.lua
14	13	51.85%	/usr/local/share/lua/5.2/busted/execute.lua
23	49	31.94%	/usr/local/share/lua/5.2/busted/init.lua
37	1	97.37%	/usr/local/share/lua/5.2/busted/languages/en.lua
10	1	90.91%	/usr/local/share/lua/5.2/busted/modules/files/lua.lua
6	46	11.54%	/usr/local/share/lua/5.2/busted/modules/files/moonscript.lua
28	24	53.85%	/usr/local/share/lua/5.2/busted/modules/filter_loader.lua
8	9	47.06%	/usr/local/share/lua/5.2/busted/modules/output_handler_loader.lua
41	6	87.23%	/usr/local/share/lua/5.2/busted/modules/test_file_loader.lua
65	35	65.00%	/usr/local/share/lua/5.2/busted/outputHandlers/base.lua
59	53	52.68%	/usr/local/share/lua/5.2/busted/outputHandlers/utfTerminal.lua
48	56	46.15%	/usr/local/share/lua/5.2/busted/runner.lua
22	2	91.67%	/usr/local/share/lua/5.2/busted/status.lua
30	320	8.57%	/usr/local/share/lua/5.2/luarocks/deps.lua
48	40	54.55%	/usr/local/share/lua/5.2/luarocks/loader.lua
13	165	7.30%	/usr/local/share/lua/5.2/luarocks/path.lua
21	55	27.63%	/usr/local/share/lua/5.2/luassert/assert.lua
11	203	5.14%	/usr/local/share/lua/5.2/luassert/assertions.lua
1	10	9.09%	/usr/local/share/lua/5.2/luassert/modifiers.lua
46	106	30.26%	/usr/local/share/lua/5.2/luassert/util.lua
20	18	52.63%	/usr/local/share/lua/5.2/lub/Autoload.lua
62	247	20.06%	/usr/local/share/lua/5.2/lub/init.lua
5	5	50.00%	/usr/local/share/lua/5.2/md5.lua
41	26	61.19%	/usr/local/share/lua/5.2/mediator.lua
7	81	7.95%	/usr/local/share/lua/5.2/moonscript/base.lua
59	170	25.76%	/usr/local/share/lua/5.2/pl/dir.lua
37	170	17.87%	/usr/local/share/lua/5.2/pl/path.lua
27	361	6.96%	/usr/local/share/lua/5.2/pl/tablex.lua
5	48	9.43%	/usr/local/share/lua/5.2/pl/types.lua
8	182	4.21%	/usr/local/share/lua/5.2/pl/utils.lua
84	76	52.50%	/usr/local/share/lua/5.2/requests.lua
11	14	44.00%	/usr/local/share/lua/5.2/say/init.lua
40	43	48.19%	/usr/local/share/lua/5.2/ssl.lua
52	11	82.54%	/usr/local/share/lua/5.2/ssl/https.lua
3	14	17.65%	/usr/local/share/lua/5.2/term/colors.lua
5	1	83.33%	/usr/local/share/lua/5.2/xml/Parser.lua
33	52	38.82%	/usr/local/share/lua/5.2/xml/init.lua
41	0	100.00%	tests/tests_spec.lua
------------------------
1824	3606	33.59%	
